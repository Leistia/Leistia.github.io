<!DOCTYPE HTML>
<html lang="zh-CN">




<head>
    <meta charset="utf-8">
    <meta name="keywords" content="IO流详解, 嘟噜嘟~">
    <meta name="description" content="嘟噜噜~">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>IO流详解 | 嘟噜嘟~</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
 
<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>








<body>
   

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">嘟噜嘟~</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/develop">
          
          <i class="fas fa-tags" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>开发技术</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/dailyLife">
          
          <i class="fas fa-tags" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>日常</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/galleries" class="waves-effect waves-light">
      
      <i class="fas fa-image" style="zoom: 0.6;"></i>
      
      <span>相册</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/Medias/music">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Music</span>
        </a>
      </li>
      
      <li>
        <a href="/Medias/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/Medias/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">嘟噜嘟~</div>
        <div class="logo-desc">
            
            嘟噜噜~
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-bookmark"></i>
			
			分类
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/categories/develop " style="margin-left:75px">
				  
				   <i class="fa fas fa-tags" style="position: absolute;left:50px" ></i>
			      
		          <span>开发技术</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/dailyLife " style="margin-left:75px">
				  
				   <i class="fa fas fa-tags" style="position: absolute;left:50px" ></i>
			      
		          <span>日常</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/galleries" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-image"></i>
			
			相册
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/Medias/music " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Music</span>
                  </a>
                </li>
              
                <li>

                  <a href="/Medias/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/Medias/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    
  
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">IO流详解</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/">
                                <span class="chip bg-color"></span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/" class="post-category">
                                
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-09-16
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-03-14
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    166.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    609 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html">https://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Np4y1z7BU/">https://www.bilibili.com/video/BV1Np4y1z7BU/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yerenyuan_pku/category_11163055.html">https://blog.csdn.net/yerenyuan_pku/category_11163055.html</a></p>
<hr>
<h1 id="省流总结"><a href="#省流总结" class="headerlink" title="省流总结"></a>省流总结</h1><h2 id="介绍与大纲"><a href="#介绍与大纲" class="headerlink" title="介绍与大纲"></a>介绍与大纲</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>（Design Pattern）代表了最佳的实践，在面向对象的编程中被很多老鸟们反复使用。那么，使用设计模式究竟有哪些好处呢？看一看下面就知道了，其实还远不止这些好处。</p>
<ul>
<li>可重用代码。</li>
<li>保证代码可靠性。</li>
<li>使代码更易被他人理解。</li>
<li>······</li>
</ul>
<p>毫无疑问，设计模式于己、于人、于系统都是多赢的。设计模式之于程序员，就好比圣经之于耶稣信徒一样，意义可想而知！</p>
<h3 id="设计模式（Design-Pattern）代表了最佳的实践，在面向对象的编程中被很多老鸟们反复使用。使用设计模式有很多好处："><a href="#设计模式（Design-Pattern）代表了最佳的实践，在面向对象的编程中被很多老鸟们反复使用。使用设计模式有很多好处：" class="headerlink" title="设计模式（Design Pattern）代表了最佳的实践，在面向对象的编程中被很多老鸟们反复使用。使用设计模式有很多好处："></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>（Design Pattern）代表了最佳的实践，在面向对象的编程中被很多老鸟们反复使用。使用设计模式有很多好处：</h3><ul>
<li>可重用代码</li>
<li>保证代码可靠性</li>
<li>使代码更易被他人理解</li>
<li>…</li>
</ul>
<p>毫无疑问，设计模式于己、于人、于系统都是多赢的。《设计模式》之于程序员，就好比《圣经》之于耶稣信徒一样，意义可想而知！</p>
<h3 id="什么是-GoF"><a href="#什么是-GoF" class="headerlink" title="什么是 GoF"></a>什么是 GoF</h3><p>谈及设计模式，必然离不开 GoF：</p>
<p>GoF：Gang of Four，也称为“四人组”，即：EErich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人。</p>
<p>1994 年，这几位大牛合著出版了一本名为《Design Patterns: Elements of Reusable Object-Oriented Software》（即：《设计模式》）的书。该书首次提到了软件开发中设计模式的概念，将设计模式提升到理论高度，并将之规范化。书中提及了 23 种基本设计模式，时至今日，在可复用面向对象软件的发展过程中，新的设计模式仍然不断出现。</p>
<p><img src="/./assets/1709707797073-2f2274ad-3f9a-41e0-9008-d2278853fb9c.png" alt="img"></p>
<p>这就是传说中的“风尘四侠”，比起国外的其他技术大咖（不修边幅），看起来要好很多O(∩_∩)O。</p>
<h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><p>根据《设计模式》参考书，共有 23 种设计模式，这些模式可以分为三类：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式（Creational Patterns）</td>
<td>用于构建对象，以便它们可以从实现系统中分离出来。</td>
</tr>
<tr>
<td>结构型模式（Structural Patterns）</td>
<td>用于在许多不同的对象之间形成大型对象结构。</td>
</tr>
<tr>
<td>行为型模式（Behavioral Patterns）</td>
<td>用于管理对象之间的算法、关系和职责。</td>
</tr>
</tbody></table>
<h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><ul>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/61615495">单例模式</a>（Singleton Pattern）<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/70653800">抽象工厂模式</a> （Abstract Factory Pattern）<br>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/66968761">建造者模式</a>（Builder Pattern）<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/70652858">工厂方法模式</a> （Factory Method Pattern）<br>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/66969965">原型模式</a>（Prototype Pattern）<br>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li>
</ul>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><ul>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/66973296">适配器模式</a>（Adapter Pattern）<br>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79501177">桥接模式</a>（Bridge Pattern）<br>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/66973836">装饰者模式</a>（Decorator Pattern）<br>动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/71240662">组合模式</a>（Composite Pattern）<br>将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/70850367">外观模式</a>（Facade Pattern）<br>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79629690">享元模式</a>（Flyweight Pattern）<br>运用共享技术有效地支持大量细粒度的对象。</li>
<li><a target="_blank" rel="noopener" href="https://waleon.blog.csdn.net/article/details/78533179">代理模式</a>（Proxy Pattern）<br>为其他对象提供一个代理以控制对这个对象的访问。</li>
</ul>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><ul>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79403900">模版方法模式</a> （Template Method Pattern）<br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/62060457">命令模式</a>（Command Pattern）<br>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</li>
<li>迭代器模式（Iterator Pattern）<br>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/61925314">观察者模式</a>（Observer Pattern）<br>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79242388">中介者模式</a>（Mediator Pattern）<br>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79292435">备忘录模式</a> （Memento Pattern）<br>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</li>
<li>解释器模式（Interpreter Pattern）<br>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/78647519">状态模式</a>（State Pattern）<br>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79242297">策略模式</a>（Strategy Pattern）<br>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79077715">职责链模式</a> （Chain of Responsibility Pattern）<br>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</li>
<li><a target="_blank" rel="noopener" href="http://waleon.blog.csdn.net/article/details/79364406">访问者模式</a> （Visitor Pattern）<br>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ul>
<h3 id="N问设计模式"><a href="#N问设计模式" class="headerlink" title="N问设计模式"></a>N问设计模式</h3><h4 id="GoF四人组提出的设计模式，至今仍被人津津乐道，但是你又了解多少呢？"><a href="#GoF四人组提出的设计模式，至今仍被人津津乐道，但是你又了解多少呢？" class="headerlink" title="GoF四人组提出的设计模式，至今仍被人津津乐道，但是你又了解多少呢？"></a>GoF四人组提出的设计模式，至今仍被人津津乐道，但是你又了解多少呢？</h4><p>你可能：</p>
<ul>
<li>没听过</li>
<li>听说过，但不知道具体能干嘛</li>
<li>了解，会用其中的两三种</li>
<li>熟悉，能根据实际情况快速设计</li>
<li>精通，游刃有余</li>
</ul>
<p>第一种：“虽然不懂你们在说什么，但是貌似很厉害的样子”。大牛才会用到的东西，高端而又神秘！</p>
<p>最后一种：“已上天，正和太阳肩并肩”。心中未曾想用设计模式，写出的代码却处处都是。倘若你和我一样，属于其他情况，嘿嘿😊，那么，就认真学习吧！</p>
<h4 id="设计模式能带给你什么？"><a href="#设计模式能带给你什么？" class="headerlink" title="设计模式能带给你什么？"></a>设计模式能带给你什么？</h4><p>看下下面这张人类演变图。</p>
<p><img src="/./assets/1709707347479-a42351cb-e940-4e96-b14a-8e401caffea2.png" alt="img"></p>
<p>从”猿猴→程序猿”的巨变，怎么样，是不是很炫酷啊？</p>
<h4 id="有些人说设计模式没用，真是这样吗？"><a href="#有些人说设计模式没用，真是这样吗？" class="headerlink" title="有些人说设计模式没用，真是这样吗？"></a>有些人说设计模式没用，真是这样吗？</h4><p>引用一句哲学名言：存在即合理。当然，若要扯非OO语言，也许真没什么用！但可以肯定的是，非OO语言完全可以借鉴OO的思想，设计模式也不例外！</p>
<h4 id="设计模式有多重要？"><a href="#设计模式有多重要？" class="headerlink" title="设计模式有多重要？"></a>设计模式有多重要？</h4><p>要做一位大神或所谓的高手，基本之一就是要懂得若干设计模式。设计模式是软件工程的基石脉络，如同大厦的结构一样，你说有多重。</p>
<p>对了，还有面试要考！设计模式有多重要勿须我再费口舌了。</p>
<h4 id="怎么学习设计模式？"><a href="#怎么学习设计模式？" class="headerlink" title="怎么学习设计模式？"></a>怎么学习设计模式？</h4><p>设计模式不是基于理论发明的，而是先有问题场景，再基于需求和情景不断演化设计方案，最后把一些方案标准化成”模式”。</p>
<p>所以，通过实际案例学习是最好的！在讨论每一个设计模式时，要尽量用生活中的真实问题来理解和分析，然后尝试一步步地阐述设计，并以一个能匹配某些模式的设计收尾。</p>
<h4 id="如何选择设计模式？"><a href="#如何选择设计模式？" class="headerlink" title="如何选择设计模式？"></a>如何选择设计模式？</h4><p>设计模式是针对某种情景下某种问题的某种解决方案，也就是说，每个模式都有自己的使用场景、使用方法和使用后果。正所谓物有两极，各模式也存在相应的优缺点，得其优，而避其劣，终得之！</p>
<hr>
<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>接下来，我不妨带领大家看看设计模式这门课的教程大纲吧，如下图所示。</p>
<p><img src="/./assets/1709375854851-1c931564-1de1-4bfd-8bbd-32eb05f1cef4.png" alt="img"></p>
<hr>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>在第一章中，我们要学习的内容分为三个部分，它们分别是：</p>
<ul>
<li>设计模式概述：我们总得了解什么是设计模式吧！</li>
<li>UML图：在后面设计模式的学习过程中，我们会遇到大量的类图，而它们就属于UML图</li>
<li>软件设计原则：未来我们作为一个架构师要去设计咱们的软件的话，总得知道所设计的软件应该要满足一个什么样的原则吧！</li>
</ul>
<p>接下来，咱们首先先来看一下第一部分所要学习的内容，即设计模式的概述。设计模式的概述我会就以下四部分进行讲解。</p>
<ol>
<li>软件设计模式产生背景</li>
<li>软件设计模式的概念</li>
<li>学习设计模式的必要性</li>
<li>设计模式的分类</li>
</ol>
<p>然后，咱们再来聊一下第二部分所要学习的内容，即UML图。大家要注意了，在这一块我们重点学习的就是类图。</p>
<p>最后，咱们再来聊一下第三部分所要学习的内容，即软件设计原则。软件设计原则有如下6个原则：</p>
<ol>
<li><strong>开闭原则          (利用抽象实现拓展)</strong></li>
<li><strong>里氏代换原则   (提取接口时只提取共有的部分)</strong></li>
<li><strong>依赖倒转原则   (同开闭原则)</strong></li>
<li><strong>接口隔离原则   (<strong><strong>依赖最少,最细拆分接口</strong></strong>)</strong></li>
<li><strong>迪米法特原则   (中介)</strong></li>
<li><strong>合成复用原则   (<strong><strong>尽量先使用组合或者聚合</strong></strong>)</strong></li>
</ol>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>而创建者模式又可分为如下5种：</p>
<ol>
<li><p><strong>单例模式          ()</strong></p>
</li>
<li><p><strong>工厂方法模式</strong>  </p>
</li>
<li><ol>
<li>简单工厂(加产品要改工厂代码)</li>
<li>简单工厂+配置文件(加产品要改配置文件)<br><img src="/./assets/1709386963661-f2aad69a-4229-4c9a-9750-08d5a5fbe3e6.png" alt="img"></li>
<li>工厂方法(加产品要加工厂实现类)<br><img src="/./assets/1709386964332-bee0211a-a30c-4b60-8456-81551fd93787.png" alt="img"></li>
</ol>
</li>
<li><p><strong>抽象工厂模式</strong></p>
</li>
</ol>
<p>工厂方法模式只生产同一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p><img src="/./assets/1709435132215-83dc7095-19cd-449e-b64c-9c05ae835b74.png" alt="img"></p>
<ol>
<li>**原型模式          (实现clone()方法)<br>**<img src="/./assets/1709438946794-8b0967d0-a489-46a2-b9b6-af7efac5fb6b.png" alt="img"></li>
<li>**建造者模式      ()<br>**<img src="/./assets/1709439941272-044c9da4-cd14-4d20-a4c7-32d0a90a7b8c.png" alt="img"></li>
</ol>
<hr>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>结构型模式又可分为如下7种：</p>
<ol>
<li><p>**代理模式      (静态,jdk,CGlib)<br><strong><img src="/./assets/1709441899079-39c3ff8e-0a29-454d-b941-81509e408e40.png" alt="img"></strong></p>
<p>**</p>
</li>
<li><p><strong>适配器模式  ()</strong></p>
</li>
<li><ol>
<li><p>**类适配器模式<br>**<img src="/./assets/1709450080770-9a5f448b-6658-42ce-9bc5-80521c9c172e.png" alt="img"></p>
</li>
<li><p>**对象适配器模式<br><strong><img src="/./assets/1709450080796-a27e486a-bb36-4ee5-ae6e-89607a5d421d.png" alt="img"></strong></p>
<p>**</p>
</li>
</ol>
</li>
<li><p>**装饰者模式  (<strong>同类A组合同类B,从而增强B的功能</strong>)<br>**<img src="/./assets/1709541440117-2a982db5-963d-43df-b25c-58fdfecdbbd7.png" alt="img"></p>
</li>
<li><p>**组合模式     (同时继承和聚合抽象根节点)(<strong><strong>和装饰者模式有区别?</strong></strong>)<br><strong><img src="/./assets/1709469973975-86b5ae0a-4ee1-4200-a9b5-a040c87a01c4.png" alt="img"></strong><br>**<img src="/./assets/1709469973988-ce267add-4d72-46bd-b054-4b2bdbfa6af7.png" alt="img"></p>
</li>
<li><p>**桥接模式     (组合)<br>**<img src="/./assets/1709469808476-62c58961-64d2-4496-836b-4ae789c4bb88.png" alt="img"></p>
</li>
<li><p>**外观模式     (迪米法特原则实现)<br>**<img src="/./assets/1709469877098-0c8febd3-3a87-4ad6-aecc-870552ee2203.png" alt="img"></p>
</li>
<li><p><strong>享元模式     (单例工厂维护共享对象池)</strong></p>
</li>
<li><p><img src="/./assets/1709470052606-8bc7f23c-4abf-459e-be6e-2e23f7d36da6.png" alt="img"></p>
</li>
</ol>
<hr>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>行为型模式又可分为如下11种：</p>
<ol>
<li><strong>模板方法模式   (<strong>抽象类的具体方法调用自己的抽象方法</strong>)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709470438664-21df4e92-4bcb-425c-84a6-ae2f39580c6a.png" alt="img"></p>
<ol>
<li><strong>策略模式          (有点像桥接)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709470465981-4ea87881-4f78-4395-8d40-008fcdb67fe1.png" alt="img"></p>
<ol>
<li><strong>命令模式         (调用者创建命令,命令调用接收者)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709612487639-3e7aaecd-f938-41dc-bf8d-8d14f52554b1.png" alt="img"></p>
<ol>
<li><strong>观察者模式     (像命令模式)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709612749311-06325bf9-74d2-49e4-81c4-9a460d89f8ce.png" alt="img"></p>
<ol>
<li><strong>责任链模式     (自己聚合自己形成一条链)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709615987584-100f04fa-5509-459a-83b5-72bd1326963e.png" alt="img"></p>
<ol>
<li><strong>状态模式        (省流:复杂,开闭原则不好,不如写到swich里直观)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709612651473-4749ceb6-0fe4-421e-b7b7-4358f79e0f47.png" alt="img"></p>
<ol>
<li><strong>中介者模式      ()</strong></li>
</ol>
<p>**<br><strong><img src="/./assets/1709706458373-1b4a9cd2-dcc3-49f9-87df-c471396acfa3.png" alt="img"></strong><br><strong><img src="/./assets/1709819979785-f580f39b-4808-44d0-9e38-22224f5c3cd1.png" alt="img"></strong></p>
<p>**</p>
<ol>
<li><strong>迭代器模式    (A类找个B类实现A的功能,这样A的部分功能根据B的不同实现变化 )</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709706524778-2023d12f-ec4e-439c-aff3-1d0f9afc13b6.png" alt="img"></p>
<ol>
<li><strong>访问者模式  (双分派)</strong></li>
</ol>
<p>**<br>**<img src="/./assets/1709986308920-a919ddb9-3c5b-4e31-bc14-578108b76a81.png" alt="img"></p>
<ol>
<li><strong>备忘录模式    (<strong>状态恢复</strong>)</strong></li>
</ol>
<p><img src="/./assets/1709706935115-5fd2a2af-85b2-488c-a131-efbb6632b84d.png" alt="img"></p>
<p>使用黑箱备忘录模式的核心就是要把备忘录角色类定义在发起人角色类的内部，并且将其私有，私有的话，外界就不能去访问了！</p>
<p><img src="/./assets/1709988781290-25e4ac33-61d1-4712-8232-922b8a4d225a.png" alt="img"></p>
<ol>
<li><strong>解释器模式    (文法规则+抽象语法树)</strong></li>
</ol>
<p><img src="/./assets/1709707034622-fea65b5d-201b-45b3-9c72-b3cd092e8e2b.png" alt="img">**<br>**<img src="/./assets/1709998711474-c1cc14b6-e36f-4d73-9492-28c2379cdb77.png" alt="img"></p>
<hr>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>在最后这一章，我们会做一个综合案例，即自定义Spring框架。当然了，我们也只是简单的去模拟Spring里面的一个功能，即Spring里面的IoC功能。</p>
<p>那么如何做到这一点呢？首先，我们得去分析一下Spring核心功能的结构，即分析Spring它是如何做的；然后，确定Spring核心功能使用的设计模式，如果在Spring核心功能里面确定出了它用到了哪些设计模式，那么我们就在自己模拟的过程中，也把这些设计模式给它加入到里面，除此之外，我们还得知道这些设计模式，它们所起到的一个作用，或者说在某个地方使用某种设计模式，它带来的一个好处；最后，就是实现Spring IoC功能了。</p>
<p>至此，设计模式这门课所要学习的内容，我就给大家梳理出来了，是不是一目了然啊！</p>
<hr>
<h1 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1. 设计模式概述"></a>1. 设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1. 软件设计模式的产生背景"></a>1.1. 软件设计模式的产生背景</h2><p>首先，我们来看一下第一章中的第一部分内容，即设计模式概述。而在设计模式概述里面，我们第一个要明了的就是软件设计模式的产生背景。因为我们既然要学习软件设计模式，那么就得知道一下它的背景，我想这是毋庸置疑的。</p>
<p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p>
<p>从这句话中我们可以知道，软件设计模式来源于建筑领域的设计。</p>
<p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了253种关于对城镇、邻里、住宅、花园和房间进行设计的基本模式。</p>
<p>从这句话中，我们第一次了解到了设计模式，只不过这个设计模式，它是属于建筑领域的设计模式。</p>
<p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995年艾瑞克·伽马、理査德·海尔姆、拉尔夫·约翰森、约翰·威利斯迪斯等4位作者合作出版了《设计模式：可复用面向对象软件的基础》这一本书，在此书中收录了23个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这4位作者在软件开发领域里也以他们的”四人组”（Gang of Four，简称GoF）著称。</p>
<p>很明显，我们所要学习的设计模式其实就是以上提到的这23种设计模式，而且，另外一点，大家也一定要记住，GoF我们在后面也会遇到，它指的其实就是以上这4个人的一个简称。</p>
<h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2. 软件设计模式的概念"></a>1.2. 软件设计模式的概念</h2><p>知道了软件设计模式的产生背景之后，我们就得来了解了解软件设计模式的概念了，软件设计模式的概念如下：</p>
<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p>
<p>这句话读起来还是有点绕口的，不过大家一定要知道一点，就是软件设计模式它并不是什么新的技术，而是代码设计经验的一个总结，即总结出来的一些套路。谁总结出来的呢？其实就是软件开发的那些前辈们，他们在软件开发过程中遇到了一些问题，然后针对这些问题他们提供好了解决的方案，而这些解决方案就是总结出来的一些套路，也可以说成是设计模式。</p>
<p>那么，以后我们在设计咱们自己的软件过程中，就可以将这些设计模式套用到我们自己的软件中了，从而使得我们的程序变得更加完美，软件设计得更加完美。</p>
<hr>
<h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3. 学习设计模式的必要性"></a>1.3. 学习设计模式的必要性</h2><p>为什么要学习设计模式呢？我们可以看一下下面这句话。</p>
<p>设计模式的本质是面向对象设计原则的实际应用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p>
<p>我在上面也已经说过了，设计模式它并不是一门新的技术，而是对于我们之前学习的面向对象开发的一个实际的应用。之前我们学完了面向对象开发之后，想必你会有很多感触，我想第一个感触就是面向对象开发它到底有什么用，以及在我们以后真正的软件开发中又能起到什么作用？我想你只要学完设计模式这门课，就能有更深的体会了，因为实践出真知嘛！</p>
<p>以上那句话的后半句中的类的关联关系和组合关系，现在如果你还不理解的话，也没关系，因为后面我会对它作一个详细的讲解。</p>
<p>其次，我们应该还要知道正确使用设计模式所具有的如下几个优点。</p>
<ul>
<li>可以提高程序员的思维能力（即让我们的思维更加开阔，如果后期我们要去设计咱们的软件的话，那么就能套用这些设计模式去设计咱们的软件了）、编程能力和设计能力。当然，在这里我们更强调的是设计能力</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li>
</ul>
<p>以上说的这些优点，字面意思都看得懂，但问题是现在体现不出来，因为我们还没有学习到这些设计模式。等我们学完了设计模式之后，大家不妨再来深刻地体会一下这些好处。</p>
<h2 id="1-4-设计模式的分类"><a href="#1-4-设计模式的分类" class="headerlink" title="1.4. 设计模式的分类"></a>1.4. 设计模式的分类</h2><p>通过前面的学习，我们知道设计模式有23种，而且想必大家也知道了这23种设计模式又可分成三大类，即：</p>
<ul>
<li>创建型模式</li>
<li>结构型模式</li>
<li>行为型模式</li>
</ul>
<p>那么接下来，我再来为大家一个一个地详细介绍下这些分类。</p>
<h3 id="1-4-1-创建型模式"><a href="#1-4-1-创建型模式" class="headerlink" title="1.4.1. 创建型模式"></a>1.4.1. 创建型模式</h3><p>什么是创建型模式呢？大家看下面这句话便能知道答案了。</p>
<p>用于描述”怎样创建对象”，它的主要特点是”将对象的创建与使用分离”。</p>
<p>看到这儿的话，有些同学可能会想，创建对象这个谁不会啊！不就是new一个对象嘛！比如说现在有一个Student类，那么要创建对象的话，new一个Student不就行了嘛，这样对象就创建好了。</p>
<p>不错，这说的没有任何问题，但是我们现在讨论的是创建型模式啊！而它最主要的特点就是将对象的创建和使用分离。可按照我们之前的做法，更多的是创建好对象之后，就开始使用这个对象了，那么从某种意义上来说，创建型模式其实就是进行了一个解耦。</p>
<p>最后，我们再看一下GoF四人组，他们的书中都提供了哪些创建型模式，我也不废话，直接就列出来了，如下所示，提供了5种创建型模式。</p>
<ol>
<li>单例模式</li>
<li>原型模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
</ol>
<h3 id="1-4-2-结构型模式"><a href="#1-4-2-结构型模式" class="headerlink" title="1.4.2. 结构型模式"></a>1.4.2. 结构型模式</h3><p>什么是结构型模式呢？大家看下面这句话便能知道答案了。</p>
<p>结构型模式用于描述如何将类和对象按照某种布局组成更大的结构。</p>
<p>这句话，怎么去理解呢？我来举个例子吧！比如说，你现在要盖房，那么创建型模式就好比你去购买盖房所需要的材料，如钢筋、水泥等等，然后用这些材料你就能搭起来整个房屋的架构了，这个就是所谓的结构型模式。</p>
<p>那么GoF四人组他们在自己的书中提供了哪些结构型模式呢？大家也不用翻书了，我直接列出来了，如下所示，提供了7种结构型模式：</p>
<ol>
<li>代理模式</li>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰者模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>组合模式</li>
</ol>
<h3 id="1-4-3-行为型模式"><a href="#1-4-3-行为型模式" class="headerlink" title="1.4.3. 行为型模式"></a>1.4.3. 行为型模式</h3><p>什么是行为型模式呢？大家看下面这句话便能知道答案了。</p>
<p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。</p>
<p>这句话要理解清楚也非常简单，就是多个对象合作去完成某一件事。</p>
<p>那么GoF四人组他们在自己的书中提供了哪些行为型模式呢？大家也不用翻书了，我直接列出来了，如下所示，提供了11种结构型模式：</p>
<ol>
<li>模板方法模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>责任链模式</li>
<li>状态模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
</ol>
<hr>
<hr>
<h1 id="2-UML图"><a href="#2-UML图" class="headerlink" title="2. UML图"></a>2. UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>
<p>UML它到底是什么呢？它被称为统一建模语言（Unified Modeling Language，简称为UML），即用来设计软件的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%AF%E8%A7%86%E5%8C%96&amp;spm=1001.2101.3001.7020">可视化</a>建模语言。其特点是简单、统一、图形化，能表达软件设计中的动态和静态信息。而在本讲中我们所要学习的UML里面的类图，它主要体现的就是静态信息。</p>
<p>下面，我们来看一下UML它包含了哪些图？UML从目标系统的不同角度出发，定义了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%A8%E4%BE%8B%E5%9B%BE&amp;spm=1001.2101.3001.7020">用例图</a>、类图、对象图、状态图、活动图、时序图、协作图、构建图、部署图等9种图。而我也在上面说过了，在本讲中，我们所要学习的是UML里面的类图。</p>
<h2 id="类图的概述"><a href="#类图的概述" class="headerlink" title="类图的概述"></a>类图的概述</h2><p>什么是类图呢？</p>
<p>类图（Class diagram）是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<p>上面这句话中提到了类的内部结构，想必大家也很清楚这其实说的就是一个类里面到底有哪些成员？你不会不知道一个类里面到底有哪些成员吧！无非就是成员变量、构造方法以及成员方法，相信你一定知道这些。</p>
<p>其次，上面这句话中还提到了一个关系，该关系是特别重要的，而且类图也定义了一些规则来进行描述。</p>
<hr>
<h2 id="类图的作用"><a href="#类图的作用" class="headerlink" title="类图的作用"></a>类图的作用</h2><p>类图它到底有什么作用呢？我们不妨来看一下。</p>
<ul>
<li>在软件工程中，类图是一种静态的结构图（也就是说一个类中有哪些成员，以及该类和其他类到底有什么关系，这都是静态的，并且实实在在存在的），描述了系统的类的集合，类的属性和类之间的关系，可以简化人们对系统的理解</li>
<li>类图是系统分析和设计阶段的重要产物（正好，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>就在设计阶段来研究的），是系统编码和测试的重要模型</li>
</ul>
<p>类图的作用说白了，其实就是以图形化的形式让我们更好地去理解整个系统里面包含了哪些类、类里面的结构以及类和类之间的一个关系。</p>
<hr>
<h2 id="类图表示法"><a href="#类图表示法" class="headerlink" title="类图表示法"></a>类图表示法</h2><p>了解了类图之后，接下来我们来看下类图表示法。在类图表示法这一章节，我们所要学习的内容有：</p>
<ul>
<li>类的表示方式，当然，也包括含接口的表示方式</li>
<li>类和类之间关系的表示方式，当然，也包含类和接口之间关系的表示方式</li>
</ul>
<p>接下来，我们先来看一下类的表示方式。</p>
<h3 id="类的表示方式"><a href="#类的表示方式" class="headerlink" title="类的表示方式"></a>类的表示方式</h3><p>在UML类图中，类使用包含类名、属性（field，也即成员变量）和方法（method）且带有分割线的矩形来表示，比如下图就表示了一个Employee类，它包含name、age和address这3个属性，以及work方法。</p>
<p><img src="/./assets/1709376439420-6db4d7ff-217a-4a6f-9149-e97ccc561b62.png" alt="img"></p>
<p>看清楚上面这张图没有，它其实就是一个矩形，而且该矩形被分成了三部分，</p>
<ul>
<li>第一部分表示的是类名，</li>
<li>第二部分是成员变量，</li>
<li>第三部分是成员方法。</li>
</ul>
<p>但是，这里面有一个问题，就是这里面的减号、加号以及冒号分别表示的是什么含义呢？要搞清楚这个，那我们就得知道类图中成员变量和和成员方法的表示方式。</p>
<p><strong>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，</strong>也就是我们之前学习的访问修饰符，我们知道Java中访问修饰符有4种，那么UML类图中表示可见性的符号有几种呢？可能会出乎你的意料，其有3种，分别是：</p>
<ul>
<li>**+**<strong>：表示public</strong></li>
<li>**-**<strong>：表示private</strong></li>
<li>**#**<strong>：表示protected</strong></li>
</ul>
<p>有些同学可能会想，不是应该有4种吗？为什么只有3种啊？其实，还有一种是默认，也就是什么都不加，在类图中表示的话，什么都不加就可以了。</p>
<p>接下来，我们来看一下属性和方法的完整表示方式。</p>
<ul>
<li>属性的完整表示方式：可见性 名称 : 类型[ = 缺省值]</li>
<li>方法的完整表示方式：可见性 名称(参数列表)[ : 返回类型]</li>
</ul>
<p>注意：</p>
<ol>
<li>中括号中的内容表示是可选的</li>
<li>也有将类型放在变量名前面，返回值类型放在方法名前面的，但是还是建议大家按照以上标准方式来写</li>
</ol>
<p>明了上面的知识点之后，我们再来重新分析一下Employee类的类图，可以很清楚地看到该类里面有3个成员变量，而且它们前面加的都是-，这说明它们都是用private修饰的；其次，我们还能看到，name成员变量的类型是字符串，age成员变量的类型是int，address成员变量的类型也是字符串；最后，我们也能看到，该类里面只有一个成员方法，而且它是public修饰的，没有参数，也没有返回值。</p>
<p>这个时候，相信你再来看某个类的类图，一定会很好理解了。</p>
<p>不妨我们再来看一个Demo类的类图，如下图所示。</p>
<p><img src="/./assets/1709376439359-a3cc07b5-39f7-496b-9e06-567fae9e5e0d.png" alt="img"></p>
<p>可以看到，Demo类里面没有成员变量，只有3个成员方法，我们不妨来分析一下每一个方法：</p>
<ul>
<li>method方法：修饰符为public，没有参数，没有返回值</li>
<li>method1方法：修饰符为private，没有参数，返回值类型为String</li>
<li>method2方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数的类型为String，返回值类型是int</li>
</ul>
<hr>
<h3 id="类与类之间关系的表示方式"><a href="#类与类之间关系的表示方式" class="headerlink" title="类与类之间关系的表示方式"></a>类与类之间关系的表示方式</h3><p>在这一章节，我们来探讨一下类和类之间关系的表示方式，当然了，这里面也包含类和接口之间关系的表示方式。那么类和类之间都有哪些关系呢？嘿嘿！关系还挺多的，一共有如下这些。</p>
<ul>
<li>关联关系</li>
<li>聚合关系</li>
<li>组合关系</li>
<li>依赖关系</li>
<li>继承关系</li>
<li>实现关系</li>
</ul>
<p>这些关系中，继承关系和实现关系，我们还是比较熟的。至于其他的关系，你不熟，也没关系，因为下面我会为大家详细地阐述每一种关系。不妨，我们就先来看一下关联关系。</p>
<h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>什么是关联关系呢？</p>
<p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生（一个老师可以教多个学生）、师傅和徒弟（一个师傅可以教多个徒弟）、丈夫和妻子（当然，这种必须是一对一的关系哟😊）等。关联关系是类和类之间最常用的一种关系，可分为一般关联关系、聚合关系和组合关系。</p>
<p>如何去理解以上这句话中的引用关系呢？我们可以这样理解，所谓的引用就是可以在一个类中声明另外一个类型的变量。</p>
<p>从以上关联关系的概述中，我相信大家也能知道这点，即聚合关系和组合关系它们也属于关联关系，只不过这里我是单独的把它们拿出来讲解而已！</p>
<p>下面，我来为大家讲一下关联关系所属里面的一般关联关系，而且大家要知道一般关联关系又可分为单向关联、双向关联以及自关联哟！那没办法了，只好分类来介绍了。</p>
<h5 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h5><p>请看一下下面这张类图，有一个顾客类和地址类，并且还能看到在顾客类的成员位置声明了一个地址类型的变量，相信大家已经猜到了，这表示的就是引用，即引用了Address类的对象，很显然，这个就属于单向关联。</p>
<p><img src="/./assets/1709376439383-b7c0d1fd-6c18-41c6-ae0d-d57e8d55877a.png" alt="img"></p>
<p>那么，单向关联在类图中是如何来表示的呢？在UML类图中，单向关联是用一个带箭头的实线来表示的，也就是说，这条实线表示的其实就是单向关联关系。上图表示的就是每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量来实现。</p>
<h5 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h5><p>请看一下下面这张类图，该类图里面有两个类，一个是顾客类，还有一个是商品类。请注意，由于一个顾客可以购买多个商品，所以在顾客类的成员位置处声明了商品类型的变量，只不过它是一个集合；而商品类中也声明了一个顾客类型的变量，表示该商品属于某一个顾客，很显然，这个就属于双向关联。</p>
<p><img src="/./assets/1709376439359-d92b03e3-a58d-4877-bbc0-8c68a6069785.png" alt="img"></p>
<p>那么，双向关联在类图中是如何来表示的呢？在UML类图中，双向关联是用一个不带箭头的直线来表示的。上图中在Customer类中维护了一个List<product>集合，且该集合里面存的是商品对象，这表示一个顾客可以购买多个商品；在Product类中维护了一个Customer类型的成员变量，表示这个产品被哪个顾客所购买了。相信大家从上图中也能很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</product></p>
<h5 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h5><p>自关联比较特殊，相对而言用的其实也并不是特别多。我们不妨看一下下面这张类图，有一个Node类，而且Node类里面又声明了一个Node类型的变量（也即成员变量），很显然，这个就属于自关联。</p>
<p><img src="/./assets/1709376439366-c0aa9d23-f5fb-45ac-b4b0-34019a83568d.png" alt="img"></p>
<p>那么，自关联在类图中是如何来表示的呢？自关联在UML类图中是用一个带有箭头且指向自身的线来表示的。上图的意思就是Node类包含类型为Node的成员变量，也就是”自己包含自己”。</p>
<p>还记得我们之前学习过的一个叫LinkedList的集合吗？它底层其实就用到了这种自关联的结构。</p>
<hr>
<h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>什么是聚合关系呢？聚合关系，上面我也已经说过了，它和组合关系都是属于关联关系里面的，也即关联关系的一种，而且它是强关联关系，是整体和部分之间的关系。</p>
<p>什么叫整体和部分之间的关系呢？就拿大学和老师这个例子来说，这里我为了让大家更好地理解，我直接给出了大学和教师的关系图，如下图所示，以该例子而言，大学属于整体，老师就属于部分。</p>
<p><img src="/./assets/1709376439857-92b26783-4378-43bc-bb4e-ae4848e1d6ae.png" alt="img"></p>
<p>此外，关于聚合关系，我们还得知道一点，那就是<strong>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在</strong>。</p>
<p>这句话怎么理解呢？从上图中可以看到，在大学里面，是有成员的，而且成员还是另外一种类型（即老师）的对象，只不过它是放在了一个集合里面，所以我们才说聚合关系是通过成员对象来实现的；其次，由于大学是一个整体，而老师是部分，也即成员对象，所以很显然成员对象是整体对象的一部分；最后，一个大学肯定会有多位老师，如果这个大学停办了，或者说这个大学没落了，那么老师是还依旧存在的，他还可以到其他的学校继续任职，所以我们才说成员对象可以脱离整体对象而独立存在。</p>
<p>那么，聚合关系在类图中是如何来表示的呢？在UML类图中，聚合关系可以用带空心菱形的实线来表示，而且菱形指向整体。在上图中，老师是属于部分，大学是属于整体，所以空心菱形就得指向于大学这一边，这点大家也能很清晰地看出来。</p>
<h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>这一小节，我们再来看一下关联关系的另外一种，即组合关系。那什么是组合关系呢？</p>
<p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>
<p>从以上这句话中我们可以知道，组合关系也是整体和部分的关系，既然如此，那么它和上面讲到的聚合关系到底又有什么区别呢？区别就是组合关系是一种更强烈的聚合关系，那怎么体现更强烈这一点呢？请看下面这句话。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，头属于整体，嘴属于部分，没有了头，嘴也就不存在了，因为嘴是依赖于头而存在的。</p>
<p>所以，关于组合关系的概念，大家一定要清楚哟，而且也要知道它和聚合关系不太一样的地方。</p>
<p>那么，组合关系在类图中是如何来表示的呢？在UML类图中，组合关系用带实心菱形的实线来表示，而且菱形指向整体。</p>
<p>这与上面所讲到的聚合关系还是有所区别的，虽然都有讲菱形指向整体，但是一个是实心菱形，一个是空心菱形，所以，我们就可以通过判断菱形是空心的还是实心的，来区分开其到底是聚合关系还是组合关系。</p>
<p>当然了，组合关系在我们的日常生活中还是用的比较多的，可能我们在真正定义类的时候，相对而言用的并不是特别多。在现实生活中，就拿我上面举的头和嘴的例子来说，其关系图就应该是下面这样子的。</p>
<p><img src="/./assets/1709376439880-00fe86b9-0ab9-4cb6-9048-7f99666fd460.png" alt="img"></p>
<p>大家一定得注意了，对于组合关系而言，如果整体不存在了，那么部分肯定不复存在了。</p>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>什么是依赖关系呢？</p>
<p>依赖关系是一种使用关系（在我们平时定义类的时候特别常用），它是对象之间耦合度最弱的一种关联关系，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另外一个类（被依赖类）中的某些方法来完成一些职责。</p>
<p>以上这句话中说到了一个词，就是临时性的关联，那什么是临时性的关联呢？举个例子，我们在一个类的方法里面去创建了另外一个类的对象，那么这就是属于依赖关系了，也可说成是临时性的关联，其实，这一点在以上这句话的后半句中也提到了。</p>
<p>请看一下下面这幅司机和汽车的关系图，有一个司机类和汽车类，由于司机要驾驶汽车，所以你能看到在Driver类中有一个Car类型的形式参数，当然了，你也可以说成是Car类在Driver类中充当的是方法的参数，这个就是所谓的依赖关系，也即Driver类依赖于Car类。</p>
<p><img src="/./assets/1709376439931-1ad1d816-aade-45a4-99e0-6d1c938b7d98.png" alt="img"></p>
<p>当然了，我们还可以在Driver类的drive方法中通过局部变量的形式来描述依赖关系，只不过这儿是以方法的参数这种形式来描述的，至于对静态方法调用也是同样的一个道理，这里我就不再赘述了。</p>
<p>那么，依赖关系在类图中是如何来表示的呢？在UML类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</p>
<p>这里我再次重复地来分析一下以上司机和汽车的关系图，可以看到，在Driver类里面有一个叫driver的方法，而且方法中使用了一个Car类型的变量，也即Car类型的形式参数，那么到时候在调用driver方法的时候，必然是要给其传递一个Car类型的对象的，这样，我们就可以说Driver类依赖于Car类，这个就是依赖关系。</p>
<p>最后，我再强调一点，依赖关系在真正的开发中用的是最多的，而且它的耦合性也是最弱的。</p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>依赖关系讲解完之后，我们再来看一下继承关系和实现关系，它俩在真正的开发中也是用的特别多。不过这一小节，我们先来说一下继承关系。</p>
<p>什么是继承关系呢？</p>
<p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>
<p>有些同学可能会想，为什么说继承关系是对象之间耦合度最大的一种关系呢？你想啊，当两个类有了继承关系之后，如果我们在父类中定义了一个成员，不管是成员变量还是成员方法，那么子类都会继承过来，所以耦合度就特别高。</p>
<p>在UML类图中，泛化关系也被称为继承关系（也可以说泛化关系表示的其实就是继承关系），只不过这一块我没有单独去说它。那么，泛化关系在类图中是如何来表示的呢？泛化关系在UML类图中是用带空心三角箭头的实线来表示的，而且箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系（或者说继承关系），这个想必大家应该很熟了。例如，Student类和Teacher类都是Person类的子类，其类图如下图所示。</p>
<p><img src="/./assets/1709376440031-52a367d2-2eb0-457c-9dcb-223e05a567b7.png" alt="img"></p>
<p>大家从以上类图中看清楚没有？就是箭头是从子类指向父类的。</p>
<p>总之，只要看到带空心三角箭头的实线，你就应该得明白这表示的就是继承关系。</p>
<h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>什么是实现关系呢？</p>
<p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>实现关系的概念很好理解，无非就是我们平常所说所做的，如果实现类要去实现某个接口的话，那么必须就得重写该接口里面的所有的抽象方法了，当然，前提是该实现类不是抽象的类。</p>
<p>那么，实现关系在类图中是如何来表示的呢？在UML类图中，实现关系使用带空心三角箭头的虚线来表示，而且箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图就如下图所示。</p>
<p><img src="/./assets/1709376439986-4f7f9cf0-5c18-4d59-ba8e-15a60c09cf83.png" alt="img"></p>
<p>不知你看到了没有，在Vehicle上面有一个&lt;<interface>&gt;这样的标识，这表明了Vehicle是一个接口，而且，该接口又有两个子实现类，只因它们上面没有声明&lt;<interface>&gt;。</interface></interface></p>
<p>至此，类和类、类和接口之间的关系的表示方式我就彻底讲解完了。不妨我们在脑海中再回顾一下以上所学的知识，想必你就应该会很清楚，关系总共可分为关联关系、聚合关系、组合关系、依赖关系、继承关系以及实现关系，其中又以依赖关系的耦合度最低，以继承关系和实现关系的耦合度最高，当然，在继承和实现这俩关系中，耦合度最高的还属继承关系。</p>
<hr>
<hr>
<h1 id="3-软件设计原则"><a href="#3-软件设计原则" class="headerlink" title="3. 软件设计原则"></a>3. 软件设计原则</h1><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1. 开闭原则"></a>3.1. 开闭原则</h2><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<p>那么是6条原则呢？看过我前面文章的同学肯定知道，就是下面这6条原则。</p>
<ol>
<li>开闭原则</li>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>迪米法特原则</li>
<li>合成复用原则</li>
</ol>
<p>本讲我会为大家介绍第一个软件设计原则，即开闭原则。</p>
<h3 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1. 概述"></a>3.1.1. 概述</h3><p>什么是开闭原则呢？开闭原则就是<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p>不妨我就举一个现实生活中的例子来说明一下开闭原则吧！在现实生活中，我们可以经常看到这样的一些效果，咱们的笔记本都会预留有一些USB接口，这样，不管是U盘还是一些什么其他的外接设备，例如鼠标、键盘，我们都可以随插随用了，即实现了一个热插拔的效果，也更加方便我们进行扩展。</p>
<p>有些同学可能就会问了，如果要想达到这样一个效果，那么应该怎么办呢？我们需要使用接口和抽象类。为什么要用接口和抽象类呢？因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p>那么也就是说，我们现在只须去定义一个接口或者抽象类，很显然，它们里面定义了所有子类必须重写的方法，也即定义了一些规范，然后我们再去定义其子类，这样，在后期如果我们要进行程序的扩展，那么我们就不需要再去修改原有的代码，而是直接重新再去定义一个子实现类就可以了。</p>
<p>可能我说了这么多，大家还不是特别理解，没关系，下面我会以搜狗输入法的皮肤为例来向大家介绍开闭原则的一个应用。</p>
<hr>
<h3 id="3-1-2-案例"><a href="#3-1-2-案例" class="headerlink" title="3.1.2. 案例"></a>3.1.2. 案例</h3><p>这块我是以搜狗输入法的皮肤设计为例来介绍开闭原则的一个应用的。</p>
<h4 id="3-1-2-1-案例分析"><a href="#3-1-2-1-案例分析" class="headerlink" title="3.1.2.1. 案例分析"></a>3.1.2.1. 案例分析</h4><p>搜狗输入法的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，当然，用户可以用默认的，也可以用其他的皮肤，而且他还可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），大家一定要注意，不管是默认的皮肤还是什么其他的皮肤，我们现在的做法就是向上进行抽取，抽取出一个抽象类或者接口，不过这一块咱们使用的是抽象类，如此一来，每一个具体的皮肤（例如DefaultSkin和MeimeixiaSkin）都将是其子类，这样，用户窗体就可以根据需要选择或者增加新的主题，而不再需要修改原代码了。</p>
<p>这样一路分析下来，我们可以发现该案例是能够满足开闭原则的，所以现在咱们就可以通过该案例来演示一下开闭原则了。当然了，在演示之前，大家得能看懂下面的类图，这也是通过以上分析画出来的。</p>
<p><img src="/./assets/1709377612945-7efe0894-7e50-437d-9e1f-96589e10c9d8.png" alt="img"></p>
<p>从以上类图中可以看到，顶层有一个抽象的皮肤类，它下面有两个子类，一个是默认的皮肤类，一个是美美侠皮肤类，它俩都需要去重写父类中的抽象方法。当然了，旁边还有一个搜狗输入法类，由于该类拥有显示皮肤的功能，所以它需要用到皮肤，故你能看到我在这里面进行了一个聚合的操作。</p>
<p>当然了，以上类图中还缺少一个测试类，只不过我没有在以上类图中体现出来罢了。</p>
<h4 id="3-1-2-2-案例实现"><a href="#3-1-2-2-案例实现" class="headerlink" title="3.1.2.2. 案例实现"></a>3.1.2.2. 案例实现</h4><p>接下来，我们便通过代码来实现一下搜狗输入法皮肤设计这个案例。</p>
<p>要想做到这点，咱们首先得打开咱们的开发工具，这里我使用的开发工具是IDEA，相信大家也都是用的它，然后创建一个maven工程，名字不妨起为design_patterns，以后有关<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>的代码我们统统都会放在这个工程里面，工程创建好之后，不妨接着在其下创建一个包，例如com.meimeixia.principles，在该包下存放的都是我们编写的有关软件设计原则的代码，至于设计模式的代码，后续我会重新再创建一个包来进行存放。</p>
<p>当然了，软件设计原则有多条，要想讲清楚每一条设计原则，我们还得在com.meimeixia.principles包下分别创建多个子包来存放每一条设计原则所对应案例的代码，例如com.meimeixia.principles.demo1包里面存放的就是开闭原则所对应案例（即搜狗输入法的皮肤设计）的代码。</p>
<p>下面，我们就得根据以上类图来写出对应的代码了。</p>
<p>首先，定义一个抽象皮肤类，例如AbstractSkin。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象皮肤类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 12:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSkin</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，再来定义以上抽象皮肤类的子类，咱们定义的第一个子类是默认皮肤类，即DefaultSkin。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认皮肤类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSkin</span> <span class="keyword">extends</span> <span class="title class_">AbstractSkin</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"默认皮肤"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>咱们定义的第二个子类是美美侠皮肤类，即MeimeixiaSkin。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美美侠皮肤类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 12:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeimeixiaSkin</span> <span class="keyword">extends</span> <span class="title class_">AbstractSkin</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"美美侠皮肤"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上三个类定义完毕之后，我们还得定义一个类，从以上类图可知，该类的类名叫SougouInput，此外，我们还知道该类聚合了抽象皮肤类。这样，该类的代码应该是下面这样子的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜狗输入法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 12:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SougouInput</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractSkin skin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkin</span><span class="params">(AbstractSkin skin)</span> {</span><br><span class="line">        <span class="built_in">this</span>.skin = skin;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        skin.display();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，我在SougouInput类里面定义了一个AbstractSkin类型的成员变量，这就代表了SougouInput类聚合了抽象皮肤类。此外，由于外界要对AbstractSkin类型的成员变量赋值，所以我们还得提供对应的set方法，当然，这里面我没有提供get方法，只是提供了一个set方法用于赋值。最后，在SougouInput类里面我还提供了一个display方法，该方法是用于展示皮肤的，大家注意了，在该方法里面是调用抽象皮肤类的具体子类的display方法去进行皮肤的一个展示的。</p>
<p>SougouInput类定义完之后，别着急，还有一个类需要我们去定义，它就是咱们的测试类，我们可以给它起名为Client。下面我提供了一个编写好的测试类，以供大家参考。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 12:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 1. 创建搜狗输入法对象</span></span><br><span class="line">        <span class="type">SougouInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SougouInput</span>();</span><br><span class="line">        <span class="comment">// 2. 创建皮肤对象</span></span><br><span class="line">        <span class="comment">// DefaultSkin skin = new DefaultSkin();</span></span><br><span class="line">        <span class="type">MeimeixiaSkin</span> <span class="variable">skin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MeimeixiaSkin</span>();</span><br><span class="line">        <span class="comment">// 3. 将皮肤设置到输入法中</span></span><br><span class="line">        input.setSkin(skin);</span><br><span class="line">        <span class="comment">// 4. 显示皮肤</span></span><br><span class="line">        input.display();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>相信大家都能看懂以上测试类中编写的代码，我就不再详细赘述了。</p>
<p>测试类定义完毕之后，我们来测试一下，看效果是不是我们所想要的，如下图所示，美美侠皮肤打印出来了，看来效果确实是达到了。</p>
<p><img src="/./assets/1709377612978-970f36d3-2cc6-4631-8f42-8dd299032f9b.png" alt="img"></p>
<p>如果现在我们不想用美美侠皮肤了，而是想要用默认皮肤，那么只须稍微修改一下测试类即可，怎么修改想必大家都知道了，我也就不再赘述了。这时，你会发现其他四个类的代码都没有进行任何修改，效果便已经实现了。</p>
<p>后期我们可能面临这样一个需求，就是我们还想再去扩展一种皮肤，例如觉醒年代皮肤，那么你觉得现在以上这个案例有没有满足开闭原则呢？很显然，是满足的，你要知道开闭原则是对扩展开放，对修改关闭的，也就是说我们要进行扩展的话是可以的，但是尽量不要去修改我们之前编写的类的代码。</p>
<p>如果现在还想再去扩展一种觉醒年代皮肤，那么此时我们的做法就很简单了，重新再创建一个类，例如JueXingNianDaiSkin，然后让它去继承抽象皮肤类即可。接下来的事情就好办了，只需要把客户端的代码进行一个修改，让其使用觉醒年代皮肤，一切就都OK了。</p>
<p>至此，开闭原则我就为大家介绍到这。</p>
<hr>
<h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2. 里氏代换原则"></a>3.2. 里氏代换原则</h2><h3 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1. 概述"></a>3.2.1. 概述</h3><p>首先，大家应该知道，里氏代换原则是面向对象设计的基本原则之一。那什么是里氏代换原则呢？</p>
<p>里氏代换原则是指任何基类可以出现的地方，子类一定可以出现。这句话不好理解，但大家可以通俗理解成子类可以扩展父类的功能，但不能改变父类原有的功能。现在，这句话就好理解很多了，指的就是在Java里面通常都会有父子类的关系，一般而言，我们都会将子类中的功能抽取到父类中，以提高代码的复用性，而在子类中，我们只需要去定义子类特有的功能即可。</p>
<p>换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。为什么呢？因为如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性就会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>你想啊，要是在父类中已经声明了一个方法，而你又在子类中再进行了一个重写，那么在父类中定义的方法是不是就没有任何意义了？如果说父类定义规则，要求子类必须重写，那么在父类中只需要定义成抽象的方法就可以了。</p>
<p>经过我上面的描述，相信大家对里氏代换原则有了一个简单的认识。接下来，我就为大家介绍里氏替换原则中的一个经典的案例，即正方形不是长方形。</p>
<h3 id="3-2-2-案例"><a href="#3-2-2-案例" class="headerlink" title="3.2.2. 案例"></a>3.2.2. 案例</h3><h4 id="3-2-2-1-案例分析"><a href="#3-2-2-1-案例分析" class="headerlink" title="3.2.2.1. 案例分析"></a>3.2.2.1. 案例分析</h4><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，如果我们要开发一个与几何图形相关的软件系统的话，那么就可以顺理成章的让正方形继承自长方形了。</p>
<p>请看一下下面这张类图。</p>
<p><img src="/./assets/1709378549782-4f96272c-3c16-4b1b-bdbf-dcc861682b6b.png" alt="img"></p>
<p>可以看到，这张类图里面有三个类，第一个是长方形类，长方形类里面有两个成员变量，一个是length，表示长，一个是width，表示宽，而且它里面还提供了相应的getter和setter方法，相对来说，这个类还是很简单的，比较好理解。</p>
<p>第二个是长方形类的子类，即正方形类，该类要重写父类中设置长和宽的这两个方法。为什么要重写呢？因为正方形里面的长和宽是相等的。</p>
<p>以上两个类介绍完之后，再来看最后一个类，即测试类，在测试类中应该提供这么几个方法：</p>
<ul>
<li>主方法：这里面我没有写出来</li>
<li>resize方法：扩宽方法。长方形里面的宽是要比长小的，如果宽比长小的话，那么我们就可以通过该方法来进行判断，然后再将宽给它扩长，直到比长大就OK了</li>
<li>打印长和宽的方法：该方法只是为了更好的看到效果而已</li>
</ul>
<p>注意了，在resize方法和打印长和宽的这两个方法里面，还需要传递一个长方形类型的参数，也就是说测试类其实是依赖于长方形类的，所以它俩之间是一个依赖关系。</p>
<p>把以上这三个类以及依赖关系理清楚了之后，接下来我们就要编写代码来实现这个案例了。</p>
<h4 id="3-2-2-2-案例实现"><a href="#3-2-2-2-案例实现" class="headerlink" title="3.2.2.2. 案例实现"></a>3.2.2.2. 案例实现</h4><p>打开咱们的maven工程，然后在com.meimeixia.principles包下创建一个子包，即demo2，接着在com.meimeixia.principles.demo2包下再创建一个子包，即before，我们首次是在该包下来存放咱们编写的代码的。接下来，我们就要正式开始编写代码来实现以上案例了。</p>
<p>首先，在com.meimeixia.principles.demo2.before包下新建第一个类，即长方形类，名字可取做Rectangle。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长方形类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> {</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> {</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，新建第二个类，即正方形类，名字可取做Square，记住要让该类去继承长方形类，并重写父类中设置长和宽的方法。那么应该如何去重写呢？很简单，就拿重写父类中设置长的setLength方法来说，我们只需要调用父类中的设置长和宽的方法把方法中的length参数设置给长和宽即可，因为长和宽必须保持一致。当然，重写父类中设置长的setWidth方法也是同理。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正方形类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 13:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> {</span><br><span class="line">        <span class="built_in">super</span>.setLength(length);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> {</span><br><span class="line">        <span class="built_in">super</span>.setLength(width);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(width);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，我们就要编写测试类了，名字就叫RectangleDemo。根据我们上面的分析，相信你一定能写出下面的代码，只不过现在还未在主方法中编写测试代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 13:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 测试代码...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩宽方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，那么则进行扩宽的操作</span></span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) {</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，在主方法中编写如下代码进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 13:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setLength(<span class="number">20</span>);</span><br><span class="line">        r.setWidth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用resize方法进行扩宽</span></span><br><span class="line">        resize(r);</span><br><span class="line">        printLengthAndWidth(r);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩宽方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，那么则进行扩宽的操作</span></span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) {</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时，我们不妨来运行一下以上测试类，看看打印结果是啥？如下图所示，可以看到长是20，没变，宽是21，因为我们进行了一个扩宽的操作，此时，宽已经比长大了。</p>
<p><img src="/./assets/1709378549783-58cdfd49-ec34-4409-b6b6-043e9b99913f.png" alt="img"></p>
<p>如果我像下面这样向resize方法中传入一个正方形类型的对象，那么可不可以呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 13:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setLength(<span class="number">20</span>);</span><br><span class="line">        r.setWidth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用resize方法进行扩宽</span></span><br><span class="line">        resize(r);</span><br><span class="line">        printLengthAndWidth(r);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============================="</span>);</span><br><span class="line">        <span class="comment">// 创建正方形对象</span></span><br><span class="line">        <span class="type">Square</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        s.setLength(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用resize方法进行扩宽</span></span><br><span class="line">        resize(s);</span><br><span class="line">        printLengthAndWidth(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩宽方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，那么则进行扩宽的操作</span></span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) {</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从语法上来说是可以的，因为正方形是属于长方形的子类的，所以传递子类对象完全是可以的。</p>
<p>这时，我们再来运行一下测试类，看一下打印结果是什么，如下图所示，你会发现等了好久，结果却什么都没有打印出来。</p>
<p><img src="/./assets/1709378549792-efdd64b9-6892-4f56-90da-a64cb34053f9.png" alt="img"></p>
<p>难道是我们程序出现问题了吗？其实不是，你注意看以上控制台中的那个红色按钮，这表明程序还没有结束，它还在一直执行，为什么会出现这种现象呢？下面我就为大家解释一下其原因。</p>
<p>运行以上测试类中代码，你就会发现，假如我们把一个普通长方形对象作为参数传入resize方法中的话，是会看到长方形的宽度逐渐增长的效果的，当宽度大于长度时，代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形对象作为参数传入resize方法的话，就会看到正方形的宽度和长度都在不断增长，因为长和宽要保持一致，这是正方形的一个特点，那么代码就会一直运行下去，直至系统产生溢出错误为止。</p>
<p>所以，普通的长方形是适合这段代码的，而正方形不适合。而里氏代换原则又是指基类能使用的地方，那么子类也可以使用，因此很显然这违背了这一原则。</p>
<p>于是，我们可以得出这样一个结论：在resize方法中，Rectangle类型的参数是不能被其子类Square类型的参数所代替的，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p>
<p>那么如何改进呢？下面我们再说。</p>
<hr>
<h4 id="3-2-2-3-案例改进"><a href="#3-2-2-3-案例改进" class="headerlink" title="3.2.2.3. 案例改进"></a>3.2.2.3. 案例改进</h4><p>初步实现以上正方形不是长方形的案例之后，相信你也看到了其所在的问题，即违反了里氏代换原则。那么应该如何对该案例进行改进呢？</p>
<p>首先，我们要对类以及类和类之间的关系进行重新设计，重新设计出来的类图应该是下面这个样子的。</p>
<p><img src="/./assets/1709378549875-2e75a90c-6e3a-4524-b77d-075dbfc34043.png" alt="img"></p>
<p>对于正方形和长方形而言，我们向上抽取，抽取出来一个四边形接口（即Quadrilateral），并在这个接口里面定义两个抽象的方法，一个是getLength，一个是getWidth，分别用于获取长和宽，然后让Rectangle类和Square类实现Quadrilateral接口；从以上类图中可以看到，我们还在Square类里面定义了一个名字为side的成员变量，也即正方形的边长，而且在该类里面，除了提供该成员变量的getter和setter方法之外，我们还重写了Quadrilateral接口里面的抽象方法；至于Rectangle类，依旧还是原先的设计，该类是没有任何变化的。</p>
<p>最后，大家不要忘了，还有一个测试类（即RectangleDemo），该测试类是没有成员变量的，只有如下三个方法：</p>
<ul>
<li>主方法：这里面我没有声明出来，主要作测试用</li>
<li>resize方法：扩宽方法。注意，该方法需要的是一个长方形类型的对象，正方形类型的对象此时是不能传入进来的</li>
<li>printLengthAndWidth方法：打印长和宽的方法。注意，该方法需要传递的是一个Quadrilateral接口的子实现类对象</li>
</ul>
<p>这样一路分析下来，你就会发现该测试类不仅得依赖Quadrilateral接口，还得依赖Rectangle类。至此，我就给大家分析完以上类图了，接下来，我们就得编写代码来实现以上改进后的案例了。</p>
<p>首先，在com.meimeixia.principles.demo2包下再创建一个子包，即after，该包下存放的就是改进后的案例的代码。</p>
<p>然后，我们再创建一个四边形接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四边形接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 14:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Quadrilateral</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取宽</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，再来创建咱们的正方形类，注意了，该类是要去实现四边形接口的，这样，我们还必须得重写其中的方法。此外，在该类里面我们还得声明一个表示边长的成员变量，当然还得提供其对应的getter和setter方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正方形类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 14:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Quadrilateral</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> side;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSide</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> side;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSide</span><span class="params">(<span class="type">double</span> side)</span> {</span><br><span class="line">        <span class="built_in">this</span>.side = side;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> side;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> side;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，再来创建咱们的长方形类，同理，该类也得实现四边形接口，重写其里面的抽象方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长方形类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 14:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Quadrilateral</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> {</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> {</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们再来创建一个测试类。根据我们上面对类图的分析，相信你一定能写出下面的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setLength(<span class="number">20</span>);</span><br><span class="line">        r.setWidth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用方法进行扩宽操作</span></span><br><span class="line">        resize(r);</span><br><span class="line">        printLengthAndWidth(r);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩宽的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> {</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，那么则进行扩宽的操作</span></span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) {</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Quadrilateral quadrilateral)</span> {</span><br><span class="line">        System.out.println(quadrilateral.getLength());</span><br><span class="line">        System.out.println(quadrilateral.getWidth());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，不妨来运行一下以上测试类，看看打印结果是不是我们所想要的，如下图所示，可以看到长是20，没变，宽是21，因为我们进行了一个扩宽的操作。</p>
<p><img src="/./assets/1709378549795-4fec8c97-3727-425b-b599-883ec3fad8ed.png" alt="img"></p>
<p>大家现在想一想，如果我们去调用resize方法时传入的是一个正方形对象，那么还可不可以呢？肯定是不可以的，因为正方形和长方形它俩现在没有父子关系了，所以在resize方法里面只能传递长方形对象，而不能再传递正方形对象了。这样，我们就通过以上改进完美的解决了案例之前所存在的问题。</p>
<hr>
<h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3. 依赖倒转原则"></a>3.3. 依赖倒转原则</h2><h3 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1. 概述"></a>3.3.1. 概述</h3><p>什么是依赖倒转原则呢？我们来看一下下面这段描述：</p>
<p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<p>这句话看起来就不好懂，不过没关系，下面我会为大家详细解释下。</p>
<p>你可能会问的第一个问题是高层模块是什么？低层模块又是什么？下面我用一张图来解释一下。</p>
<p><img src="/./assets/1709379474056-3a1b9ebc-1573-45ac-b0b7-c3215f5251f6.png" alt="img"></p>
<p>仔细看完以上类图，相信你对高层模块和低层模块有了一个简单的认识。</p>
<p>继续看上面那句话，高层模块和低层模块两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。这句话又该如何理解呢？其实这里面的细节指的就是具体的实现类或者子类。以上面的例子来说，A类是依赖于B类的，而B类又是一个具体的类，也即不是抽象类或者接口。现在我们的做法就是要把B类向上进行抽取，抽取出来一个抽象类或者接口，那么这样的话，我们在进行依赖的时候，A类就不需要直接依赖于B类了，而是依赖其父类或者父接口就行了，即细节应该依赖于抽象。</p>
<p><img src="/./assets/1709379474118-f00ad84e-8f61-4cf7-9a49-8ede7fc7161f.png" alt="img"></p>
<p>看完以上那句话，如果大家还不是特别理解的话，那么接下来我再通过一个例子来为大家解释一下依赖倒转原则。其实，依赖倒转原则是开闭原则的具体的实现。</p>
<hr>
<h3 id="3-3-2-案例"><a href="#3-3-2-案例" class="headerlink" title="3.3.2. 案例"></a>3.3.2. 案例</h3><p>这个例子就是组装电脑。</p>
<h4 id="3-3-2-1-案例分析"><a href="#3-3-2-1-案例分析" class="headerlink" title="3.3.2.1. 案例分析"></a>3.3.2.1. 案例分析</h4><p>现在我们要组装一台电脑，那么就得需要一些配件了，例如cpu、硬盘、内存条。只有这些配件都有了，计算机才能正常的运行。选择cpu的话，它又有很多品牌，比如说Intel、AMD等等，硬盘也是一样，它也有很多品牌，如希捷、西数等等，内存条同样也是，有金士顿、海盗船等等这些品牌。所以，我们在组装电脑的时候，可以选择任意一个品牌的配件来进行组装。</p>
<p>这样，通过对以上案例的描述，相信大家不难画出如下类图，要是真画不出来，那就看下面类图吧！</p>
<p><img src="/./assets/1709379474123-f8eec533-b2da-4c4b-9ed2-c4c496f9a406.png" alt="img"></p>
<p>从以上类图中可以看到，有一个希捷硬盘类，它里面既有存储数据的方法，也有获取数据的方法；其次，还有一个英特尔cpu类，它里面有一个运行的方法，即run方法；最后还有一个金士顿内存条类，它里面有保存数据的方法。</p>
<p>大家注意了，以上三个类均不能独立运行，而是必须组合到Computer类里面，所以，你会看到在Computer类里面是以成员变量的形式来声明希捷硬盘、英特尔cpu、金士顿内存条等等这些配件的，继而我们就得为这些成员变量提供相应的getter和setter方法了。此外，在Computer类里面还定义了一个run方法，该方法就是用来运行计算机的，当然了，计算机的运行肯定是包含了希捷硬盘、英特尔cpu、金士顿内存条等等这些配件的运行的。</p>
<p>接下来，我们便来通过代码实现以上组装电脑案例。</p>
<h4 id="3-3-2-2-案例实现"><a href="#3-3-2-2-案例实现" class="headerlink" title="3.3.2.2. 案例实现"></a>3.3.2.2. 案例实现</h4><p>打开咱们的maven工程，然后在com.meimeixia.principles包下创建一个子包，即demo3，接着在com.meimeixia.principles.demo3包下再创建一个子包，即before，我们首次是在该包下来存放咱们编写的代码的。接下来，我们就要正式开始编写代码来实现以上案例了。</p>
<p>首先，在com.meimeixia.principles.demo3.before包下新建第一个类，即希捷硬盘类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希捷硬盘类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用希捷硬盘存储数据为："</span> + data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用希捷硬盘获取数据"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"数据"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，新建第二个类，即InterCpu。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intel cpu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用Intel处理器"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，新建第三个类，即金士顿内存条类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 金士顿内存条类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用金士顿内存条"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，以上三个配件类我们就定义完毕了。而且在上面我也说过了，这些组件是不能独立去运行的，所以，我们还需要定义一个Computer类，并将以上三个配件给组合进来。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiJieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> XiJieHardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(XiJieHardDisk hardDisk)</span> {</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IntelCpu <span class="title function_">getCpu</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(IntelCpu cpu)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> KingstonMemory <span class="title function_">getMemory</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(KingstonMemory memory)</span> {</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"运行计算机"</span>);</span><br><span class="line">        <span class="comment">// 计算机运行时，各个配件应各司其职，干自己的活</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">"从硬盘上获取的数据是："</span> + data);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时，我们就来运行一下以上测试类，看一下计算机能不能正常的去运行，并且使用硬盘、cpu和内存条等等这些配件。从下图所示的打印结果中可以看到，计算机是能正常运行的，并且还伴随着硬盘、cpu和内存条等等这些组件各司其职，做着自己的工作。</p>
<p><img src="/./assets/1709379474087-51dfc7c9-7ebc-446f-8f71-6a601935400e.png" alt="img"></p>
<p>那么你觉得以上代码有没有什么问题啊？从以上代码中可以看到，已经组装了一台计算机，但是似乎组装的计算机的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，为什么呢？因为在Computer类里面成员变量声明的是固定品牌的配件，如果我们后期想换成其他品牌的配件的话，那么是不是还得需要去修改Computer类啊？这就违背开闭原则了。</p>
<p>因此，这对用户肯定是不友好的，用户有了机箱之后，肯定是想按照自己的喜好选择自己喜欢的配件进行组装。</p>
<p>综上所述，以上案例遇到的问题就是，违背了开闭原则，因为后期如果我们想要把cpu换成AMD品牌的，那么我们还得去修改Computer类。</p>
<h4 id="3-3-2-3-案例改进"><a href="#3-3-2-3-案例改进" class="headerlink" title="3.3.2.3. 案例改进"></a>3.3.2.3. 案例改进</h4><p>虽说我们实现了以上组装电脑的案例，但是我们也看到了该案例所存在的问题，即违反了开闭原则。因此，我们就要对该案例进行改进了，那如何进行改进呢？这里就需要用到依赖倒转原则了。</p>
<p>首先，我们得重新设计类图。那如何设计新的类图呢？根据依赖倒转原则设计，即分别对希捷硬盘类、英特尔cpu类、金士顿内存条类向上抽取，抽取出一个父接口，完成之后，现在在Computer类里面就不再是聚合具体的实现类了，而是改成了聚合抽象接口这种方式。</p>
<p><img src="/./assets/1709379474116-22c6db10-6df0-490c-a3bf-a843f798a037.png" alt="img"></p>
<p>那么，这样设计有什么好处呢？后期如果有其他品牌配件的话，例如西数品牌的硬盘，那么我们就只需要定义一个西数硬盘类，让它去实现HardDisk接口即可。这样，当我们在组装计算机的时候，就只需要创建西数硬盘类的对象并把它传递进来就OK了，而且Computer类还不需要进行修改哟！如此一来，以上组装电脑案例所存在的问题不就迎刃而解了吗？</p>
<p>下面，我们就来编写代码来改进一下以上案例。</p>
<p>首先，在com.meimeixia.principles.demo3包下再创建一个子包，即after，该包下存放的就是改进后的案例的代码。</p>
<p>然后，定义第一个接口，即HardDisk接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 硬盘接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HardDisk</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上HardDisk接口定义完毕之后，我们立马定义一个它的子实现类，即希捷硬盘类，该类与咱们上面所写的基本上一模一样，只不过现在它要去实现HardDisk接口了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希捷硬盘类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span> <span class="keyword">implements</span> <span class="title class_">HardDisk</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用希捷硬盘存储数据为："</span> + data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用希捷硬盘获取数据"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"数据"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，定义第二个接口，即Cpu接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cpu接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cpu</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行cpu</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上Cpu接口定义完毕之后，我们立马定义一个它的子实现类，即英特尔cpu类，该类与咱们上面所写的基本上一模一样，只不过现在它要去实现Cpu接口了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intel cpu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> <span class="keyword">implements</span> <span class="title class_">Cpu</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用Intel处理器"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，定义第三个接口，即Memory接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存条接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 20:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上Memory接口定义完毕之后，我们立马定义一个它的子实现类，即KingstonMemory类，该类与咱们上面所写的基本上一模一样，只不过现在它要去实现Memory接口了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 金士顿内存条类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 19:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> <span class="keyword">implements</span> <span class="title class_">Memory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用金士顿内存条"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上这些接口以及其子实现类全部定义完毕之后，接下来我们开始定义Computer类。在该类里面，我们要声明以上那些配件，不过，我们现在不能在这一块去声明具体的实现类了，而是应该声明抽象的父接口，就像依赖倒转原则所描述的那样——应该依赖抽象，而不应该依赖细节。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 20:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(HardDisk hardDisk)</span> {</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">getCpu</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(Cpu cpu)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memory <span class="title function_">getMemory</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Memory memory)</span> {</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"运行计算机"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">"从硬盘上获取的数据是："</span> + data);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们还得提供一个测试类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 20:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建计算机的配件对象</span></span><br><span class="line">        <span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiJieHardDisk</span>();</span><br><span class="line">        <span class="type">Cpu</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCpu</span>();</span><br><span class="line">        <span class="type">Memory</span> <span class="variable">memory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KingstonMemory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建计算机对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 组装计算机</span></span><br><span class="line">        c.setCpu(cpu);</span><br><span class="line">        c.setHardDisk(hardDisk);</span><br><span class="line">        c.setMemory(memory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行计算机</span></span><br><span class="line">        c.run();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时，不妨来运行一下以上测试类，看一下效果是不是我们所想要的，如下图所示，确实是打印出了我们想要的结果。那么这样的话，以上这个案例就已经改进了。</p>
<p><img src="/./assets/1709379474728-f7d06b10-debd-4bcb-b3e1-784d11beb51d.png" alt="img"></p>
<p>当然了，如果后期你想要去换一个AMD品牌的cpu的话，那么只需要去新建一个AMD品牌的cpu类，然后让它去实现Cpu接口就可以了，此时，Computer类是不需要进行修改的。接着，你只需要在测试类中创建一个AMD品牌的cpu对象，并将其作为参数进行一个传递，组装到计算机里面即可。这样，就很好地符合了开闭原则。</p>
<p>最后，我做一个总结，面向对象的开发很好的解决了以上案例所存在的问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p>
<p>通过以上案例的改进，相信大家能看懂以上这句话，要是还不懂，你自个去揣摩吧！</p>
<hr>
<h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4. 接口隔离原则"></a>3.4. 接口隔离原则</h2><h3 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1. 概述"></a>3.4.1. 概述</h3><p>接口隔离原则是指客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上面。</p>
<p>这句话可能不是很好理解，所以下面我会画一张图来解释一下。先看的是前半段话，客户端不应该被迫依赖于它不使用的方法，这是什么意思呢？</p>
<p><img src="/./assets/1709380160106-f86ac928-e229-4fee-a980-6ba1b6f1fade.png" alt="img"></p>
<p>从上图中，相信大家能够更好地理解前半段话的内容，所以，在上述这种情景下，我们是不能使用继承关系的。</p>
<p>那么，现在我们应该如何对其进行改进呢？其实，在接口隔离原则概述的后半段话中就已经说了，即一个类对另一个类的依赖应该建立在最小的接口上面。改进之后，就变成下图所示的这样了。</p>
<p><img src="/./assets/1709380160506-c1875804-8bf1-40d6-b711-4b3f7b356d74.png" alt="img"></p>
<p>通过上面两张图的解释，相信大家对于接口隔离原则的概念有了一个更深入的认识。</p>
<p>接下来，我们就通过一个例子来更深入的去理解一下接口隔离原则。</p>
<hr>
<h3 id="3-4-2-案例"><a href="#3-4-2-案例" class="headerlink" title="3.4.2. 案例"></a>3.4.2. 案例</h3><p>这个例子就是安全门案例。</p>
<h4 id="3-4-2-1-案例分析"><a href="#3-4-2-1-案例分析" class="headerlink" title="3.4.2.1. 案例分析"></a>3.4.2.1. 案例分析</h4><p>我们现在需要创建一个美美侠品牌的安全门，该安全门具有防火、防水、防盗的功能。</p>
<p>要想做到这一点的话，咱们首先得设计出类图来。那我们应该如何去设计呢？可以将防火、防水、防盗等功能提取到一个接口里面，形成一套规范，所以，设计出来的类图应该如下所示。</p>
<p><img src="/./assets/1709380160227-84ba9c41-3b0e-40a8-8a74-0f3854c920a2.png" alt="img"></p>
<p>如果你想要去设计安全门的话，那么你只需要去实现SafetyDoor接口，并重写它里面的所有的抽象方法就可以了。</p>
<p>接下来，我们便来通过代码实现以上安全门案例。</p>
<h4 id="3-4-2-2-案例实现"><a href="#3-4-2-2-案例实现" class="headerlink" title="3.4.2.2. 案例实现"></a>3.4.2.2. 案例实现</h4><p>打开咱们的maven工程，然后在com.meimeixia.principles包下创建一个子包，即demo4，接着在com.meimeixia.principles.demo4包下再创建一个子包，即before，我们首次是在该包下来存放咱们编写的代码的。接下来，我们就要正式开始编写代码来实现以上案例了。</p>
<p>首先，定义一个SafetyDoor接口，即安全门接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全门接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SafetyDoor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防盗</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防火</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防水</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterProof</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，定义以上接口的一个实现类，例如美美侠安全门。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美美侠品牌的安全门类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 21:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeimeixiaSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">SafetyDoor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防盗"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防火"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterProof</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防水"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来编写一个测试类用作测试，不妨取名为Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-27 21:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MeimeixiaSafetyDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MeimeixiaSafetyDoor</span>();</span><br><span class="line">        door.antiTheft();</span><br><span class="line">        door.fireProof();</span><br><span class="line">        door.waterProof();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上测试类编写好之后，不妨来运行一下，如下图所示，可以看到，咱们设计的美美侠安全门确实具有了防盗、防火、防水的功能。</p>
<p><img src="/./assets/1709380160119-fe56c809-0d85-49d1-bb59-744e246b090f.png" alt="img"></p>
<p>对于以上设计，你觉得存不存在什么问题啊？如果我们现在再提一个需求，即还想再创建一个阿昀品牌的安全门，而该安全门只具有防盗、防火功能，不具有防水功能，那么难道我们需要再去定义一个类，让它去实现SafetyDoor接口吗？很显然不能，因为如果让新建的类再去实现SafetyDoor接口的话，那么就意味着该类要被迫依赖于它不使用的方法，即防水的方法，这也就违背了接口隔离原则。</p>
<p>那么我们又该如何进行修改呢？下面就会说到。</p>
<h4 id="3-4-2-3-案例改进"><a href="#3-4-2-3-案例改进" class="headerlink" title="3.4.2.3. 案例改进"></a>3.4.2.3. 案例改进</h4><p>虽然我们实现了以上安全门案例，但是我们也看到该案例所存在的问题，即违背了接口隔离原则。因此，我们就得需要对其进行改进了。那如何进行改进呢？</p>
<p>首先，咱们得按照接口隔离原则来重新设计出以下类图。</p>
<p><img src="/./assets/1709380160186-70c2e135-812e-4397-bb67-5cc8b5b33b6b.png" alt="img"></p>
<p>从以上类图中可以看到，我们是将安全门的接口给它拆分成了不同的接口，分别是防盗接口、防火接口、防水接口。现在，如果我们想要去创建一个美美侠品牌的安全门的话，那么只需要让其分别去实现这三个接口就可以了。要是后期我们还想要再创建一个阿昀品牌的安全门的话，而该安全门只具有防盗、防火功能，那么我们只须让其去实现防盗、防火这两个接口就可以了。</p>
<p>分析完了之后，下面我们来看一下代码的具体实现。</p>
<p>首先，在com.meimeixia.principles.demo4包下再创建一个子包，即after，该包下存放的就是改进后的案例的代码。</p>
<p>然后，创建防盗接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防盗接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 11:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建防火接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防火接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 11:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fireproof</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建防水接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防水接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 11:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Waterproof</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上三个接口定义完毕之后，接下来，我们来定义美美侠品牌的安全门类，并让其去实现以上三个接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 11:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeiMeiXiaSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>, Fireproof, Waterproof {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防盗"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防火"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防水"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，来编写一个测试类进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 11:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建美美侠安全门对象</span></span><br><span class="line">        <span class="type">MeiMeiXiaSafetyDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MeiMeiXiaSafetyDoor</span>();</span><br><span class="line">        <span class="comment">// 调用功能</span></span><br><span class="line">        door.antiTheft();</span><br><span class="line">        door.fireproof();</span><br><span class="line">        door.waterproof();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上测试类编写好之后，不妨来运行一下，如下图所示，可以看到，咱们设计的美美侠安全门确实具有了防盗、防火、防水的功能。</p>
<p><img src="/./assets/1709380160677-01869f51-ad51-477b-80d5-5aedb20da63e.png" alt="img"></p>
<p>这时，应该是解决了之前案例所存在的问题，为了验证这一点，我们在这儿再去定义一个阿昀品牌的安全门类，而且该类只具有防盗和防火功能，因此我们得让该类去实现防盗、防火这两个接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阿昀安全门</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AyunSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>, Fireproof {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防盗"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"防火"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上类定义完毕之后，我们再在Client测试类中编写如下代码进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 11:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建美美侠安全门对象</span></span><br><span class="line">        <span class="type">MeiMeiXiaSafetyDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MeiMeiXiaSafetyDoor</span>();</span><br><span class="line">        <span class="comment">// 调用功能</span></span><br><span class="line">        door.antiTheft();</span><br><span class="line">        door.fireproof();</span><br><span class="line">        door.waterproof();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 创建阿昀安全门对象</span></span><br><span class="line">        <span class="type">AyunSafetyDoor</span> <span class="variable">door1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AyunSafetyDoor</span>();</span><br><span class="line">        <span class="comment">// 调用功能</span></span><br><span class="line">        door1.antiTheft();</span><br><span class="line">        door1.fireproof();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时，不妨来运行一下以上测试类，如下图所示，可以看到，咱们设计的阿昀安全门确实是只具有防盗、防火这俩功能。</p>
<p><img src="/./assets/1709380160767-b8578660-cd0d-4134-a887-fdeb0a5be6e9.png" alt="img"></p>
<p>至此，安全门案例我们就改进完毕了，现在更好地符合了接口隔离原则。</p>
<hr>
<h2 id="3-5-迪米法特原则"><a href="#3-5-迪米法特原则" class="headerlink" title="3.5. 迪米法特原则"></a>3.5. 迪米法特原则</h2><h3 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1. 概述"></a>3.5.1. 概述</h3><p>迪米特法则，又叫最少知识原则。其表示的含义是只和你的直接朋友交谈，不跟”陌生人”说话。</p>
<p>看到这儿的话，很多人会一头雾水，尼玛的，这到底表示什么含义啊？不着急，咱们看下下面这段描述。</p>
<p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%80%A6%E5%90%88%E5%BA%A6&amp;spm=1001.2101.3001.7020">耦合度</a>，提高模块的相对独立性。</p>
<p>大家看到这儿，可能还不是特别理解，没关系，下面我会举几个现实生活中的例子来向大家解释一下。</p>
<p>看这样一个例子，如果一个人想要租房的话，那么他找的就该是房屋中介了，而不是直接的房主；再来看这样一个例子，明星和粉丝进行见面的话，肯定是由经纪人来进行安排的，是不是啊？</p>
<p>最后，再看一个例子，假设现在有家公司需要一个办公软件，那么这家公司是直接找具体的软件工程师，还是找某家开发软件的公司啊？肯定是软件公司，而软件公司又会有许多软件工程师，所以它会把甲方需要的办公软件交给具体的软件工程师去开发。其实，软件工程师在去开发软件的时候，很多情况下，他是压根就不知道到底是哪个甲方需要这个软件的，因此他是不需要直接去和甲方沟通的。如果要沟通的话，那么可以通过第三方转发进行沟通。也就是说，软件工程师把他在开发中遇到的问题告诉公司，公司再跟甲方进行沟通，这样，就可以降低软件工程师和甲方之间的耦合度了，继而提高模块的相互独立性。</p>
<p>看完以上我举的这三个例子，特别是最后一个例子，大家是不是对迪米特法则有了一个更深入的认识啊！</p>
<p>最后，我得多说一嘴，迪米特法则里面有一个”朋友”这个词，它所表示的含义是指当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系（当然，这里面还有依赖关系，因为有方法参数这样一个概念），可以直接访问这些对象的方法。</p>
<p>以上就是”朋友”所带来的好处，说得通俗一点，就是我可以直接去访问你里面的方法。</p>
<h3 id="3-5-2-案例"><a href="#3-5-2-案例" class="headerlink" title="3.5.2. 案例"></a>3.5.2. 案例</h3><p>了解了迪米特法则的概念之后，接下来我们来做一个案例，即明星与经纪人的关系实例，通过这个案例，希望能加深大家对迪米特法则的理解。</p>
<h4 id="3-5-2-1-案例分析"><a href="#3-5-2-1-案例分析" class="headerlink" title="3.5.2.1. 案例分析"></a>3.5.2.1. 案例分析</h4><p>明星由于全身心投入艺术，所以许多日常事务均由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p>通过上面的描述，我们不难设计出如下所示的类图。</p>
<p><img src="/./assets/1709380733832-97449132-6f81-41f1-bebf-0abd9abaaf64.png" alt="img"></p>
<p>从以上类图中可以看到，我们定义了一个明星类，它里面有一个name成员变量，用于表示明星的姓名，而且还有一个有参构造和获取明星姓名的getName方法。至于，另外定义的两个类，即粉丝类和媒体公司类，它俩与明显类比较相似，这里我就不再详细赘述了。</p>
<p>目前，定义好的以上这三个类是没有任何关系的，如果我们要让它们产生关系，那么就得借助于第三方类了，即经纪人类。在该类里面我们会声明以上三个类型的成员变量，并提供对应的setter方法，此外，我们还提供了与粉丝见面和业务洽谈这俩成员方法，而且这俩成员方法的具体描述，我也体现在以上类图中了。</p>
<p>有些同学可能会问，经纪人类和明星类、粉丝类、媒体公司类这三个类有什么关系呢？由于是在经纪人类里面声明了这三个类型的成员变量，所以经纪人类和这三个类就是属于聚合关系了，相信大家对这点是没有任何疑问的。</p>
<p>接下来，我们便来通过代码实现以上明星与经纪人的关系案例。</p>
<h4 id="3-5-2-2-案例实现"><a href="#3-5-2-2-案例实现" class="headerlink" title="3.5.2.2. 案例实现"></a>3.5.2.2. 案例实现</h4><p>打开咱们的maven工程，然后在com.meimeixia.principles包下创建一个子包，即demo5，我们是在该包下来存放咱们编写的代码的。接下来，我们就要正式开始编写代码来实现以上案例了。</p>
<p>首先，定义一个明星类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 明星类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 12:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Star</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，定义一个粉丝类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 粉丝类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fans</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fans</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，定义一个媒体公司类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 媒体公司类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，定义一个经纪人类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 经纪人类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 12:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> {</span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStar</span><span class="params">(Star star)</span> {</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFans</span><span class="params">(Fans fans)</span> {</span><br><span class="line">        <span class="built_in">this</span>.fans = fans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(Company company)</span> {</span><br><span class="line">        <span class="built_in">this</span>.company = company;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和粉丝见面的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(star.getName() + <span class="string">"和粉丝"</span> + fans.getName() + <span class="string">"见面"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和媒体公司洽谈的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(star.getName() + <span class="string">"和"</span> + company.getName() + <span class="string">"洽谈"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来编写一个测试类用作测试，不妨取名为Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.principles.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 13:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建经纪人类</span></span><br><span class="line">        <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">        <span class="comment">// 创建明星对象</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">"林青霞"</span>);</span><br><span class="line">        agent.setStar(star);</span><br><span class="line">        <span class="comment">// 创建粉丝对象</span></span><br><span class="line">        <span class="type">Fans</span> <span class="variable">fans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fans</span>(<span class="string">"张三"</span>);</span><br><span class="line">        agent.setFans(fans);</span><br><span class="line">        <span class="comment">// 创建媒体公司对象</span></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>(<span class="string">"美美侠媒体公司"</span>);</span><br><span class="line">        agent.setCompany(company);</span><br><span class="line"></span><br><span class="line">        agent.meeting(); <span class="comment">// 和粉丝见面</span></span><br><span class="line">        agent.business(); <span class="comment">// 和媒体公司洽谈业务</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上测试类编写好之后，不妨来运行一下，如下图所示，确实是我们想要的结果哟！</p>
<p><img src="/./assets/1709380733892-53901275-fb03-4597-a508-b5538a36f28a.png" alt="img"></p>
<p>至此，我们就通过以上案例更加深入地认识了一下迪米特法原则，它其实就是为了降低明星类和粉丝类以及媒体公司类之间的一个耦合度。</p>
<hr>
<h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6. 合成复用原则"></a>3.6. 合成复用原则</h2><h3 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1. 概述"></a>3.6.1. 概述</h3><p>合成复用原则是指尽量先使用组合或者聚合 等关联关系 来实现，其次才考虑使用继承关系来实现。</p>
<p>我们之前讲过继承关系，虽然使用继承可以提高代码的复用性，但是它存在很多问题，这些问题等会我们再去说，大家也别着急。</p>
<p>了解了合成复用原则的概念之后，我们还应知道，通常类的复用可分为继承复用（使用继承实现代码的复用性）和合成复用（使用组合或者聚合实现代码的复用性）两种。而且，这两种复用各有其优缺点，下面我就为大家详细阐述一下。</p>
<p><strong>我们先来看下继承复用的优缺点。</strong></p>
<ul>
<li>优点：简单、易实现</li>
<li>缺点：</li>
</ul>
<ol>
<li><ol>
<li><strong>继承复用破坏了类的封装性</strong>。为什么说破坏了类的封装性呢？因为继承会将父类的实现细节暴露给子类，也就是说子类可以直接去继承父类中的功能，这样，子类就可以将父类中的功能给覆盖掉了，所以，父类对子类是透明的。其实，这种复用我们又可称为”白箱”复用</li>
<li><strong>子类与父类的耦合度高</strong>。为什么说耦合度高呢？因为我们之前就已经讲过了，继承它本身就比组合、聚合的耦合度高。这样，父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护</li>
<li><strong>继承限制了复用的灵活性</strong>。如何去理解呢？从父类继承而来的实现是静态的，这是因为在编译时就已经定义好了，所以在运行时是不可能发生变化的。我们总不能说，在程序运行过程中，来解除子类和父类的继承关系吧！况且，这也是无法实现的，所以我们才说继承限制了复用的灵活性</li>
</ol>
</li>
</ol>
<p><strong>组合或聚合复用的优点。</strong></p>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，那么新对象就可以调用已有对象的功能了。所以，它相比于继承复用有以下优点：</p>
<ul>
<li><strong>维护了类的封装性</strong>。为什么说维护了类的封装性呢？因为成员对象的内部细节是对新对象不可见的，也就是说新对象不知道成员对象里面的具体的实现，但是可以调用其功能，所以这种复用又被称为”黑箱”复用</li>
<li><strong>对象间的耦合度低</strong>。我们之前就讲过，组合或者聚合本身就比继承的耦合度低。当我们真正去使用组合或者聚合复用时，我们可以在类的成员位置声明抽象父类或者父接口，这样，我们就能动态地去传递该抽象类或者父接口的子类对象了</li>
<li><strong>复用的灵活性高</strong>。这种复用可以在运行时动态进行，也就是说如果我们要给成员变量进行赋值，那么我们就可以在程序运行的时候才对其进行赋值了。若成员位置声明的是抽象的类或者接口，则我们就可以传递该接口或者该类的子类对象了。总之，这种复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的对象</li>
</ul>
<p>了解完合成复用原则的概念，以及继承复用、组合或者聚合复用各自的优缺点之后，我们来看一个案例，通过该案例，大家再去深入理解一下合成复用原则。</p>
<hr>
<h3 id="3-6-2-案例"><a href="#3-6-2-案例" class="headerlink" title="3.6.2. 案例"></a>3.6.2. 案例</h3><p>这个案例是汽车分类管理程序。</p>
<h4 id="3-6-2-1-案例分析"><a href="#3-6-2-1-案例分析" class="headerlink" title="3.6.2.1. 案例分析"></a>3.6.2.1. 案例分析</h4><p>汽车按”动力源”划分，可分为汽油汽车、电动汽车等；按”颜色”划分，可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，那么其组合就更多了。</p>
<p>以上案例要是使用继承复用的话，那么设计出来的类图就应该是下面这个样子的了。</p>
<p><img src="/./assets/1709381698723-0c7a33d6-bcf0-41a4-9f56-30348b9d72d9.png" alt="img"></p>
<p>从以上类图中可以看到，首先定义了一个顶层父类，即汽车类，而该类下面又有两个子类，一个是汽油汽车类，一个是电动汽车类。汽油汽车类下面又有两个子类，一个是红颜色的汽油汽车类，一个是白颜色的汽油汽车类；电动汽车类也是一样，它也有两个子类，一个是红颜色的电动汽车类，一个是白颜色的电动汽车类。</p>
<p>不知你有没有从以上类图中看出，使用继承复用产生了很多子类。如果现在又有一个新的动力源了，例如光能汽车，那么我们是不是又要在以上类图中添加一个新的子类啊？而且，我们还得添加更多的子类，因为光能汽车又得按”颜色”来划分。</p>
<h4 id="3-6-2-2-案例实现"><a href="#3-6-2-2-案例实现" class="headerlink" title="3.6.2.2. 案例实现"></a>3.6.2.2. 案例实现</h4><p>在这儿，我就不再通过代码来实现以上案例了，因为很简单，不值得我这样做。你要是有兴趣，不妨自个来写一下。</p>
<h4 id="3-6-2-3-案例改进"><a href="#3-6-2-3-案例改进" class="headerlink" title="3.6.2.3. 案例改进"></a>3.6.2.3. 案例改进</h4><p>如何对以上案例进行改进呢？很简单，将继承复用改为合成复用。那么，重新设计出来的类图就应该是下面这个样子了。</p>
<p><img src="/./assets/1709381698701-070794f7-ea55-4fb7-952f-0962b003c09a.png" alt="img"></p>
<p>首先，来看下以上类图中右边的部分，在这一部分，我们定义了一个颜色接口，而且该接口有两个子实现类，一个是Red类，一个是White类；在以上类图中左边的部分，我们定义了一个顶层父类，即汽车类，而且该类还聚合了Color接口，也就是说，到时候我们在去创建汽车对象的时候，就需要给它传递具体的颜色的子类对象了。此外，该汽车类还有两个子类，一个是汽油汽车类，一个是电动汽车类。</p>
<p>对比一下以上继承复用和合成复用的类图，如果要是现在多了一种动力源，例如光能汽车，那么使用继承复用该如何去做呢？使用合成复用又该如何去做呢？</p>
<p>如果要是使用继承复用，那么设计出来的类图就应该是下面这个样子的。</p>
<p><img src="/./assets/1709381698696-db966646-651e-425b-8a5a-c846e8fbfb08.png" alt="img"></p>
<p>以上就是我们新添加一种动力源，使用继承复用实现的方式。</p>
<p>下面，咱们再来看一下使用合成复用实现的方式。如果要是使用合成复用，那么设计出来的类图就应该是下面这个样子的。</p>
<p><img src="/./assets/1709381698729-a74689a7-aae2-42dd-8bf6-754b2187de6a.png" alt="img"></p>
<p>这时，你会发现，使用继承复用的话，我们要添加多个类，而使用合成复用的话，我们只需要添加一个类。通过对比，大家可以很明显地看到合成复用会更好一些。所以，我们说合成复用原则它就是尽可能的先使用组合或者聚合等关联关系来实现，如果不能使用它俩进行实现的话，那么我们才会去考虑使用继承关系来实现。</p>
<p>至此，合成复用原则我就给大家解释清楚了。</p>
<hr>
<h1 id="4-创建者模式"><a href="#4-创建者模式" class="headerlink" title="4. 创建者模式"></a>4. 创建者模式</h1><p>从本讲开始，咱们就要开始正式学习23种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>了。当然，我们得按照顺序来学，首先先来学习23种设计模式里面的第一类模式，即创建型模式。</p>
<p>创建型模式的主要关注点是”怎样创建对象？”，它的主要特点是”将对象的创建与使用分离”。也就是说，如果我们作为一个使用者的话，那么我们可以直接通过某种方式去获取别人创建好的对象，至于别人是如何创建的，我们并不关注。这样，就可以降低系统的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%80%A6%E5%90%88%E5%BA%A6&amp;spm=1001.2101.3001.7020">耦合度</a>了，使用者并不需要关注对象的创建细节，尤其是那些创建特别麻烦的对象。于是，创建型模式的好处就这样体现出来了。</p>
<p>此外，我们还应知道，创建型模式分为以下几种：</p>
<ul>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ul>
<p>注意，在本讲中，我们先来学习第一种创建型模式，即单例模式。</p>
<hr>
<h2 id="4-1-单例模式"><a href="#4-1-单例模式" class="headerlink" title="4.1. 单例模式"></a>4.1. 单例模式</h2><h3 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1. 概述"></a>4.1.1. 概述</h3><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>单例设计模式的概念讲完之后，接下来我们再来看一下单例设计模式的结构。</p>
<h3 id="4-1-2-结构"><a href="#4-1-2-结构" class="headerlink" title="4.1.2. 结构"></a>4.1.2. 结构</h3><p>单例设计模式主要有两种角色，它们分别是：</p>
<ul>
<li>单例类：该类只能创建一个对象</li>
<li>访问类：该类其实就是测试类，即使用单例类</li>
</ul>
<h3 id="4-1-3-实现"><a href="#4-1-3-实现" class="headerlink" title="4.1.3. 实现"></a>4.1.3. 实现</h3><p>在介绍单例设计模式的实现之前，我们先来看一下单例设计模式的分类，单例设计模式可分为如下两类：</p>
<ul>
<li><strong>饿汉式：</strong>类加载就会导致该单实例对象被创建。也就是说类加载的时候，该类的对象就创建好了</li>
<li><strong>懒汉式：</strong>类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li>
</ul>
<p>所以，我们如何去区分饿汉式和懒汉式呢？只需要去判断该单实例对象是否是在类加载的时候创建即可，若是，则是饿汉式，若不是，则是懒汉式。</p>
<h4 id="4-1-3-1-饿汉式"><a href="#4-1-3-1-饿汉式" class="headerlink" title="4.1.3.1. 饿汉式"></a>4.1.3.1. 饿汉式</h4><p>在本节，我们先来看一下饿汉式是如何来实现的。大家要注意了，饿汉式又可分为多种实现方式，在这里，我只介绍两种，它们分别是：</p>
<ul>
<li>静态成员变量方式</li>
<li>静态代码块方式</li>
<li>枚举方式(<strong>简单安全推荐</strong>)</li>
</ul>
<h5 id="4-1-3-1-1-静态成员变量"><a href="#4-1-3-1-1-静态成员变量" class="headerlink" title="4.1.3.1.1. 静态成员变量"></a>4.1.3.1.1. 静态成员变量</h5><p>下面咱们就得来正式编写代码实现饿汉式的第一种实现方式（即静态成员变量方式）了。</p>
<p>首先，在com.meimeixia.pattern.singleton.demo1包下创建一个单例类，不妨我们就命名为Singleton。</p>
<p>那如何创建该类呢？只要大家跟着我的思路一步一步来，相信大家肯定能创建出来。</p>
<ol>
<li><strong>私有构造方法：</strong>为什么要私有构造方法呢？因为私有了构造方法之后，外界就访问不到这个构造方法了，访问不到的话外界就无法去创建对象了</li>
<li>在本类中创建一个本类对象供外界去使用</li>
<li>提供一个公共的访问方式，让外界获取该对象</li>
</ol>
<p>经过上述三步，相信你很快就能创建出Singleton类了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：静态成员变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 18:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在本类中创建本类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的访问方式，让外界获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，以上该类中对外提供的公共访问方法，除了使用public修饰之外，还使用了static修饰，这是为什么呢？因为外界无法创建Singleton类的对象，既然不能创建对象的话，那么就无法去调用其非静态方法了，所以这里面我们对外要提供的是静态方法。而且，由于静态的不能直接访问非静态的，所以instance成员变量还得使用static来修饰。</p>
<p>然后，创建一个测试类，这里我们不妨就命名为Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 18:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断获取到的两个是否是同一个对象</span></span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，两次获取到Singleton类的对象之后，我们还得再来判断一下获取到的两个对象是不是同一个对象。</p>
<p>此时，我们运行一下以上测试类，如下图所示，可以看到打印结果是true，也就是说两次获取到Singleton类的对象是同一个对象，这样，我们就已经保证Singleton这个类只能创建一个对象了。</p>
<p><img src="/./assets/1709382451387-978f4701-6a4b-4d98-be92-aa39b9016b43.png" alt="img"></p>
<hr>
<h5 id="4-1-3-1-2-静态代码块"><a href="#4-1-3-1-2-静态代码块" class="headerlink" title="4.1.3.1.2. 静态代码块"></a>4.1.3.1.2. 静态代码块</h5><ol>
<li>私有构造方法：私有构造方法其实就是为了让外界不能创建该类的对象</li>
<li>在成员位置声明一个该类的成员变量，不过不要给其赋值</li>
<li>在静态代码块中进行赋值</li>
<li>对外提供一个公共的访问方式，让外界获取该对象</li>
</ol>
<p>经过上述四步，相信你很快就能创建出Singleton类了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：静态代码块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 18:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在静态代码块中进行赋值</span></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供获取该类对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你会发现，这和饿汉式的第一种实现方式唯一的区别是：对于饿汉式的第一种实现方式来说，在单例类里面是在成员位置声明了一个该类的成员变量，声明的同时并直接为其进行了赋值；而对于饿汉式的第二种实现方式而言，在单例类里面是先在成员位置声明了一个该类的成员变量，然后再在静态代码块里面对其进行赋值。除此之外，这两种实现方式就差不多了，其他就没有什么区别了。</p>
<p>紧接着，创建一个测试类，同理我们不妨命名为Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-28 23:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">// 判断两次获取到的Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们运行一下以上测试类，若打印结果是true，则说明我们确实已经做到了单例；若打印结果是false，则说明我们写的代码是有问题的。如下图所示，可以看到打印结果是true，也就是说两次获取到Singleton类的对象是同一个对象，当然了，多次获取到的肯定也是同一个对象，这不用说。</p>
<p><img src="/./assets/1709382451402-dfde12fd-e54e-4740-baee-f21580d9c3d5.png" alt="img"></p>
<p>至此，我就将饿汉式的两种实现方式讲解完了。那么我们不妨再来总结一下饿汉式有什么特点？不管是饿汉式的第一种实现方式还是第二种实现方式，它们都属于是在类加载的时候就已经创建了该类的对象。</p>
<p>大家不妨设想一下这种情况，如果我们只是对单例类进行了一个类加载的操作，并没有去获取该类的对象，那么这个对象是不是已经存在于内存中了啊！当然了，前提是使用饿汉式的方式来实现单例。此时，如果我们一直不用它的话，那么你会发现它是一直存在于内存中的，这势必就会造成内存的浪费。也就是说，饿汉式的另外一个特点是会造成内存的浪费。</p>
<p>由于饿汉式会浪费内存，所以我们还得去学习一下懒汉式，下面我就会讲到。</p>
<hr>
<h5 id="4-1-3-1-3-枚举方式-极力推荐"><a href="#4-1-3-1-3-枚举方式-极力推荐" class="headerlink" title="4.1.3.1.3. 枚举方式(极力推荐)"></a>4.1.3.1.3. 枚举方式(极力推荐)</h5><p>枚举类实现单例模式是极力推荐的单例实现方式，因为枚举类型是线程安全的（也即它不会存在线程安全问题），并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式；</p>
<p>其二，枚举的写法非常简单,   而且枚举类型是所有单例实现中<strong>唯一一种不会被破坏的单例实现方式</strong>。至于如何去破坏，我后面就会讲到，大家也别着急。</p>
<p>接下来，我们就来看一下具体的代码实现。</p>
<p>首先，在com.meimeixia.pattern.singleton包下再创建一个子包，即demo6，这表明编写的枚举实现方式的代码我们都会放在该包下。</p>
<p>然后，在com.meimeixia.pattern.singleton.demo6包下创建一个枚举类型的类，不妨我们就命名为Singleton。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举实现方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大家可能心里会犯嘀咕，真有这么简单吗？嘿嘿😘，枚举方式的实现还真这么简单。</p>
<p>接着，创建一个测试类，同理我们不妨命名为Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 20:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，我们运行一下以上测试类，若打印结果是true，则两次获取的是同一个对象；若打印结果是false，则两次获取的不是同一个对象。如下图所示，可以看到打印结果是true，这说明多次获取到的就是同一个对象。</p>
<p><img src="/./assets/1709382452150-120513f4-3b83-43be-9315-8a38d266c10f.png" alt="img"></p>
<p>最后，我得给大家说一个注意事项，就是枚举方式其实是属于饿汉式的，所以如果你不考虑浪费内存空间的话，那么就首选枚举这种实现方式吧！</p>
<hr>
<h4 id="4-1-3-2-懒汉式"><a href="#4-1-3-2-懒汉式" class="headerlink" title="4.1.3.2. 懒汉式"></a>4.1.3.2. 懒汉式</h4><p>饿汉式的两种实现方式讲完之后，接下来我们来看一下懒汉式。当然，懒汉式它也有多种实现方式，下面我会一一介绍给大家。</p>
<p>接下来，我们先来看懒汉式的第一种实现方式，即线程不安全的方式。</p>
<h5 id="4-1-3-2-1-线程不安全"><a href="#4-1-3-2-1-线程不安全" class="headerlink" title="4.1.3.2.1. 线程不安全"></a>4.1.3.2.1. 线程不安全</h5><ol>
<li>私有构造方法</li>
<li>在成员位置声明一个该类的成员变量，不过不要给其赋值</li>
<li>对外提供一个公共的访问方式</li>
</ol>
<p>经过以上三个步骤，可能有些同学写出来的Singleton类是下面这样的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// 只是声明了一个该类型的变量，并没有对其进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>写出来之后，他还很得意，他说懒汉式的概念不就是在首次使用单实例对象的时候才创建的嘛，首次使用无非就是调用以上getInstance方法呗，所以我在该方法里面给其赋值并返回出去，不是合情合理的吗？是，懒汉式的概念理解得是没错，但他没意识到一个问题，就是外界每调用一次getInstance方法，都会发现又重新new了一个对象，这样，多次获取到的肯定就不是同一个对象了。</p>
<p>你要是不信的话，不妨编写一个测试类来测试一下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 18:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两次获取到的Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类之后，如下图所示，你会发现打印结果是false，为什么是false呢？上面我已经分析过了，这里不再赘述。</p>
<p><img src="/./assets/1709382451415-de205f88-48bb-4da9-8001-55ddc4ed6671.png" alt="img"></p>
<p>而我们现在想要的是以上Singleton类只能创建一个对象，所以我们得在Singleton类的getInstance方法里面加上一个如下if判断。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// 只是声明了一个该类型的变量，并没有对其进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 判断instance是否为null，如果为null，那么说明还没有创建Singleton类的对象</span></span><br><span class="line">        <span class="comment">// 如果没有创建的话，那么我们就创建一个并返回；如果有创建，那么直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码改进之后，不妨再来运行一下测试类，如下图所示，发现打印结果是true，这说明咱们多次获取到的是同一个对象。</p>
<p><img src="/./assets/1709382451433-e86440df-e723-47e3-a603-5abe386de58b.png" alt="img"></p>
<p>你觉得以上Singleton类写的有没有什么问题啊？肯定是存在问题的，如果是多线程环境下，那么就会出现线程安全问题。</p>
<p>为什么这么说呢？假设现在是多线程环境，两个线程同时调用getInstance方法，线程1拿到cpu的执行权，它在调用getInstance方法时，首先肯定是要做一个判断的，做完判断之后，它会进入到判断里面。此时，如果线程2拿到了cpu的执行权，那么线程1就会处于等待状态，同样，线程2在调用getInstance方法时也是要进行判断的，你觉得线程2还能进入到判断里面吗？</p>
<p>肯定能够啊！因为此时if判断条件是成立的，即instance是等于null的，这一切都是由于线程1还处于等待状态，还未执行下面的代码而导致的。也就是说，只要线程2获取到了cpu的执行权，那么它也会进入到判断里面。这样，以上Singleton类创建的就不是单个对象了，而是多个。</p>
<hr>
<h5 id="4-1-3-2-2-线程安全"><a href="#4-1-3-2-2-线程安全" class="headerlink" title="4.1.3.2.2. 线程安全"></a>4.1.3.2.2. 线程安全</h5><p>既然以上实现方式在多线程环境下会出现线程安全问题，那么我们就得改进代码了，如何进行改进呢？很简单，只须在以上Singleton类的getInstance方法上加上一个同步关键字（即synchronized）即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// 只是声明了一个该类型的变量，并没有对其进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 判断instance是否为null，如果为null，那么说明还没有创建Singleton类的对象</span></span><br><span class="line">        <span class="comment">// 如果没有创建的话，那么我们就创建一个并返回；如果有创建，那么直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 线程1等待，线程2获取到cpu的执行权，也会进入到该判断里面</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于涉及到多线程，如果我们暂时不创建多线程的话，那么是演示不出来效果的，而且即使创建出来多线程，也不一定能演示出来效果，所以，我们只好做如下分析了。</p>
<p>假设线程1现在拿到了cpu的执行权，它在调用getInstance方法时，首先肯定是要做一个判断的，做完判断之后，它会进入到判断里面。此时，如果线程2拿到了cpu的执行权，那么线程1就会处于等待状态，这样，当线程2调用getInstance方法时，线程2现在还能进入到判断里面吗？很显然，进不来，因为这里面有一个同步锁，而线程1还在判断里面等待，它并没有释放这个同步锁，所以线程2是进不来的，它只能在外面等着。那么这样的话，线程2就只能等线程1执行完，而线程1执行完，就意味着instance变量已经被赋好值了，如此一来，就解决掉了线程不安全的问题了。</p>
<p>因此，以上两种实现方式要进行选择的话，我们肯定首选线程安全的这种实现方式。</p>
<p>讨论一下上面懒汉式线程安全的那种实现方式所存在的问题，也即在getInstance方法上加了锁之后所导致的<strong>性能问题。</strong></p>
<p>对于getInstance方法来说，绝大部分的操作都是读操作，而读操作本身就是线程安全的，所以我们没必要让每个线程必须持有锁才能调用该方法，故我们需要调整加锁的时机</p>
<p>看完上面这句话之后，有些同学可能不甚理解什么是读操作。没关系，我为大家解释一下，大家不妨看一下以上懒汉式的第二种实现方式所对应的代码，可以看到，第一次调用getInstance方法的时候，会先判断instance是否为null，此时肯定是为null的，所以就会创建一个Singleton类的对象，并将其赋给instance，这是一个赋值的操作，我们又可以称为写操作。</p>
<p>赋完值之后，接着就要把instance的值进行一个返回了，即将当前类的对象返回。后续每一次调用getInstance方法时，由于if判断语句中的条件不再成立（这是因为instance已经被赋予值了），所以都会直接将instance的值进行返回。于是，后续每一次调用getInstance方法，将instance直接返回的这个操作，我们就可以把它称为读操作了。</p>
<p>明确了读操作之后，我们继续看以上那句话的后半段描述，说我们没必要让每个线程必须持有锁才能调用getInstance方法，为什么呢？因为这会导致程序运行的性能更加低下。所以，我们才要调整加锁的时机，由此也产生了一种新的实现方式——双重检查锁方式。</p>
<hr>
<h5 id="4-1-3-2-3-双重检查锁-较好"><a href="#4-1-3-2-3-双重检查锁-较好" class="headerlink" title="4.1.3.2.3. 双重检查锁(较好)"></a>4.1.3.2.3. 双重检查锁(较好)</h5><p>既然是双重检查，那么肯定是两次判断了。接下来，我们就来看一下具体的代码实现。</p>
<p>首先，在com.meimeixia.pattern.singleton包下再创建一个子包，即demo4，这表明编写的懒汉式的第三种实现方式的代码我们都会放在该包下。</p>
<p>然后，在com.meimeixia.pattern.singleton.demo4包下创建一个单例类，该类我们同样命名为Singleton。</p>
<p>同理，只要大家跟着我的思路一步一步来，相信你一定能创建出该类。</p>
<ol>
<li>私有构造方法</li>
<li>在成员位置声明一个该类的成员变量，不过不要给其赋值</li>
<li>对外提供一个公共的访问方式，在该方法里面记得要做两次判断</li>
</ol>
<p>经过以上三个步骤，相信大家能写出来下面这样的Singleton类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查锁方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 18:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 第一次判断，如果instance的值不为null，那么就不需要抢占锁了，直接返回对象即可</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="comment">// 第二次判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，对于getInstance方法来说，我们是做了两次判断的。</p>
<ul>
<li>第一次判断：判断instance是否等于null，若是，则需抢占锁；若不是，则直接返回instance即可，由于并没有去持有锁，所以效率就可以得到提升了</li>
<li>第二次判断：如果第一次判断时，instance等于null，那么进来判断里面之后我们得先持有一把锁，所以在这儿咱们就编写了一个同步代码块，而且锁对象就是当前类的字节码对象，这样，我们就可以在同步代码块里面做第二次判断了。所做判断很简单，无非就是判断instance是否为null，若是，则需创建一个本类对象并将其赋值给instance；若不是，则直接返回instance即可</li>
</ul>
<p>以上双重检查锁方式的实现代码虽然写完了，但你不觉得还存在什么问题吗？</p>
<p>双重检查锁方式是一种非常好的单例实现方式，解决了单例、性能、线程安全问题，上面的双重检查锁方式看上去完美无缺，其实它是存在问题的，即在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p>
<p><img src="/./assets/1709385077666-f7fcba5a-0251-4c0a-979e-0eddce320a51.png" alt="img"></p>
<p>由于以上双重检查锁方式所存在的问题是在多线程的情况下有可能出现，有可能不出现，所以在这儿我就不为大家进行演示了。对了，还有引起该问题的原因中涉及到了一个指令重排序操作，在本课程里面我也不会做详细讲解，大家有兴趣的话不妨去看一下Java并发编程。</p>
<p>既然问题出现了，那如何进行解决呢？要解决双重检查锁方式所带来的空指针异常问题，只需要使用volatile关键字即可，因为该关键字的作用就是保证可见性和有序性，在此处体现的就是有序性。</p>
<p>那么问题又来了，volatile关键字我们应该放在哪呢？记住，我们应该放在instance变量上面，用它来修饰instance变量，这样，就可以保证指令是有序的了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查锁方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 18:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 第一次判断，如果instance的值不为null，那么就不需要抢占锁了，直接返回对象即可</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="comment">// 第二次判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上就是双重检查锁方式的标准代码。现在再去运行Client测试类，打印的结果肯定是true，这是毋庸置疑的。</p>
<p>最后，我做一个总结，<strong>添加volatile关键字之后的双重检查锁方式是一种比较好的单例实现方式，能够保证在多线程的情况下线程安全，并且也不会有性能问题</strong>。</p>
<hr>
<h5 id="4-1-3-2-4-静态内部类-优秀"><a href="#4-1-3-2-4-静态内部类-优秀" class="headerlink" title="4.1.3.2.4. 静态内部类(优秀)"></a>4.1.3.2.4. 静态内部类(优秀)</h5><p>上面我为大家讲解了双重检查锁这种单例实现方式，不过实现代码写起来还是稍微有点麻烦的，所以，在这一小节，我就来为大家介绍懒汉式的第四种实现方式，即静态内部类的方式。</p>
<p>静态内部类单例模式中实例由内部类创建，由于JVM在加载外部类的过程中，是不会加载静态内部类的，只有内部类的属性或者方法被调用时才会被加载，并初始化其静态属性。当然，这个静态属性所要被赋予的值其实就是外部类的对象。</p>
<p>而且，由于该静态属性被static修饰了，所以保证其只会被实例化一次，这样，就严格保证了实例化顺序，顺便就解决了上面所说的指令重排序的问题。</p>
<p>接下来，我们就来看一下具体的代码实现。</p>
<p>首先，在com.meimeixia.pattern.singleton包下再创建一个子包，即demo5，这表明编写的懒汉式的第四种实现方式的代码我们都会放在该包下。</p>
<p>然后，在com.meimeixia.pattern.singleton.demo5包下创建一个单例类，该类我们同样命名为Singleton。</p>
<p>同理，只要大家跟着我的思路一步一步来，相信你一定能创建出该类。</p>
<ol>
<li>私有构造方法</li>
<li>定义一个静态内部类，并在内部类中声明并初始化外部类的对象</li>
<li>在外部类里面，对外提供一个公共的访问方式，供外界去获取本类对象</li>
</ol>
<p>经过上述四步，相信你很快就能创建出Singleton类了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="comment">// 为了防止外界对该静态属性进行修改，故在其上加了一个final关键字，也即意味着它就是一个常量了</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建一个测试类，同理我们不妨命名为Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，我们运行一下以上测试类，若打印结果是true，则两次获取的是同一个对象；若打印结果是false，则两次获取的不是同一个对象。如下图所示，可以看到打印结果是true，这说明多次获取到的就是同一个对象。</p>
<p><img src="/./assets/1709382452188-7f208c8e-d1f4-4ba1-8c79-48ab580c2155.png" alt="img"></p>
<p>至此，静态内部类的这种实现方式我就给大家讲解完了。</p>
<p>那么，我们是在何时何地创建外部类的对象的啊？是在内部类里面声明了一个静态的外部类类型的属性之后再对其进行的初始化。由于我们是在外部类里面定义了一个静态内部类，所以当我们在getInstance方法里面通过内部类类名调用其静态属性时，JVM才会去加载该内部类(静态变量初始化由jvm控制,不用担心多线程问题)，并且初始化其静态属性。这样，该静态属性就只会被初始化一次了，即使是在多线程情况下调用getInstance方法，最终获取到的都是同一个对象。</p>
<p>最后，我们可以简单的做一个总结，<strong>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费</strong>。</p>
<hr>
<h3 id="4-1-4-存在的问题"><a href="#4-1-4-存在的问题" class="headerlink" title="4.1.4. 存在的问题"></a>4.1.4. 存在的问题</h3><p>接下来，我们来看一下单例模式所存在的问题，即破坏单例模式。</p>
<p>如何去理解破坏单例模式呢？就是使上面定义的单例类（即Singleton）可以创建多个对象，若能创建多个对象，则说明就已经破坏单例模式了，因为单例模式是只能让一个类创建一个对象。</p>
<p>不过要注意，<strong>枚举方式除外，这是因为枚举方式是JVM底层的一个实现，它已经把所有的问题都解决掉了</strong>。</p>
<p>那么，如何来破坏单例模式呢？有如下两种方式：</p>
<ul>
<li>序列化</li>
<li>反射</li>
</ul>
<p>下面我就挨个来为大家讲解。</p>
<h4 id="4-1-4-1-问题演示"><a href="#4-1-4-1-问题演示" class="headerlink" title="4.1.4.1. 问题演示"></a>4.1.4.1. 问题演示</h4><h5 id="4-1-4-1-1-序列化破坏单例模式"><a href="#4-1-4-1-1-序列化破坏单例模式" class="headerlink" title="4.1.4.1.1. 序列化破坏单例模式"></a>4.1.4.1.1. 序列化破坏单例模式</h5><p>在本小节，我就以静态内部类这种实现方式来为大家进行演示了。当然了，你还可以使用其他的实现方式，不过要注意，枚举方式除外。</p>
<p>先给大家看一下Singleton类的代码，注意，由于现在咱们要进行序列化操作，所以定义的单例类（即Singleton）必须实现序列化的接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建一个测试类，用来测试序列化破坏单例模式。注意，在该测试类中，除了主方法之外，我们还得定义两个方法，分别是：</p>
<ul>
<li>向文件中写数据（对象）：当然这块的数据指的就是对象，即把一个对象写到一个文件中</li>
<li>从文件中读取数据（对象）：这一块的数据也指的是对象</li>
</ul>
<p>明确以上对测试类的描述之后，相信大家不难写出下面这样的测试类代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试使用反射破坏单例模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 桌面路径：C:\Users\32120\Desktop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 调用方法进行测试...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取数据（对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1. 创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"C:\\Users\\32120\\Desktop\\a.txt"</span>));</span><br><span class="line">        <span class="comment">// 2. 读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        <span class="comment">// 3. 释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向文件中写数据（对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1. 获取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">// 2. 创建对象输出流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"C:\\Users\\32120\\Desktop\\a.txt"</span>));</span><br><span class="line">        <span class="comment">// 3. 写对象</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，现在咱们还未在主方法里面写代码来测试。下面，我们先在主方法里面调用一下writeObject2File方法来测试是否能向文件中写数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// 调用方法进行测试...</span></span><br><span class="line">    writeObject2File();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上主方法之后，发现桌面上生成了一个a.txt文件，当然了，你也别打开去看了，因为打开看的话你也看不懂。</p>
<p>测试完向文件中写数据的操作之后，咱们再来测试从文件中读取数据的操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// 调用方法进行测试...</span></span><br><span class="line">    <span class="comment">// writeObject2File();</span></span><br><span class="line">    readObjectFromFile();</span><br><span class="line">    readObjectFromFile();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上主方法之后，打印结果如下图所示，可<strong>以看到两次打印出来的对象地址不是同一个地址，即两次从文件里面读取到的对象不是同一个对象，这就说明序列化和反序列化已经破坏了单例模式</strong>。</p>
<p><img src="/./assets/1709382452187-0b70bea0-cced-4f61-8e97-6aac5e590154.png" alt="img"></p>
<hr>
<h5 id="4-1-4-1-2-反射破坏单例模式"><a href="#4-1-4-1-2-反射破坏单例模式" class="headerlink" title="4.1.4.1.2. 反射破坏单例模式"></a>4.1.4.1.2. 反射破坏单例模式</h5><p>刚才我们演示了通过序列化和反序列化去破坏单例模式，接下来，我们再来演示通过反射来破坏单例模式。</p>
<p>这里，我同样是以静态内部类这种实现方式来为大家演示的。当然了，大家还可以使用其他的实现方式，不过要注意，枚举方式除外。</p>
<p>先给大家看一下Singleton类的代码，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建一个测试类，用来测试反射破坏单例模式。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试使用反射破坏单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1. 获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">// 2. 获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 3. 取消访问检查</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 4. 通过反射的方式创建Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) cons.newInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) cons.newInstance();</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// 如果返回的是true，那么说明并没有破坏单例模式；如果是false，那么说明破坏了单例模式</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上主方法之后，可以看到打印结果是false，这说明通过反射两次创建的不是同一个对象，也即验证了反射可以破坏单例模式。</p>
<p><img src="/./assets/1709382452189-6fe9c684-fbe1-4234-99ed-7ed069697302.png" alt="img"></p>
<hr>
<h4 id="4-1-4-2-问题解决"><a href="#4-1-4-2-问题解决" class="headerlink" title="4.1.4.2. 问题解决"></a>4.1.4.2. 问题解决</h4><p>刚才我们已经通过序列化和反射这两种方式去破坏了单例模式，那么接下来我们要做的就是解决这个问题了。</p>
<h5 id="4-1-4-2-1-序列化破坏单例模式的解决方案"><a href="#4-1-4-2-1-序列化破坏单例模式的解决方案" class="headerlink" title="4.1.4.2.1. 序列化破坏单例模式的解决方案"></a>4.1.4.2.1. 序列化破坏单例模式的解决方案</h5><p>只须在Singleton类中添加一个叫readResolve的方法即可，这样，在反序列化时该方法就会被反射调用，如果定义了这个方法，那么就返回这个方法的值, 如果没有定义，那么就返回新new出来的对象。</p>
<p>所以，如果在Singleton类中没有定义该方法的话，那么当我们多次从文件中去读取对象时就会新new出来多个对象了，这就是序列化破坏单例模式的本质原因。</p>
<p>接下来，咱们就在Singleton类中定义一个readResolve方法，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当进行反序列化时，会自动调用该方法，并将该方法的返回值直接返回</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在Singleton类中添加完以上readResolve方法之后，我们便来到Client测试类中来测试一下，看它到底能不能解决序列化破坏单例模式这个问题。</p>
<p>如何测试呢？先重新向文件中写对象，再多次从文件中去读取对象。测试结果如下图所示，可以看到两次打印出来的对象地址是同一个地址，说明我们现在已经解决了这个问题。</p>
<p><img src="/./assets/1709382452245-b1fe1550-4380-407a-a8b9-7c27f46611d7.png" alt="img"></p>
<h6 id="4-1-4-2-1-1-readResolve方法源码分析"><a href="#4-1-4-2-1-1-readResolve方法源码分析" class="headerlink" title="4.1.4.2.1.1. readResolve方法源码分析"></a>4.1.4.2.1.1. readResolve方法源码分析</h6><p>此刻，大家可能有这样一个疑问，上面已经说了，在反序列化时readResolve方法就会被反射调用，难道该方法就真的会被调用吗？为了弄清楚这个问题，我们就不得不去研究一下底层原理了。</p>
<p>那从何研究起呢？从ObjectInputStream类中的readObject方法开始研究即可，因为该方法是用来读取对象的。接下来，我们就来研究一下该方法在读取对象时，对象是新new的呢？还是调用Singleton类里面的readResolve方法直接返回的？</p>
<p>先进入到ObjectInputStream类的readObject方法中，如下图所示，该方法里面的代码有很多，所以大家跟着我一块走，来看一下重点的代码，其他的暂时不用去关注。</p>
<p><img src="/./assets/1709382452982-a9345d66-e5af-40b0-a681-4adedebef7e1.png" alt="img"></p>
<p>看到它里面的readObject0方法没？我们再进入到readObject0方法里面去看一下其实现，如下图所示，该方法里面的代码也是有很多，但我们只关注重点代码。</p>
<p><img src="/./assets/1709382452788-162b9851-bdb4-4222-aa9c-32c09e7c99ec.png" alt="img"></p>
<p>往下翻阅该方法，你会看到一个有switch选择语句，然后找到TC_OBJECT选项中的readOrdinaryObject方法，如下图所示。</p>
<p><img src="/./assets/1709382452936-43acd528-1581-4000-90cd-37f153e2d4d6.png" alt="img"></p>
<p>找到之后，再进入该方法中，该方法里面的代码也是有很多，但我们只关注重点代码。于是，我们往下翻阅，直至找到hasReadResolveMethod这个方法为止，如下图所示。</p>
<p><img src="/./assets/1709382452950-d8548ea2-f306-459b-a249-6c7f8f31d256.png" alt="img"></p>
<p>大家看该方法的方法名就可以了，不必再进去看其具体的实现。从该方法的方法名（即hasReadResolveMethod），我们就能看出它是来判断是否有readResolve方法的，如果有的话，那么肯定返回的就是true了，反之返回的就是false。</p>
<p>由于我们在Singleton类中已经定义了一个readResolve方法，所以这儿的hasReadResolveMethod方法返回的结果就是true，继而程序就会进入到if判断语句中，接着便会来执行invokeReadResolve方法了，见名思意，该方法是来调用readResolve方法的，因此我们也就不再进入到invokeReadResolve方法里面去看了。</p>
<p>这样，你就会得出这样一个结论了，即如果我们在Singleton类中定义了一个readResolve方法，那么在反序列化时该方法就会被反射调用，如果没有定义的话，那么就会重新new出一个对象来。</p>
<hr>
<h5 id="4-1-4-2-2-反射破坏单例模式的解决方案"><a href="#4-1-4-2-2-反射破坏单例模式的解决方案" class="headerlink" title="4.1.4.2.2. 反射破坏单例模式的解决方案"></a>4.1.4.2.2. 反射破坏单例模式的解决方案</h5><p>首先，我们先分析一下反射是如何破坏单例模式的？通过上面反射破坏单例模式的演示，我们就能知道了，就是通过反射去获取Singleton类的私有构造方法，然后再利用该私有构造方法去创建对象，这就是反射破坏单例模式的本质原因。</p>
<p>接下来，大家就要思索反射破坏单例模式的解决方案了。</p>
<p>大家不妨开动自己的脑筋想一想，看是不是这样的，如果是第一次调用Singleton类的私有构造方法去创建单实例对象，那么就允许其去创建，当单实例对象创建出来并存在于内存中之后，接下来要是再来调用Singleton类的私有构造方法的话，就直接抛出一个异常即可。</p>
<p>由于我们是通过静态内部类这种方式来实现单例模式的，所以在Singleton类里面我们就要声明一个静态的布尔类型的变量，判断一下Singleton类的私有构造方法是第一次还是后面几次调用去创建对象的。</p>
<p>有些同学可能为会问，为什么该布尔类型的变量要是静态的呢？这是因为要让所有的线程（或者锁）所共享。</p>
<p>键盘啪啪啪敲起来，相信大家很快就能写出下面这样的代码了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 判断flag的值是否为true，若是true，则说明非第一次访问，直接抛一个异常，若是false，则说明第一次访问，就让该私有构造方法正常的去创建对象即可</span></span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"不能创建多个对象"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将flag的值设置为true</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>写完了之后，大家分析一下以上代码还存不存在什么问题啊？其实还存在一个问题，就是如果是多线程环境的话，那么它就可能出现线程安全问题了。那如何去解决呢？很简单，直接使用一个同步代码块将以上Singleton类的私有构造方法的代码全部包裹起来就行，当然，锁对象就是当前类的字节码对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-29 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">            <span class="comment">// 判断flag的值是否为true，若是true，则说明非第一次访问，直接抛一个异常，若是false，则说明第一次访问，就让该私有构造方法正常的去创建对象即可</span></span><br><span class="line">            <span class="keyword">if</span> (flag) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"不能创建多个对象"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 将flag的值设置为true</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，我们再去运行一下测试类，你会发现控制台中抛出了如下这样一个异常，打印的异常信息就是不能创建多个对象。</p>
<p><img src="/./assets/1709382453124-d667f3c1-494b-4cc5-9537-5b705020803f.png" alt="img"></p>
<p>有些同学会问，这个异常到底是第一次调用私有构造方法时报的，还是第二次调用时报的呢？很简单，Debug调试一下便知道了。</p>
<p>首先，将断点打在Singleton类的私有构造方法处，如下图所示。</p>
<p><img src="/./assets/1709382453556-cff134e0-19f6-44f6-aabf-94e41d2713d6.png" alt="img"></p>
<p>然后，以Debug方式来运行测试类。这时，程序会停留在断点处，如下图所示，可以看到此时flag为false，那么很显然程序并不会进入到if判断语句里面去，当程序走完这个私有构造方法，单实例对象就创建成功了。</p>
<p><img src="/./assets/1709382453600-774b20c9-a5dc-4f15-add9-10901d0feea6.png" alt="img"></p>
<p>这是第一次调用Singleton类的私有构造方法，可见并没有抛异常。</p>
<p>接着，按住F6快捷键让程序一直往下运行，直至再次运行到Singleton类的私有构造方法中，如下图所示，可以看到此时flag为true，那么很显然程序就会进入到if判断语句里面去，必然就会抛出一个异常了。</p>
<p><img src="/./assets/1709382453731-3810db64-84c0-4198-aa47-dee41e1d17cd.png" alt="img"></p>
<p>所以，大家一定要清楚是第二次调用Singleton类的私有构造方法去创建对象的时候才会抛异常。</p>
<p>以上就是反射破坏单例模式的解决方案，我就先讲到这。</p>
<hr>
<h3 id="4-1-5-单例模式在源码中的体现"><a href="#4-1-5-单例模式在源码中的体现" class="headerlink" title="4.1.5. 单例模式在源码中的体现"></a>4.1.5. 单例模式在源码中的体现</h3><p>大家学完单例模式之后，要思考一个问题，就是在JDK源码里面，哪些类用到了单例模式呢？</p>
<p>在这里我给大家介绍一个类，即Runtime，该类就使用到了单例模式，那么它使用的是哪种单例模式呢？查看源码便知道了，如下图所示。</p>
<p><img src="/./assets/1709382453806-6e6b2224-c2a1-44e2-9a81-3f5bfea7faf0.png" alt="img"></p>
<p>我们都知道，要去使用单例模式的话，首先第一件事就是私有构造方法，那么在Runtime类中有没有私有构造方法的代码呢？很显然有，就是下面这行代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> {}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，在Runtime类的源码里面，我们还能看到第一行声明了一个静态的私有的Runtime类型的变量，并且还为其进行了初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>看到这，我们就能知道，这不就是标准的饿汉式吗？</p>
<p>接着，猜都能猜得到，该类里面肯定有一个方法就是让外界去获取该类对象，该方法如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这证实了我们的一个猜想，Runtime类就是利用标准的饿汉式（静态属性）来实现单例模式的。</p>
<p>分析完了之后，接下来，我们来简单的用一下Runtime类。</p>
<p>首先，创建一个类，该类我们就命名为RuntimeDemo，用于测试Runtime类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.singleton.demo9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// 获取Runtime类的对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="comment">// 调用runtime对象的exec方法，参数要的是一个命令</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">"ipconfig"</span>);</span><br><span class="line">        <span class="comment">// 调用process对象的获取输入流的方法</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">// 定义的字节数组比较大，因为我们想一次性把数据全部给它读进来</span></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(arr); <span class="comment">// 返回读到的字节的个数</span></span><br><span class="line">        <span class="comment">// 将字节数组转换为字符串并输出到控制台</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, len, <span class="string">"GBK"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，运行以上RuntimeDemo类，发现控制台中打印了如下内容，即咱们计算机现有的那些网卡，以及当前正在用的网卡所占的IP地址等等这些信息。</p>
<p><img src="/./assets/1709382453904-0800d478-c45e-4e7a-99db-636efc628040.png" alt="img"></p>
<p>至此，我们就简单地用了一下Runtime类，主要就是看单例模式对应的类的对象应该如何去获取。</p>
<hr>
<h2 id="4-2-工厂方法模式"><a href="#4-2-工厂方法模式" class="headerlink" title="4.2. 工厂方法模式"></a>4.2. 工厂方法模式</h2><h3 id="4-2-1-引子：咖啡店点餐系统"><a href="#4-2-1-引子：咖啡店点餐系统" class="headerlink" title="4.2.1. 引子：咖啡店点餐系统"></a>4.2.1. 引子：咖啡店点餐系统</h3><p>在学习工厂方法模式之前，我们先来看一个需求，设计一个咖啡店点餐系统。下面我们就来分析一下该需求。</p>
<p>咖啡店点餐系统点的肯定是咖啡，所以我们需要设计一个咖啡类（即Coffee），而咖啡它又有不同的品种：美式咖啡、拿铁咖啡等。这样，我们又得设计两个类，即美式咖啡类（即AmericanCoffee）和拿铁咖啡类（即LatteCoffee），很显然，我们得让这俩类去继承咖啡类，因为它俩可以向上抽取出共性的东西，而这些共性的东西可以放在咖啡类里面，用以提高代码的一个复用性。关于咖啡的这三个类设计完了之后，咱们还得设计一个咖啡店类，该类里面就具有点咖啡的功能，客户来了之后可以进行咖啡的一个点餐。</p>
<p>根据以上简单的分析，相信大家能画出下面这样的一个类图来。</p>
<p><img src="/./assets/1709386963620-d420b9d4-a4a7-4156-9d8b-545bb2a23dcd.png" alt="img"></p>
<p>先看以上类图的右边部分，顶层有一个父类，即咖啡类（Coffee），它里面定义有如下三个方法：</p>
<ol>
<li>getName方法：获取咖啡的名称。由于不同品种的咖啡返回的名称是不一样的，所以该方法应该是一个抽象的方法，要求子类自己去重写</li>
<li>addMilk方法：加奶。几乎所有的咖啡都需要加奶</li>
<li>addSugar方法：加糖。几乎所有的咖啡都需要加糖</li>
</ol>
<p>再来看咖啡类下面的两个子类，一个是美式咖啡类（即AmericanCoffee），一个是拿铁咖啡类（即LatteCoffee），它俩都重写了父类中的getName方法。</p>
<p>然后，我们再来看一下以上类图的左边部分，有一个咖啡店类（即CoffeeStore），它里面只有一个orderCoffee方法，它是用来点咖啡的，并且它里面还有一个String类型的参数。该参数表示的是什么含义呢？客户要点什么咖啡，不管是美式咖啡还是拿铁咖啡，他是不是得告诉咖啡店的前台服务员啊，然后咖啡店的前台服务员再根据客户所点咖啡类型去点餐。如果客户点的是美式咖啡，那么他只须给咖啡店的前台服务员传递一个american字符串就行；如果客户点的是拿铁咖啡，那么他只须给咖啡店的前台服务员传递一个latte字符串就行。</p>
<p>以上就是我们对咖啡店点餐系统的设计类图的一个分析。分析完了之后，接下来，我们就要开始编写代码来实现了。</p>
<p>首先，打开咱们的maven工程，在com.meimeixia.pattern包下新建一个子包，即factory.before，我们是在该包中来编写以上咖啡店点餐系统的代码的。</p>
<p>然后，创建一个咖啡类，即Coffee。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加糖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加糖"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加奶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加奶"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，我们再创建以上咖啡类的两个子类。先创建第一个子类，即美式咖啡类（AmericanCoffee），注意，该美式咖啡类要去继承Coffee类并重写里面的getName方法哟！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美式咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"美式咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建第二个子类，即拿铁咖啡类（LatteCoffee），同样，该类得去继承Coffee类并重写里面的getName方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿铁咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"拿铁咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，Coffee类以及它的子类就已经全部创建完毕了。</p>
<p>接下来，我们再创建一个咖啡店类，即CoffeeStore。根据以上设计类图，相信你能写出来下面这样一个类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡店</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="comment">// 声明Coffee类型的变量，根据不同类型创建不同的Coffee子类对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"american"</span>.equals(type)) {</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"latte"</span>.equals(type)) {</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"对不起，您所点的咖啡没有"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个测试类来测试一下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 22:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 1. 创建咖啡店类</span></span><br><span class="line">        <span class="type">CoffeeStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeStore</span>();</span><br><span class="line">        <span class="comment">// 2. 点咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> store.orderCoffee(<span class="string">"american"</span>);</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类，发现控制台打印了如下内容，我们想点的是美式咖啡，结果打印的也是美式咖啡，还加奶、加糖了，这说明咱们写的代码是没有任何问题的。</p>
<p><img src="/./assets/1709386963730-946e15aa-aeb9-4e72-8d23-eb46a081110c.png" alt="img"></p>
<p>至此，以上咖啡店点餐系统的代码我们就已经实现完毕了。</p>
<p>接下来，我们来分析一下以上咖啡店点餐系统的实现代码有没有什么问题。</p>
<p>大家不妨再来看一下咖啡店类，该类里面的点咖啡功能是要依赖于美式咖啡类和拿铁咖啡类的，如果后期我们再加一种咖啡的品种的话，那么势必就要修改这个方法里面的代码了，那么这就违背软件设计原则里面的开闭原则（即对修改关闭）了，而我们现在是肯定要修改之前的代码的。</p>
<p>用更加专业一点的话说，就是在Java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，那么就会对该对象耦合严重，假如我们要更换对象，那么所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。</p>
<p>问题是知道了，那么如何进行解决呢？其实大家想一想现实生活中的场景就知道解决方案了。比如说，我现在要用一台电脑，那么我是自己去生产一台电脑吗？很显然不是，我们直接购买一台就行，那么电脑是由谁去生产的呢？由具体的电脑工厂去生产，是不是啊？手机也是一样的，我们用一个手机，并不需要自己去生产，而是直接去买一个就行，手机也是由具体的手机工厂去生产的。</p>
<p>所以我们要改进以上点咖啡的案例，就得去解除咖啡店和具体咖啡的一个耦合了，这样，我们就要引入工厂思想了，通过工厂来生产对象，而我们只需要通过工厂去获取对象就行了，也就是说，我们只需要和工厂打交道就行，如此一来，就彻底和对象解耦了，当然，这儿的对象指的就是具体的咖啡对象。如果要更换对象，那么直接在工厂里面更换该对象即可，于此，便能达到与对象解耦的目的了。所以说，工厂模式最大的优点就是<strong>解耦</strong>。</p>
<p>在本教程中我会向大家介绍三种工厂的使用，它们分别是：</p>
<ol>
<li>简单工厂模式：它并不属于GOF的23种经典设计模式，也即没被收录到里面，但是在真正的开发中也有很多人习惯去用简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
<p>下面，我先来为大家介绍一下简单工厂模式。</p>
<hr>
<h3 id="4-2-2-简单工厂模式"><a href="#4-2-2-简单工厂模式" class="headerlink" title="4.2.2. 简单工厂模式"></a>4.2.2. 简单工厂模式</h3><h4 id="4-2-2-1-概念"><a href="#4-2-2-1-概念" class="headerlink" title="4.2.2.1. 概念"></a>4.2.2.1. 概念</h4><p>简单工厂模式不是一种设计模式，反而比较像一种编程习惯，如果我们以后开发有遇到适用的场景，那么就可以使用简单工厂模式了。</p>
<h4 id="4-2-2-2-结构"><a href="#4-2-2-2-结构" class="headerlink" title="4.2.2.2. 结构"></a>4.2.2.2. 结构</h4><p>简单工厂模式里面包含如下角色：</p>
<ul>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。上面点咖啡的案例中就用到了抽象产品这个角色，就是咖啡类（即Coffee），它里面定义了一套规范</li>
<li>具体产品：实现或者继承抽象产品的子类。在上面点咖啡的案例中，具体产品指的就是拿铁咖啡、美式咖啡</li>
<li>具体工厂：提供了创建产品的方法，调用者通过该方法来获取产品</li>
</ul>
<p>可以看到，如果我们现在使用简单工厂模式来改进以上点咖啡的案例的话，那么只需要多一个角色（即具体工厂）就行了。</p>
<p>接下来，我们就来看一下如何使用简单工厂模式来改进以上点咖啡的案例。</p>
<h4 id="4-2-2-3-实现"><a href="#4-2-2-3-实现" class="headerlink" title="4.2.2.3. 实现"></a>4.2.2.3. 实现</h4><p>现在使用简单工厂模式对上面案例进行改进，类图设计如下：</p>
<p><img src="/./assets/1709386963661-f2aad69a-4229-4c9a-9750-08d5a5fbe3e6.png" alt="img"></p>
<p>可以看到，咖啡相关的类是没有发生任何变化的，而咖啡店类发生了一点变化，即该类里面的点咖啡功能发生了变化，现在我们是通过简单咖啡工厂来生产咖啡，而不用自己再去new对象了。此外，相比之前的类图，我们还加入了一个简单咖啡工厂类，它就是用来生产咖啡的。</p>
<p>分析完了之后，接下来，我们就要开始编写代码来实现了。</p>
<p>首先，在com.meimeixia.pattern.factory包下新建一个子包，即simple_factory，我们是在该包中来编写以上点咖啡案例改进之后的代码的。</p>
<p>由于咖啡相关的类没有发生任何变化，所以我们可以将以上案例中的咖啡相关的类拷贝过来。</p>
<ul>
<li>咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.simple_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 咖啡类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加糖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加糖"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加奶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加奶"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>美式咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.simple_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 美式咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"美式咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>拿铁咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.simple_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拿铁咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"拿铁咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建一个简单咖啡工厂类，即SimpleCoffeeFactory，该类是用来生产咖啡的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.simple_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单咖啡工厂类，用来生产咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 22:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="comment">// 声明Coffee类型的变量，根据不同类型创建不同的Coffee子类对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"american"</span>.equals(type)) {</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"latte"</span>.equals(type)) {</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"对不起，您所点的咖啡没有"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，简单咖啡工厂类中的生产咖啡功能的实现逻辑和我们之前咖啡店类中的点咖啡功能的实现逻辑是一样的。</p>
<p>接着，再创建一个咖啡店类，即CoffeeStore。根据以上设计类图，相信你能写出来下面这样一个类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.simple_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡店</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="type">SimpleCoffeeFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffeeFactory</span>();</span><br><span class="line">        <span class="comment">// 调用生产咖啡的方法</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee(type);</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，对于咖啡店类来说，它是不是就不依赖于具体的咖啡产品对象了啊！这样，就解除了咖啡店和具体的咖啡产品对象之间的一个耦合。</p>
<p>最后，我们来创建一个测试类来测试一下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.simple_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 23:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建咖啡店类对象</span></span><br><span class="line">        <span class="type">CoffeeStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeStore</span>();</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> store.orderCoffee(<span class="string">"latte"</span>);</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类，发现控制台打印了如下内容，我们想点的是拿铁咖啡，结果打印的也是拿铁咖啡，还加奶、加糖了，这说明咱们写的代码是没有任何问题的。</p>
<p><img src="/./assets/1709386963629-c79390c4-31ab-4f71-8d00-7292731194d6.png" alt="img"></p>
<p>接下来，我们不妨再来分析一下以上改进后的案例的代码。</p>
<p>上面我们引入了一个简单咖啡工厂类，它是用来处理创建对象的细节的，也就是说，我们把到底创建的是美式咖啡还是拿铁咖啡这段逻辑放在了该简单咖啡工厂类里面。如果我们以后要去创建具体的咖啡对象的话，那么直接从工厂中获取就行了，因为现在咖啡店类中的orderCoffee方法变成了工厂对象的客户。这样，便解除了咖啡店类和具体咖啡子类之间的一个耦合。</p>
<p>但同时它又产生了新的耦合，哪个耦合呢？现在工厂对象和具体的产品对象已经耦合死了。如果我们后期要添加一个新的咖啡的品种的话，那么我们还需要去修改简单工厂类里面的代码，这个就是一个新的耦合。</p>
<p>而且，如果我们后期要添加新的咖啡的品种的话，那么势必还要修改简单工厂类里面的代码，而这违背了<strong>开闭原则（开闭原则指的就是对修改关闭，对扩展开放）</strong>，现在很明显我们要修改原有的代码。</p>
<p>那么，<strong>使用简单工厂模式和我们之前的做法有什么区别呢</strong>？工厂类的<strong>客户端可能有很多</strong>（只是现在咱们工厂类的客户端只有一个，就是咖啡店），比如创建美团外卖、甜品店（甜品店也有卖咖啡）等，如果要是我们之前的做法，那么就得修改很多客户端的代码了，有咖啡店客户端的代码，有美团外卖客户端的代码，有甜品店客户端的代码。<strong>而****如果我们要是引入了简单工厂类的话，那么我们只需要去修改简单工厂类的代码即可，省去了其他的修改操作</strong>，这就是使用简单工厂模式所带来的好处。</p>
<h4 id="4-2-2-4-优缺点"><a href="#4-2-2-4-优缺点" class="headerlink" title="4.2.2.4. 优缺点"></a>4.2.2.4. 优缺点</h4><p>简单工厂模式有如下优缺点：</p>
<ul>
<li>优点：封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑分开（现在的业务逻辑就是咖啡店点咖啡的这个业务，而该业务已经与具体的咖啡对象解除耦合了），这样以后就避免了修改客户端代码，如果要实现新产品，那么直接修改工厂类即可，而不需要再在原代码上进行修改了，这样就降低了客户端代码修改的可能性，更加容易扩展</li>
<li>缺点：增加新产品时还是需要修改工厂类的代码，违背了开闭原则。虽然违背了开闭原则，但是比之前不用简单工厂模式还是要更好一些</li>
</ul>
<hr>
<h4 id="4-2-2-5-扩展"><a href="#4-2-2-5-扩展" class="headerlink" title="4.2.2.5. 扩展"></a>4.2.2.5. 扩展</h4><h5 id="4-2-2-5-1-静态工厂模式"><a href="#4-2-2-5-1-静态工厂模式" class="headerlink" title="4.2.2.5.1. 静态工厂模式"></a>4.2.2.5.1. 静态工厂模式</h5><p>在本小节，我们对简单工厂模式进行一个扩展，即静态工厂模式。</p>
<p>在以后真正的开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，注意了，它也不是23种设计模式中的，只不过是一种习惯的写法而已。</p>
<p>下面我们就使用静态工厂模式来实现以上案例。</p>
<p>实现非常简单，只需要把之前的工厂类（即SimpleCoffeeFactory）中的创建具体咖啡对象的方法定义为静态的就可以了，其他类的代码都不需要进行一个改动。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.static_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单咖啡工厂类，用来生产咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 22:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="comment">// 声明Coffee类型的变量，根据不同类型创建不同的Coffee子类对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"american"</span>.equals(type)) {</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"latte"</span>.equals(type)) {</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"对不起，您所点的咖啡没有"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上可以看到，我们在com.meimeixia.pattern.factory包下新建了一个子包，即static_factory，也就是说，使用静态工厂模式实现以上案例的代码我们都放在了该包下。注意了，大家还要记得将其他的类都拷贝到static_factory包下哟！</p>
<p>以上SimpleCoffeeFactory类修改完毕之后，客户端（即咖啡店类）也得稍微修改一下，即无需再去创建咖啡工厂对象，而只需要通过SimpleCoffeeFactory类调用它里面的静态方法去获取一个具体的咖啡对象就行了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.static_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡店</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="comment">/*SimpleCoffeeFactory factory = new SimpleCoffeeFactory();</span></span><br><span class="line"><span class="comment">        // 调用生产咖啡的方法</span></span><br><span class="line"><span class="comment">        Coffee coffee = factory.createCoffee(type);*/</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> SimpleCoffeeFactory.createCoffee(type);</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么使用静态工厂模式有什么好处呢？不用再创建重复的对象, 使用静态工厂模式唯一的一个好处就是我们在其他的客户端，例如美团外卖，从工厂对象里面去获取咖啡对象时，就不需要再去创建咖啡工厂对象了，直接通过类名去调用它里面的方法就能获取到。</p>
<hr>
<h5 id="4-2-2-5-2-简单工厂模式-配置文件"><a href="#4-2-2-5-2-简单工厂模式-配置文件" class="headerlink" title="4.2.2.5.2. 简单工厂模式 + 配置文件"></a>4.2.2.5.2. 简单工厂模式 + 配置文件</h5><p>在本小节，我们再来学习一个简单工厂模式的扩展，即使用简单工厂模式+配置文件的方式来解除耦合，注意，这种方式可以完全的解除耦合哟！而且在真正的开发中，我们会经常使用这种固定的套路，并且使用的还比较多哟！对了，我们无比熟悉的Spring框架，其实它底层就用到了这种方式。</p>
<p>我们再来看一下更为专业的描述：</p>
<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象之间的耦合。在工厂类中加载配置文件中的全类名（注意，配置文件只需要加载一次即可），并通过反射创建对象进行存储，客户端如果需要对象的话，那么直接进行获取即可。</p>
<p>看完上面这段描述之后，我们知道我们还得创建一个配置文件，并还需要在配置文件中去配置类的全类名。接下来，我就来教大家如何使用简单工厂模式+配置文件的方式来实现以上点咖啡的案例。</p>
<p>首先，在com.meimeixia.pattern.factory包下新建一个子包，即config_factory，使用简单工厂模式+配置文件的方式来实现以上点咖啡案例的代码我们都放在了该包下。</p>
<p>然后，将咖啡类、美式咖啡类、拿铁咖啡类这三个类从上面拷贝到config_factory包下，因为这三个类并不需要进行修改。本想着就不在这里贴出来这三个类的代码了，但转念一想，为了让大家看得更清楚，还是贴出来吧！</p>
<ul>
<li>咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.config_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 咖啡类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加糖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加糖"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加奶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加奶"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>美式咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.config_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 美式咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"美式咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>拿铁咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.config_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拿铁咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"拿铁咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，在maven工程的src &gt; main &gt; resources目录下创建一个配置文件，为了演示方便，这里我们不妨使用properties文件来作为配置文件，文件名字就起为bean.properties，你看咋样？文件内容如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">american=com.meimeixia.pattern.factory.config_factory.AmericanCoffee</span><br><span class="line">latte=com.meimeixia.pattern.factory.config_factory.LatteCoffee</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建工厂类，当然了，这里我们创建的是静态工厂模式的工厂类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.config_factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 22:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们所要所做的事情，就是加载配置文件，然后去获取配置文件中配置的全类名，并创建该类的对象进行存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义容器对象存储咖啡对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 容器选择双列集合</span></span><br><span class="line"><span class="comment">     *      键：（咖啡）名称</span></span><br><span class="line"><span class="comment">     *      值：咖啡对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Coffee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Coffee&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 加载配置文件中的全类名，并通过反射创建对象进行存储，注意，配置文件只需要加载一次。</span></span><br><span class="line">    <span class="comment">// 由于配置文件只需要加载一次，所以我们最好将代码写在静态代码块里面</span></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">// 2.1 创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 2.2 调用p对象的load方法进行配置文件的加载，注意，配置文件（即bean.properties）是在类路径下面哟！</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class</span><br><span class="line">                                      .getClassLoader()</span><br><span class="line">                                      .getResourceAsStream(<span class="string">"bean.properties"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">// 从p集合中获取全类名并创建对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) {</span><br><span class="line">                <span class="comment">// 获取到全类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.getProperty((String) key);</span><br><span class="line">                <span class="comment">// 通过反射技术创建对象</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">                <span class="comment">// 将名称和对象存储到容器中</span></span><br><span class="line">                map.put((String) key, coffee);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称获取Coffee对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name：咖啡的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从以上工厂类的代码中可以看到，静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象）的，读取配置文件以及创建对象的代码是写在静态代码块中的，目的就是只需要执行一次，也就是说配置文件只需要加载一次。</p>
<p>最后，我们创建一个测试类来测试一下。相信你能看懂下面的测试代码吧！非常简单。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.config_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 22:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> CoffeeFactory.createCoffee(<span class="string">"american"</span>);</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">latte</span> <span class="operator">=</span> CoffeeFactory.createCoffee(<span class="string">"latte"</span>);</span><br><span class="line">        System.out.println(latte.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类看结果，如下图所示，分别打印了美式咖啡和拿铁咖啡，这说明咱们写的代码是没有任何问题的。</p>
<p><img src="/./assets/1709386963652-a2efa271-7813-4755-b769-e13519e098d1.png" alt="img"></p>
<p>至此，工厂模式+配置文件的这种方式我就给大家讲解完了。</p>
<p>现在，你是不是发现使用工厂模式+配置文件这种方式，扩展性更好啊！而且，它也符合开闭原则，这是因为如果我们此时再定义一个Coffee的子类（例如卡布基诺咖啡）的话，那么工厂类的代码是不需要改变的，我们只需要在配置文件里面再配置一行内容（即卡布基诺咖啡类的全类名）就行了。</p>
<p>最最后，我说一下，<strong>工厂模式+配置文件这种方式在开发中是比较常用的，所以大家需要去重点掌握一下。</strong></p>
<hr>
<h3 id="4-2-3-工厂方法模式"><a href="#4-2-3-工厂方法模式" class="headerlink" title="4.2.3. 工厂方法模式"></a>4.2.3. 工厂方法模式</h3><p>虽然我们使用了简单工厂模式改进了以上点咖啡的案例，但是它依旧存在一个缺点，即违背了开闭原则。如果我们使用工厂方法模式，那么就可以解决这个问题了，因为它完全遵循开闭原则。</p>
<h4 id="4-2-3-1-概念"><a href="#4-2-3-1-概念" class="headerlink" title="4.2.3.1. 概念"></a>4.2.3.1. 概念</h4><p>定义一个用于创建对象的接口（该接口就是工厂，里面并没有具体的去创建某一个产品对象），让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化（也即对象的创建）延迟到其工厂的子类中。</p>
<h4 id="4-2-3-2-结构"><a href="#4-2-3-2-结构" class="headerlink" title="4.2.3.2. 结构"></a>4.2.3.2. 结构</h4><p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它里面并没有创建任何产品对象。调用者通过它访问具体工厂（即抽象工厂的子类）的工厂方法来创建产品</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</li>
</ul>
<p>对于以上工厂方法模式的主要角色，可能有些同学不甚理解，没关系，下面我给大家举个简单的例子来解释一下。</p>
<p>假设现在有一个抽象工厂，而且该抽象工厂有多个子类，即具体工厂，那么每一个具体工厂都会去创建对应的产品对象，比如我们会定义一个工厂专门用于创建美式咖啡，再定义另外一个工厂专门去创建拿铁咖啡。也就是说，具体工厂主要是实现抽象工厂中的抽象方法以完成具体产品的一个创建。</p>
<p>现在大家该理解了抽象工厂和具体工厂这两个角色了吧！</p>
<h4 id="4-2-3-3-实现"><a href="#4-2-3-3-实现" class="headerlink" title="4.2.3.3. 实现"></a>4.2.3.3. 实现</h4><p>经过上面的学习，相信大家对工厂方法模式有了一定的认识。接下来，我们再使用工厂方法模式对以上点咖啡案例进行一个改进，通过该案例，让大家对工厂方法模式有一个更深入的理解。</p>
<p>大家先看一下下面的类图，这是使用工厂方法模式对以上案例进行改进之后设计出来的类图。</p>
<p><img src="/./assets/1709386964332-bee0211a-a30c-4b60-8456-81551fd93787.png" alt="img"></p>
<p>从以上类图中可以看到，右边是咖啡类、美式咖啡类、拿铁咖啡类这三个类，而且它们也是父子类的关系，这和我们之前是一样的，所以我就不再过多的去强调了。中间是咖啡店类，它里面具有一个点咖啡的功能，而且它依赖于抽象（即Coffee），而没有依赖于具体，这就符合我们之前讲过的依赖倒转原则了。左边是一个接口（即CoffeeFactory），也就是抽象工厂，而且它里面有一个抽象的方法（即createCoffee）用于创建咖啡对象，这也就形成一套规范了，那么就要求子类必须去重写了。此外，CoffeeFactory接口下面还有两个子实现类，它们分别是：</p>
<ul>
<li>美式咖啡生产工厂类（即AmericanCoffeeFactory），它是得要去重写父接口中的抽象方法的，很明显它是用来生产具体的美式咖啡的，所以它还得依赖于美式咖啡类</li>
<li>拿铁咖啡工厂类（即LatteCoffeeFactory），它也需要重写父接口中创建咖啡的抽象方法，很明显它是用来生产具体的拿铁咖啡的，所以它还得依赖于拿铁咖啡类</li>
</ul>
<p>分析完以上类图之后，接下来，我们就要开始编写代码来实现了。</p>
<p>首先，在com.meimeixia.pattern.factory包下新建一个子包，即factory_method，使用工厂方法模式实现以上案例的代码我们都放在了该包下。</p>
<p>然后，将咖啡类、美式咖啡类、拿铁咖啡类这三个类从上面拷贝到factory_method包下，因为这三类并不需要进行修改。</p>
<ul>
<li>咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 咖啡类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加糖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加糖"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加奶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加奶"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>美式咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 美式咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"美式咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>拿铁咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拿铁咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"拿铁咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，根据以上类图去创建一个接口，即CoffeeFactory，它属于抽象工厂角色。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CoffeeFactory：抽象工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> {</span><br><span class="line">    <span class="comment">// 创建咖啡对象的方法</span></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建以上CoffeeFactory接口的子实现类。这里我们先创建第一个类，即美式咖啡生产工厂类，记住，该类得实现CoffeeFactory接口并重写它里面的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美式咖啡工厂类，专门用来生产美式咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建第二个类，即拿铁咖啡生产工厂类，同理，该类得实现CoffeeFactory接口并重写它里面的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿铁咖啡工厂类，专门用来生产拿铁咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">=</span><br></pre></td></tr></tbody></table></figure>

<p>不要忘了我们还得去创建一个咖啡店类哟！从以上类图中可以看到，它里面有一个点咖啡的功能，即orderCoffee，该方法与之前有点不一样，它并不需要参数，不需要参数的话，那么它就得根据具体的工厂去获取咖啡对象了。注意，在该方法里面，我们不再需要去创建具体的工厂对象了，而是会从客户端传递进来。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡店</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 21:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory; <span class="comment">// 依赖于抽象（即CoffeeFactory），而没有依赖于具体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(CoffeeFactory factory)</span> {</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点咖啡功能。注意，这儿不再需要创建具体工厂对象了，而是会从客户端传递进来</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个测试类来测试一下。如果我们现在想要点的是拿铁咖啡，那么测试代码就应该写成下面这样。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建咖啡店对象</span></span><br><span class="line">        <span class="type">CoffeeStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeStore</span>();</span><br><span class="line">        <span class="comment">// 创建具体工厂对象</span></span><br><span class="line">        <span class="comment">// CoffeeFactory factory = new AmericanCoffeeFactory();</span></span><br><span class="line">        <span class="type">CoffeeFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LatteCoffeeFactory</span>();</span><br><span class="line">        store.setFactory(factory);</span><br><span class="line">        <span class="comment">// 点咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> store.orderCoffee();</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在很明显，我们在客户端传递的是拿铁咖啡工厂对象，所以应该生产的是拿铁咖啡，那么到底是不是这样呢？运行一下以上测试类便知道了，如下图所示，发现控制台打印了如下内容，我们想点的是拿铁咖啡，结果打印的也是拿铁咖啡，还加奶、加糖了，这说明咱们写的代码是没有任何问题的。</p>
<p><img src="/./assets/1709386964323-691961a3-b9af-4ec5-8016-ffe45accd221.png" alt="img"></p>
<p>如果现在你想点美式咖啡，那么想必你应该知道该怎么做了吧！</p>
<p>此时，大家不妨开动脑筋想一想，使用工厂方法模式有没有解决以上案例中所存在的违背开闭原则的缺点呢？很显然解决了，如果我们想要添加一种新的咖啡的品种的话，那么再定义一个Coffee类的子类即可，而且此时工厂类中的方法都不需要修改，现在只需要再创建一个新的咖啡工厂的子实现类就行了，这样就解决了简单工厂模式的缺点。</p>
<p>总结一下，<strong>工厂方法模式是简单工厂模式的进一步抽象，由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点</strong>。</p>
<hr>
<h4 id="4-2-3-4-优缺点"><a href="#4-2-3-4-优缺点" class="headerlink" title="4.2.3.4. 优缺点"></a>4.2.3.4. 优缺点</h4><p>工厂方法模式有如下优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可以得到所要的产品，无须知道产品的具体创建过程，产品的具体创建过程被封装到了具体的工厂里面</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足了开闭原则，因为我们只是新添加了类，并没有去修改之前类中的代码</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。如果产品类特别特别多，那么就会产生类爆炸现象，也即系统里面的类特别特别多</li>
</ul>
<h4 id="4-2-3-5-工厂方法模式在源码中的体现"><a href="#4-2-3-5-工厂方法模式在源码中的体现" class="headerlink" title="4.2.3.5. 工厂方法模式在源码中的体现"></a>4.2.3.5. 工厂方法模式在源码中的体现</h4><p>在本小节，我们就来看一下在JDK源码中哪个地方用到了工厂方法模式。</p>
<p>这里，我就直接告诉大家吧！其实，单列集合里面获取迭代器的方法，即Collection.iterator，底层用的就是工厂方法模式。</p>
<p>为什么我会这么说呢？我们先来看下面这段代码，相信大家对这段代码是再熟悉不过了，就是使用迭代器遍历集合，并获取集合中的元素。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"令狐冲"</span>);</span><br><span class="line">        list.add(<span class="string">"风清扬"</span>);</span><br><span class="line">        list.add(<span class="string">"任我行"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从以上代码中可以看到，我们首先创建了一个List集合，并向其里面存储了三个元素，然后再通过List集合里面的iterator方法获取到迭代器对象，获取到迭代器对象之后，就可以使用它里面的方法获取集合中的元素了，也即遍历集合。</p>
<p>看到这里，不知大家知不知道单列集合获取迭代器的方法（即Collection.iterator）获取的到底是哪个类的对象呢？相信你之前应该从来没有去关注过这点，不过不知道也没关系，下面我就会为大家揭秘。</p>
<p>其实，单列集合获取迭代器的方法（即Collection.iterator）使用到了工厂方法模式，大家要是忘了的话，不妨再简单地去回顾一下。回顾起来之后，我们再来好好看看下面这张类图。</p>
<p><img src="/./assets/1709386964366-c107963a-740d-497d-9f74-f43648cd2e5b.png" alt="img"></p>
<p>仔细看以上类图，然后再对应一下工厂方法模式里面的角色，你就能知道，Iterator接口表示的是抽象产品这一角色，ArrayList类中的Iter内部类表示的是具体产品这一角色，而且可以很明显地看到它俩是属于实现关系。</p>
<p>接着，我们再来看以上类图的左边部分，有一个Collection接口，它是单列集合顶层接口，它表示的是抽象工厂这一角色。而且，该接口还有一个子实现类，即ArrayList，该类表示的是具体工厂这一角色，从以上类图中也能很明显看出它俩是实现关系。其实，如果你去看源码的话，那么你会发现ArrayList类与Collection接口之间是有很多类的，也即ArrayList类的父类是蛮多的，如下图所示。</p>
<p><img src="/./assets/1709386964401-f0d6b891-9a8b-4c61-9b05-105b95f77081.png" alt="img"></p>
<p>但现在我们并不关注，我们关注的是Collection.iterator方法使用到的工厂方法模式，所以我画的类图是比较简单的，并没有把其它的一些类给画进来。</p>
<p>分析完以上类图之后，大家一定要清楚，根据工厂方法模式的学习，我们是不是应该在具体的工厂类中去创建具体的产品类对象啊？OK，下面我们就走一遭源码，亲眼看看，毕竟事实胜于雄辩。</p>
<p>首先进入Collection接口的源码里面，注意了，它表示的是抽象工厂这一角色，可以看到它里面有一个iterator方法，并且返回值类型是Iterator（接口），而Iterator表示的正是抽象产品这一角色。</p>
<p><img src="/./assets/1709386964486-70b96b89-90df-4429-b0b2-5557c6a1d0eb.png" alt="img"></p>
<p>也就是说，在单列集合顶层接口里面定义了创建Iterator对象的方法，当然了，该方法肯定是一个抽象方法，即它定义的就是一种规范，是要求子类必须实现的。</p>
<p>然后再进入ArrayList类的源码里面，注意看啊，它里面重写了iterator方法，如下图所示。</p>
<p><img src="/./assets/1709386964922-ab05dd55-f028-42e5-83ce-208c967c5b7d.png" alt="img"></p>
<p>上面我也已经说过，我们应该在具体的工厂类中去创建具体的产品类对象，而从以上类图中可知，具体产品类指的就是ArrayList类中的Iter内部类，所以，你才会看到在ArrayList类的已经重写过的iterator方法中new了一个具体的产品类对象，并返回了出去。不知大家看到没有，就在ArrayList类的iterator方法下面，Iter内部类赫然在列，该内部类正实现了Iterator接口，所以，大家看出来了没有，这就是工厂方法模式啊！</p>
<p>最后，我总结一下，如下：</p>
<p><img src="/./assets/1709386964952-9d35a37e-a92a-4aae-8498-74d16ad721fc.png" alt="img"></p>
<p>最最后，我再说一点，在JDK的源码里面有很多地方都用到了工厂方法模式，例如：</p>
<ol>
<li>DateFormat类中的getInstance方法用到了工厂方法模式</li>
<li>Calendar类中的getInstance方法也用到了工厂方法模式</li>
</ol>
<p>不过，在这里我们就不分析了，大家重点把单列集合获取迭代器的方法（即Collection.iterator）使用到的工厂方法模式分析清楚就可以了。</p>
<hr>
<h2 id="4-3-抽象工厂模式"><a href="#4-3-抽象工厂模式" class="headerlink" title="4.3. 抽象工厂模式"></a>4.3. 抽象工厂模式</h2><h3 id="4-3-1-前言"><a href="#4-3-1-前言" class="headerlink" title="4.3.1. 前言"></a>4.3.1. 前言</h3><p>前面介绍的工厂方法模式中考虑的是一类产品，如畜牧场只养动物、电视机厂只生产电视机（不生产空调、冰箱等其它的电器）、计算机学院只培养计算机软件专业的学生等。</p>
<p>这些工厂只生产同种类产品，而同种类产品又被称为同等级产品，也就是说，工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂都是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，苹果代工厂既生产苹果电脑又生产苹果手机或苹果iPad，大学既有软件专业又有生物专业等。</p>
<p>本讲要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。这句话大家可能不是特别好理解，有点绕是不是？但没关系，下面我们来看一张图，相信大家就能很好地理解了。</p>
<p><img src="/./assets/1709435132182-a7b84197-daf8-403d-ae55-d93e82818815.png" alt="img"></p>
<p>上图所示横轴是产品等级，也就是同一类产品，从图中可以看到不管是一体机，还是笔记本，还是台式机，它们都是同一级别的产品，即电脑；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂，例如苹果代工厂既生产苹果电脑又生产苹果手机或苹果iPad，生产出的这些产品就属于同一个产品族。</p>
<p>经过以上分析，相信大家对产品族和产品等级这两个概念有了一定的认识，接下来，我们再来看一张图，以便加深理解。</p>
<p><img src="/./assets/1709435132214-b4c21006-207c-4f00-8750-cb630d4530e1.png" alt="img"></p>
<p>先来看左边部分，这部分的东东都是属于同一个产品族的，里面包含有外套、领带、衬衫、西裤、皮鞋等等这些产品，很明显能感受到这个产品族是属于商务风格的。再来看右边部分，这部分的东东同样属于同一个产品族，里面包含有运动上衣、毛衫、运动裤子、运动鞋等等这些产品，看得出来这个产品族是属于运动风格的。</p>
<p>那么在上面这张图中，如何去体现同级别的产品呢？同级别的产品就是同种类的产品，这点大家要知道哟！</p>
<p>商务风的上衣是上衣，运动风的上衣它也是上衣，所以它们属于同级别的产品。再比如鞋子，皮鞋和运动鞋就属于不同产品族里面的同种类产品。</p>
<p>至此，通过上面两张图我就为大家讲清楚了产品族和产品等级这两个概念，大家好好消化一下。</p>
<p>理解清楚以上概念之后，下面我就要为大家讲解抽象工厂模式了。</p>
<h3 id="4-3-2-概念"><a href="#4-3-2-概念" class="headerlink" title="4.3.2. 概念"></a>4.3.2. 概念</h3><p>抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>这概念真的蛮不好理解的，下面我用自己的话给大家详细解释一下。</p>
<p>先看前半段话，什么意思呢？创建对象肯定是由工厂来创建的，那工厂创建的又是哪些对象呢？一组相关的或者相互依赖的对象。例如，我现在开了一个服装工厂去生产运动风格的服装，那么不管是上衣还是内衣还是裤子还是鞋，这些就构成了一组相关的产品。</p>
<p>再来看后半段话，什么意思呢？我现在的服装工厂生产的是运动风格（运动风格指的就是产品族哟😊）的服装，那么该工厂必然就会有生产上衣、运动鞋等功。当我们访问这样一个工厂时，就可以直接使用它里面的功能去获取对应风格的上衣、内衣、裤子以及鞋了。</p>
<p>最后，我得给大家说一下，抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产同一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<h3 id="4-3-3-结构"><a href="#4-3-3-结构" class="headerlink" title="4.3.3. 结构"></a>4.3.3. 结构</h3><p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品，也就是说，每一个方法生产的是同一个产品族里面的不同级别的产品</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建，也就是说，具体产品还是在具体的工厂里面去创建</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系</li>
</ul>
<p>你会发现以上这些角色和工厂方法模式里面的是一样的，只不过稍微有点区别，主要区别就在于抽象工厂和具体工厂这俩角色上。</p>
<h3 id="4-3-4-实现"><a href="#4-3-4-实现" class="headerlink" title="4.3.4. 实现"></a>4.3.4. 实现</h3><p>刚才我们聊了一下抽象工厂模式的概念，接下来我们便来实现一个案例，再深入的去理解一下抽象工厂模式。</p>
<p>依旧是咖啡店的那个案例，只不过需求有所变化，我们来看一下。</p>
<p>现在咖啡店的业务发生了改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，如果要是按照工厂方法模式，那么需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂类、抹茶慕斯工厂类以及甜点工厂类等，这就很容易发生类爆炸情况了，即类太多了。</p>
<p>我们不妨再分析一下以上这些类的特点，你会发现一个问题，就是拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。</p>
<p>所以这个案例可以使用抽象工厂模式来实现，而且设计出来的类图应该是下面这样子。</p>
<p><img src="/./assets/1709435132215-83dc7095-19cd-449e-b64c-9c05ae835b74.png" alt="img"></p>
<p>先来看以上类图的左边部分，这块是甜点相关类，有甜点类及其子类，即提拉米苏类和抹茶慕斯类，它俩是属于同一个级别的产品；再来看右边部分，这块是咖啡相关类，有咖啡类及其子类，即拿铁咖啡类和美式咖啡类；最后来看下面部分，这块是工厂的一个设计，首先我们设计了一个甜点工厂，它具有生产咖啡与甜点的功能，不过要注意，它是一个抽象工厂（即接口），然后我们为其设计了两个具体工厂（即子实现类），一个是美式风味的甜点工厂，它可以生产美式风味的咖啡和甜点，一个是意大利风味的甜点工厂，它可以生产意大利风味的咖啡和甜点。</p>
<p>经过我们上面这样的一个设计，你会发现美式风味的甜点工厂可以生产抹茶慕斯和美式咖啡这两个产品，意大利风味的甜点工厂可以生产拿铁咖啡和提拉米苏这两个产品。</p>
<p>至此，以上类和类之间的关系我们就已经搞明白了，接下来，我们就要开始编写代码来实现了。</p>
<p>首先，打开咱们的maven工程，在com.meimeixia.pattern.factory包下新建一个子包，即abstract_factory，使用抽象工厂模式实现以上案例的代码我们都放在了该包下。</p>
<p>然后，创建咖啡相关的类。</p>
<ul>
<li>咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 咖啡类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加糖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加糖"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加奶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"加奶"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>美式咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 美式咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:40</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"美式咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>拿铁咖啡类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拿铁咖啡</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-05-31 21:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"拿铁咖啡"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建甜点相关的类。</p>
<ul>
<li>甜点类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 甜点抽象类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-06-01 18:56</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dessert</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>提拉米苏类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提拉米苏类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-06-01 18:59</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trimisu</span> <span class="keyword">extends</span> <span class="title class_">Dessert</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"提拉米苏"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>抹茶慕斯类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抹茶慕斯类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2021-06-01 19:03</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatchMousse</span> <span class="keyword">extends</span> <span class="title class_">Dessert</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"抹茶慕斯"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，抽象产品类和具体产品类我们就已经创建完毕了。接下来，我们就需要创建工厂相关的类了。</p>
<p>首先，创建一个甜点工厂接口，即DessertFactory，也就是抽象工厂角色。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 19:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DessertFactory</span> {</span><br><span class="line">    <span class="comment">// 生产咖啡的功能</span></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产甜品的功能</span></span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建美式风味的甜点工厂类，即AmericanDessertFactory，记住，要让该类去实现甜点工厂接口，并重写它里面的所有抽象方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 美式风味的甜点工厂</span></span><br><span class="line"><span class="comment"> *      生产美式咖啡和抹茶慕斯</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 19:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchMousse</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建意大利风味的甜点工厂类，即ItalyDessertFactory，同理，要让该类去实现甜点工厂接口，并重写它里面的所有抽象方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 意大利风味的甜点工厂</span></span><br><span class="line"><span class="comment"> *      生产拿铁咖啡和提拉米苏甜点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 19:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItalyDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Trimisu</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，以上类图中所涉及到的类我们就全部都创建完毕了。</p>
<p>最后，我们创建一个测试类来测试一下。现在我们想点意大利风味的咖啡、甜点来吃，那么测试代码就应该像下面这样写，很简单，我就不再多说了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.factory.abstract_factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 19:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建的是意大利风味的甜点工厂对象</span></span><br><span class="line">        <span class="type">ItalyDessertFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItalyDessertFactory</span>();</span><br><span class="line">        <span class="comment">// 创建的是美式风味的甜点工厂对象</span></span><br><span class="line">        <span class="comment">// AmericanDessertFactory factory = new AmericanDessertFactory();</span></span><br><span class="line">        <span class="comment">// 获取拿铁咖啡和提拉米苏甜点</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        <span class="type">Dessert</span> <span class="variable">dessert</span> <span class="operator">=</span> factory.createDessert();</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line">        dessert.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类看结果，如下图所示，发现确实打印的是拿铁咖啡和提拉米苏，这说明咱们写的代码是没有任何问题的。</p>
<p><img src="/./assets/1709435132224-6708e164-9e56-4433-9a67-9337d3ac26cf.png" alt="img"></p>
<p>如果要是我们的口味变了，想点美式风味的咖啡、甜点，那么应该怎么办呢？很简单，只须创建美式风味的甜点工厂对象即可，其他代码压根就不需要去修改。</p>
<p>现在，我们就能得出这样一个结论了，使用了抽象工厂模式之后，如果要加同一个产品族的话，那么我们只需要再加一个对应的工厂类即可，而不再需要修改其他的类了，这也符合了软件设计原则里面的开闭原则。</p>
<h3 id="4-3-5-优缺点"><a href="#4-3-5-优缺点" class="headerlink" title="4.3.5. 优缺点"></a>4.3.5. 优缺点</h3><p>抽象工厂模式有如下优缺点：</p>
<ul>
<li>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这是什么意思呢？我给大家简单的去解释一下，就拿以上案例来说，意大利风味的甜点工厂它只生产拿铁咖啡和提拉米苏这样的产品，你如果没有去创建其它的工厂对象的话，那么你就只能点这俩产品，这保证了它俩的一个搭配。如果后期你想换口味了，想点拿铁咖啡和抹茶慕斯，那么对不起，做不到！那么问题是不是就随之产生了啊！</li>
<li>缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。这是什么意思呢？还是拿以上案例来说，现在生产的有两类产品，一类是甜点，一类是咖啡，这时如果我们再添加一类产品，即汉堡，那么你会发现所有的工厂类（包括抽象工厂和具体工厂）的代码都需要进行修改，因为我们需要再加一个方法，即生产汉堡的方法。</li>
</ul>
<h3 id="4-3-6-使用场景"><a href="#4-3-6-使用场景" class="headerlink" title="4.3.6. 使用场景"></a>4.3.6. 使用场景</h3><p>明确了抽象工厂模式的优缺点之后，接下来我们就得知道它的使用场景了。</p>
<p>抽象工厂模式有如下这么几个使用场景：</p>
<ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品，如有人只喜欢穿某一个品牌的衣服和鞋，他只需要去该品牌店里面购买就行了</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。也就是说，客户端并不关注产品实例创建的一些细节性的东西，而是直接通过工厂去获取就行了，因为这些产品是有一个相同的接口的。</li>
</ul>
<p>当然了，同学看到这，还并不是特别明确抽象工厂模式具体的使用场景，这也没关系，下面我会举几个现实中的案例来跟大家说说。</p>
<p>第一个案例——输入法换皮肤。要是大家使用搜狗输入法的话，你会发现一套皮肤，例如觉醒年代主题的一套皮肤，有其logo、背景颜色、背景图片，你要是从默认皮肤换成觉醒年代主题皮肤的话，那么logo、背景颜色、背景图片等等这些是不是都得跟着换啊！而且是一整套一整套的去换。那么这是不是就跟我们上面每次只使用其中的某一族产品是一样的啊！你可以将一套皮肤中的logo、背景颜色、背景图片等等理解成是一个一个的产品。</p>
<p>第二个案例——生成不同操作系统的程序。只要我们的操作系统发生了一个变化，那么其他的对象是不是肯定也要一系列的发生变化呀！</p>
<hr>
<h2 id="4-4-原型模式"><a href="#4-4-原型模式" class="headerlink" title="4.4. 原型模式"></a>4.4. 原型模式</h2><h3 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1. 概述"></a>4.4.1. 概述</h3><p>原型模式就是指用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<p>这段话读起来有点绕，是不是？没有关系，这里我会举二个例子来给大家解释一下。</p>
<p>第一个例子，大家还记得很早以前的一个新闻——克隆羊吧！如果我们要去克隆羊，首先得有一个真实存在的羊，是不是啊，那么真实存在的这个羊就是原型对象，而根据这个原型对象克隆出来和它一模一样的克隆羊就是新对象。</p>
<p>第二个例子，喜欢看电影的朋友，经常会看到电影里面有这样的一些场景，偷天大盗去偷盗一件宝物时，总是会提前打造一件宝物的复制品（或者仿制品），以到达一个偷天换日、神不知鬼不觉的目的。如果大盗要去仿制宝物的话，首先得有一个真品，然后他再根据真品去做一个和真品一模一样的仿制品，那么在这种情景下，原型对象就是真品，复制出来的新对象就是仿制品。</p>
<h3 id="4-4-2-结构"><a href="#4-4-2-结构" class="headerlink" title="4.4.2. 结构"></a>4.4.2. 结构</h3><p>原型模式包含有如下角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的clone方法，该clone方法就是克隆的意思</li>
<li>具体原型类：实现抽象原型类中的clone方法，它是可被复制（克隆）的对象</li>
<li>访问类：使用具体原型类中的clone方法来复制（克隆）新的对象</li>
</ul>
<p>知道原型模式里面包含的具体角色之后，咱们来看一下下面这个类图。</p>
<p><img src="/./assets/1709438946747-a7798f55-1b75-404d-b9e0-7f7391fbd702.png" alt="img"></p>
<p>从以上类图中可以看到，有一个Prototype接口，它就属于抽象原型类，而且它里面还定义有一个clone方法，通过该方法复制出来的就是Prototype接口类型的对象。此外，我们还能看到Prototype接口有一个子实现类，即Realizetype，它就属于具体原型类，从上能看到该子实现类重写了父接口里面的clone方法。最后，我们来看一下访问类，即PrototypeTest，它就是一个测试类，里面有个主方法，主方法里面的测试代码是这样写的：首先创建一个原型对象，因为我们是要根据这个原型对象去创建（或者复制）一个新的对象的，然后调用该原型对象里面的clone方法复制出来一个和原型对象一模一样的新对象。</p>
<h3 id="4-4-3-实现"><a href="#4-4-3-实现" class="headerlink" title="4.4.3. 实现"></a>4.4.3. 实现</h3><p>下面我们就要开始编写代码来实现以上类图所表示的案例了。不过在这之前，大家还得清楚如下概念。</p>
<p>原型模式的克隆分为浅克隆和深克隆：</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本数据类型属性（即引用数据类型属性），仍指向原有属性所指向的对象的内存地址</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址</li>
</ul>
<p>大家初次看到浅克隆和深克隆这两个概念，想必理解的不是很深刻，但是没关系，下面我会通过代码来给大家演示一下。</p>
<p>注意，现在我们所讲述的原型模式指的就是浅克隆。至于深克隆，我等下会给大家进行一个扩展。</p>
<p>此外，我们还应知道一点，在Java里面，Object类提供了<strong>clone方法</strong>来实现浅克隆，注意是浅克隆哟！而且，在Java里面还有一个接口，即<strong>Cloneable接口</strong>，你可以把它理解成原型模式中的抽象原型类，这样，实现了该接口的子实现类就是具体原型类了。所以，等会我们编写代码时，就将以上类图中的Prototype接口换成Cloneable接口，这样做还是有好处的，因为Cloneable接口在Java里面已经定义好了，我们直接拿过来用就行了，而不需要再重复的去定义了。</p>
<p>清楚以上概念之后，接下来，我们就要开始编写代码来实现了。</p>
<p>首先，打开咱们的maven工程，在com.meimeixia.pattern包下新建一个子包，即prototype.demo，使用原型模式实现以上类图所表示的案例的代码我们都放在了该包下。</p>
<p>然后，创建具体原型类，即Realizetype，注意，该类得去实现Cloneable接口并重写它里面的clone方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Realizetype</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"具体的原型对象创建完成！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 克隆出来的，我们明确肯定是该具体原型类的对象，所以我们应把clone方法的返回值类型改成Realizetype</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Realizetype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建访问类，这里我们不妨将其命名为Client。根据以上类图，相信你能写出下面这样的测试代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="comment">// 创建一个原型类对象</span></span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">realizetype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        <span class="comment">// 调用原型类（即Realizetype）中的clone方法进行对象的克隆</span></span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">clone</span> <span class="operator">=</span> realizetype.clone();</span><br><span class="line">        System.out.println(<span class="string">"原型对象和克隆出来的是否是同一个对象呢？"</span> + (realizetype == clone));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后运行以上测试类看结果，如下图所示，打印结果是false，即原型对象和克隆出来的对象不是同一个对象，而且你还能从中发现先是调用了Realizetype类的无参构造方法去创建对象，再是去调用clone方法复制对象，大家注意看哟，在复制对象时，有没有再去执行无参构造方法啊？没有，这说明底层不是通过new对象的方式去克隆一个新对象的，而是通过调用clone方法。</p>
<p><img src="/./assets/1709438946747-35a2b716-3aed-44db-92e6-a91b91a095a9.png" alt="img"></p>
<p>至此，我们就通过以上代码实现了克隆这样一个效果。</p>
<h3 id="4-4-4-案例"><a href="#4-4-4-案例" class="headerlink" title="4.4.4. 案例"></a>4.4.4. 案例</h3><p>接下来，我们通过一个原型模式的案例再来理解一下原型模式以及原型模式里面的浅克隆和深克隆这俩概念。</p>
<p>该案例就是使用原型模式生成三好学生奖状。</p>
<p>同一学校的”三好学生”奖状除了获奖人姓名不同之外，其他的都相同，那么这种情况下，我们就可以使用原型模式复制多个”三好学生”奖状出来，然后再修改奖状上的名字即可。根据分析，我们是不难画出下面这样的类图的。</p>
<p><img src="/./assets/1709438946794-8b0967d0-a489-46a2-b9b6-af7efac5fb6b.png" alt="img"></p>
<p>从以上类图中可以看到，首先有一个抽象原型接口，即Cloneable，该接口并不需要我们去定义，因为在Java里面已经定义好了，我们直接用就可以。该接口的子实现类，即Citation，就是具体原型类，能看到我们还在该类中声明了一个name属性来记录获奖人的姓名，并且为其提供了相应的getter和setter方法，最后还重写了父接口中的clone方法。</p>
<p>大家不要忘了还有一个访问类哟，也就是测试类，测试类中只有一个主方法，主方法里面的测试代码是这样写的：首先创建一个原型对象，然后再调用它里面的clone方法克隆出来多个三好学生奖状。</p>
<p>分析至此，接下来，我们就要开始编写代码来实现以上案例了。</p>
<p>首先，在com.meimeixia.pattern.prototype包下新建一个子包，即test，使用原型模式实现以上案例的代码我们都放在了该包下。</p>
<p>然后，创建三好学生类，即Citation，注意，该类得去实现Cloneable接口并重写它里面的clone方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三好学生上的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 因为克隆出来的肯定是三号学生类的对象，所以我们要将clone方法的返回值类型修改为Citation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(name + <span class="string">"同学：在2021学年第一学期中表现优秀，被评为三好学生。特发此状！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大家注意了，我们在以上类中还提供了一个show方法，这在类图中是没画出来的，之所以提供该方法，是因为等会我们在打印结果时，可以让大家看得更加清楚一点。</p>
<p>接着，创建访问类，这里我们就命名为CitationTest了。像下面这样的测试代码不难写吧！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="comment">// 1. 创建原型对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">citation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        citation.setName(<span class="string">"张三"</span>); <span class="comment">// 假设这张奖状是张三的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 克隆奖状对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">citation1</span> <span class="operator">=</span> citation.clone();</span><br><span class="line">        citation1.setName(<span class="string">"李四"</span>); <span class="comment">// 克隆出来的这张奖状是李四的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用show方法展示奖状</span></span><br><span class="line">        citation.show();</span><br><span class="line">        citation1.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们便要来运行以上访问类看结果了，如下图所示，第一个奖状是张三的，第二个奖状是李四的，打印的结果确实是符合我们的预期。</p>
<p><img src="/./assets/1709438946740-0adb7a2b-c3fd-4e26-b236-df6410804b7b.png" alt="img"></p>
<h3 id="4-4-5-使用场景"><a href="#4-4-5-使用场景" class="headerlink" title="4.4.5. 使用场景"></a>4.4.5. 使用场景</h3><p>我们能在哪些场景下使用原型模式呢？这里，我就直接告诉大家答案了，原型模式的使用场景如下：</p>
<ul>
<li>如果对象的创建非常复杂，那么可以使用原型模式快捷的创建对象，即使用原型对象进行克隆，这样，我们就不需要去关注对象创建的一些细节了。当然，前提是原型对象所属类必须实现Cloneable接口</li>
<li>性能和安全要求比较高。在这种场景下，我们在设计类时不妨让它去实现Cloneable接口，如有需要，则让它去复制或者克隆新的对象，而不是再去new了。而且，在复制对象的过程中，还能按照我们自己的逻辑去创建对应的对象</li>
</ul>
<h3 id="4-4-6-扩展：深克隆"><a href="#4-4-6-扩展：深克隆" class="headerlink" title="4.4.6. 扩展：深克隆"></a>4.4.6. 扩展：深克隆</h3><p>相信通过上面使用原型模式生成三好学生奖状的案例，大家对原型模式理解得更加深刻了。原型模式说到底本质就是克隆，只不过上面我讲述的都是浅克隆，接下来，我就来为大家详细讲一下深克隆。</p>
<p>在正式讲解深克隆之前，首先我们得做一件事情，即将上面的”三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 三好学生上的姓名</span></span><br><span class="line"><span class="comment">    private String name;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public String getName() {</span></span><br><span class="line"><span class="comment">        return name;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public void setName(String name) {</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> {</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 因为克隆出来的肯定是三号学生类的对象，所以我们要将clone方法的返回值类型修改为Citation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">"同学：在2021学年第一学期中表现优秀，被评为三好学生。特发此状！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，Student类的代码就很简单了，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 7:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="comment">// 学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student{"</span> +</span><br><span class="line">        <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，测试类（即CitationTest）中的代码肯定会报错，这是毋庸置疑的，那我们就把之前的测试代码都注释掉，重新编写代码进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 1. 创建原型对象</span></span><br><span class="line"><span class="comment">        Citation citation = new Citation();</span></span><br><span class="line"><span class="comment">        citation.setName("张三"); // 假设这张奖状是张三的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 2. 克隆奖状对象</span></span><br><span class="line"><span class="comment">        Citation citation1 = citation.clone();</span></span><br><span class="line"><span class="comment">        citation1.setName("李四"); // 克隆出来的这张奖状是李四的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 3. 调用show方法展示奖状</span></span><br><span class="line"><span class="comment">        citation.show();</span></span><br><span class="line"><span class="comment">        citation1.show();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建原型对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">citation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="comment">// 创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu.setName(<span class="string">"张三"</span>);</span><br><span class="line">        citation.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 克隆奖状对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">citation1</span> <span class="operator">=</span> citation.clone();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> citation1.getStu();</span><br><span class="line">        stu1.setName(<span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用show方法展示</span></span><br><span class="line">        citation.show();</span><br><span class="line">        citation1.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们是不是通过浅克隆克隆出来了一个奖状对象啊？那么问题来了，大家觉得在浅克隆的过程中，能不能也把学生对象给克隆出来呢？肯定是能够的，要是有同学觉得不能够，那请你再好好看看浅克隆的概念。从以上代码中可以看到，奖状对象克隆出来之后，我们是将奖状中学生的姓名改成李四了。</p>
<p>不妨运行一下以上测试类，如下图所示，可以看到两个奖状打印的学生的姓名都是李四。</p>
<p><img src="/./assets/1709438946888-0ac47361-c1bd-4705-b851-441b0e51b1b5.png" alt="img"></p>
<p>明明我们将new出来的奖状中的学生姓名设置为了张三，为什么最后打印出来的学生姓名却是李四呢？这就是浅克隆所存在的问题，详细点说就是，由于stu对象和stu1对象是同一个对象，所以将stu1对象中name属性值改为”李四”的话，那么两个Citation（奖状）对象中显示的学生姓名都将会是李四。</p>
<p>这就是浅克隆的效果，对具体原型类（即Citation）中的引用类型的属性进行引用的复制。</p>
<p>讲到这里，大家有必要再去回顾一下上面讲的浅克隆和深克隆的概念。回顾完之后，想必大家觉得这时候用深克隆会更好些，是不是啊？接下来，我们就来使用深克隆去解决浅克隆所存在的问题。如果大家要进行深克隆的话，那么在这里我给大家提供一种方案，即使用对象流去操作。</p>
<p>首先，在com.meimeixia.pattern.prototype包下新建一个子包，即test1，使用深克隆解决浅克隆所存在的问题的代码我们都放在了该包下。</p>
<p>然后，将以上test包中的类全部拷贝一份到test1包下，这主要是为了方便，因为我们将在此基础上进行修改。</p>
<p><strong>使用序列化实现深克隆</strong></p>
<p>上面讲过，深克隆我们是使用对象流来操作的，也就是把奖状对象直接写到文件中，或者说序列化到硬盘上，这样，我们在多次读取奖状对象时读取到的就是不同的对象了，当然了，奖状对象里面的学生对象也会是不同的对象。</p>
<p>正是由于我们现在要把Citation类的对象序列化到文件里面，所以就要求该类必须去实现序列化接口了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Serializable {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*// 三好学生上的姓名</span></span><br><span class="line"><span class="comment">    private String name;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public String getName() {</span></span><br><span class="line"><span class="comment">        return name;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public void setName(String name) {</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> {</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而且，大家不要忘了，以上Citation类中还有一个Student类型的属性，这样当我们在去序列化Citation类的对象时，是不是意味着Student类型的对象也要被序列化到文件中啊？所以，Student类也需要实现序列化接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 7:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="comment">// 学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student{"</span> +</span><br><span class="line">        <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，回到测试类里面进行修改，按照上面的分析，相信你不难写出下面这样的测试代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.prototype.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 6:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1. 创建原型对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">citation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="comment">// 创建张三学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu.setName(<span class="string">"张三"</span>);</span><br><span class="line">        citation.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象输出流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"D:/robin/a.txt"</span>));</span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        oos.writeObject(citation);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:/robin/a.txt"</span>));</span><br><span class="line">        <span class="comment">// 读取对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">citation1</span> <span class="operator">=</span> (Citation) ois.readObject();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将克隆出来的奖状中的学生姓名改为李四</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> citation1.getStu();</span><br><span class="line">        stu1.setName(<span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时，原先的奖状中的学生姓名也会随之改为李四吗？</span></span><br><span class="line">        citation.show();</span><br><span class="line">        citation1.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上测试类，打印结果如下图所示，发现确实达到了我们所想要的效果，原先的奖状上展示出来的学生姓名是张三，而通过序列化以及反序列化的方式克隆出来的奖状上展示的学生姓名是李四，这就是深克隆的效果。</p>
<p><img src="/./assets/1709438947320-1c400045-0bca-40f0-b05a-d89084d687e8.png" alt="img"></p>
<p>至此，原型模式我就给大家全部讲完了，尤其是大家一定要弄清楚浅克隆和深克隆，这个很重要。</p>
<hr>
<h2 id="4-5-建造者模式"><a href="#4-5-建造者模式" class="headerlink" title="4.5. 建造者模式"></a>4.5. 建造者模式</h2><h3 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1. 概述"></a>4.5.1. 概述</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">建造者模式</a>是指将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>读完这句话之后，我估计很多人都已经懵了，这说的是什么意思啊？哈哈哈😊，别急，下面我会给大家解释一下，先看一下下面这张图。</p>
<p><img src="/./assets/1709439941254-4eec125f-0218-4fb7-87b8-7b959ce338aa.png" alt="img"></p>
<p>上图右边是一个主机，而左边则是主机里面包含的部件（或者组件），有主板、cpu、内存条、风扇、硬盘以及电源。</p>
<p>结合这张图，我来向大家解释一下建造者模式的概念。建造者模式的概念中不是有一个复杂对象吗？你可以将其理解为上图中的主机。为什么把它称为复杂对象呢？因为主机里面是包含了很多很多部件的。其实，建造者模式说的就是将主机和主机里面的部件进行了一个分离，分离之后有什么好处呢？解除耦合呗！另外，你可以把上图中的那些组件装配成一个主机的过程理解为建造者模式概念中的构建过程。</p>
<p>而同样的构建过程，也即不同的装配方式，最终创建出来的复杂对象（即主机）是不同的。这个如何去理解呢？例如，我现在主板、cpu、内存条都换了一个品牌，那么这时同样的一个装配过程最终出来的主机肯定和之前的是不一样的，你想啊，我现在的内存条选择的是16G，之前有可能选择的是8G，那现在装配的主机肯定和之前的是不一样的啊！</p>
<p>经过我上面的解释，相信大家一定理解了建造者模式。下面，我们再来看一下有关建造者模式的具体的描述。</p>
<ul>
<li>建造者模式分离了部件的构造（由Builder来负责构造，Builder是建造者模式中的一个角色）和装配（由Director负责装配，Director也是建造者模式中的一个角色），从而就可以构造出复杂的对象了，而且我们使用建造者模式最终要的就是这个复杂对象。这个模式适用于某个对象的构建过程复杂的情况，若是这种情况，则可以使用建造者模式</li>
<li>由于实现了构建和装配的解耦，不同的构建器，相同的装配，也可以做出不同的对象，就拿我上面举的例子来说，如果构成主机组件的品牌发生了变化，那么以同样的方式进行组装，出来的肯定是不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，这样就实现了更好的复用</li>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。这就跟我们去买一台电脑一样，我们不关注这台电脑里面用的每个品牌的组件以及它是如何进行装配的，我们只关注最终买的是一台电脑就行了</li>
</ul>
<p>相信读到这，大家对建造者模式又有了一个深刻的认识。</p>
<hr>
<h3 id="4-5-2-结构"><a href="#4-5-2-结构" class="headerlink" title="4.5.2. 结构"></a>4.5.2. 结构</h3><p>建造者（Builder）模式包含有如下角色：</p>
<ul>
<li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建，而是由具体建造者类来实现。注意了，这里说的接口并不是我们通常在Java里面定义的接口，而是指的是一种规范，既可以是Java里面的接口，又可以是抽象类，希望大家能明白这点~</li>
<li>具体建造者类（ConcreteBuilder）：实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。注意了，建造者模式的核心思想并不在于复杂对象各个部件的创建，而是强调的是整个装配的过程，至于对于这些部件的创建，我们既可以使用工厂方法模式，又可以使用抽象工厂模式</li>
<li>产品类（Product）：要创建的复杂对象</li>
<li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指挥者中不涉及具体产品的信息，它只负责保证对象各个部分完整创建或按某种顺序创建。也就是说，指挥者所要完成的工作就是装配复杂对象。举个例子，小妹需要一台电脑来学Java，她想要我帮她组装一台电脑，在组装电脑的过程中，我是不管cpu是什么牌子的，至于这个cpu是怎么去构建的，究竟是小妹自己买的还是自己造的，我也通通不管，我就只负责装配，很显然这里指挥者类就是指我本人</li>
</ul>
<p>了解了建造者模式里面包含的角色之后，接下来我们便来看一下下面的类图，根据以下类图我会再为大家讲解一下建造者模式。</p>
<p><img src="/./assets/1709439941492-f7343827-64f7-45a5-b3ee-17059943aee0.png" alt="img"></p>
<p>从以上类图中可以看到，在抽象建造者类里面构建了各个部分，比如buildPartA方法来构建A部分，buildPartB方法来构建B部分，而且这些方法都是抽象的，需要由具体的建造者去实现，也即构建具体的部件；再来看一下指挥者类，注意看，它是将Builder聚合进来了，而且在construct这个组装方法里面，还会将各个部件组装成一个复杂对象哟；最后看一下具体建造者类，它除了要重写抽象建造者类里面的抽象方法之外，还提供了一个获取复杂对象的方法，即getResult，调用该方法我们就可以获取到复杂对象。</p>
<p>以上类图分析完了之后，接下来我们就通过一个案例再去深入地理解一下建造者模式，而这个案例就是创建共享单车，也就是生产自行车。</p>
<h3 id="4-5-3-案例"><a href="#4-5-3-案例" class="headerlink" title="4.5.3. 案例"></a>4.5.3. 案例</h3><p>生产自行车是一个复杂的过程，它包含了车架、车座等组件的生产。而车架又有碳纤维、铝合金等材质，车座有橡胶、真皮等材质。这样，对于自行车的生产，我们就可以使用建造者模式了，因为生产的是自行车这个复杂对象。</p>
<p>很明显，对于该案例而言，自行车就是一个复杂对象，因为它里面包含有很多组件，而现在的组件只有车架和车座，但是肯定还有其他的一些组件，例如轮胎、轮毂等等，只不过在该案例里面我们就不进行模拟了，而只是通过车架和车座这两个组件来简单的模拟一下就可以了。</p>
<p>下面我们就来分析一下该案例里面要涉及到哪些类。</p>
<ul>
<li>产品类：Bike类，包括了车架、车座等组件。注意了，在该案例中，我为了简单，就不再将车架和车座单独设计成对应的类了，而是直接以字符串的形式体现出来</li>
<li>抽象建造者类：Builder类，在该案例中，我是将其设计成了抽象类</li>
<li>具体建造者类：抽象建造者类的子实现类，在该案例中，我设计出来了两个子实现类，分别是MobileBuilder（用来构建摩拜单车）和OfoBuilder（用来构建ofo单车）</li>
<li>指挥者类：Director类，它是用来装配自行车的</li>
</ul>
<p>明确了该案例里面所涉及到的类之后，你能不能画出下面这样一个类图呢？要是画不出来，就看下面这张类图吧！也不碍事。</p>
<p><img src="/./assets/1709439941272-044c9da4-cd14-4d20-a4c7-32d0a90a7b8c.png" alt="img"></p>
<p>先来看第一个类吧，即Client（客户端），它是需要依赖于其他类的，我们先暂时不去关注它。</p>
<p>再来看一下Bike类（即产品类），可以看到它里面声明了表示车架和车座这俩组件的属性，不过这儿我们直接是以字符串的形式体现出来了，并且还为其提供了对应的setter和getter方法。</p>
<p>看完产品类之后，我们再来看一下Builder类，可以看到它里面声明了一个Bike类型的变量，这就相当于是聚合了Bike类型的对象，此外，它里面还提供了三个抽象方法，一个buildFrame方法用于构建车架，一个buildSeat方法用于构建车座，一个createBike方法用于创建自行车，正是由于该方法是用于创建自行车的，所以该方法的返回值的类型是Bike。大家一定要注意了，由于Builder类是抽象建造者类（这里我将其设计成了抽象类），所以它里面提供的三个方法都是抽象方法。</p>
<p>正是由于Builder类是抽象建造者类，所以我们还要提供对应的具体建造者类，从以上类图中可以看到，这儿我们提供了两个具体建造者类，分别是MobileBuilder和OfoBuilder，它俩肯定是要重写父类中的三个抽象方法的。</p>
<p>最后，大家千万不要忘了最重要的一个类，即Director，它聚合了Builder类，因为它得通过Builder类去构建具体的自行车，而且通过该类中的construct方法，我们还可以去控制自行车组装的一个过程，因为该方法就是用于组装自行车的。此外，在该类里面我们还提供了一个有参构造，这样，该类就没有无参构造了。</p>
<p>以上类图我就为大家分析至此了，接下来，我们就要编写代码来实现以上生产自行车的案例了。</p>
<p>首先，打开咱们的maven工程，在com.meimeixia.pattern包下新建一个子包，即builder.demo1，实现以上生产自行车案例的代码我们都放在了该包下。</p>
<p>然后，创建产品类，即Bike。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-02 21:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> {</span><br><span class="line">    <span class="keyword">private</span> String frame; <span class="comment">// 车架</span></span><br><span class="line">    <span class="keyword">private</span> String seat; <span class="comment">// 车座</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrame</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrame</span><span class="params">(String frame)</span> {</span><br><span class="line">        <span class="built_in">this</span>.frame = frame;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeat</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeat</span><span class="params">(String seat)</span> {</span><br><span class="line">        <span class="built_in">this</span>.seat = seat;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建抽象建造者类，即Builder。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 5:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Bike类型的变量，并进行赋值</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建自行车的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从以上代码中可以看到，我们是在Builder类中声明了一个Bike类型的变量，并为其进行了赋值，这是为啥呢？其实从以上类图中我们也知道应该这么做，它说得很明白了，Builder类是要聚合Bike类型的对象的。</p>
<p>其二，是因为这样做可以提高代码的一个复用性，为什么这么说呢？还是看一下以上类图，你会发现我们得在具体建造者类（比如MobileBuilder和OfoBuilder）里面构建自行车，既然这样，那么它里面就得有一个自行车了，所以我们就把声明一个Bike类型变量这件事放在父类（即抽象建造者类）中来做了，这样做的话，就可以提高代码的一个复用性了。</p>
<p>此外，大家还要注意一点，在为Bike类型的变量赋值时，我们是new了一个Bike类型的对象，而我想要告诉大家的是，该对象里面的组件（车架和车座）还并未组装，就跟我们组装一台主机一样，现在是只有一个机箱。如果要想给该对象组装组件，那么这件事就得交给具体的指挥者去做了。</p>
<p>紧接着，创建具体建造者类。第一个类是MobileBuilder，它得继承以上Builder类并重写里面所有的抽象方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的构建者，用来构建摩拜单车对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 5:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建车架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> {</span><br><span class="line">        bike.setFrame(<span class="string">"碳钎维"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建车座</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> {</span><br><span class="line">        bike.setSeat(<span class="string">"真皮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> bike;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第二个类是OfoBuilder，同样，它也得继承以上Builder类并重写里面所有的抽象方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ofo单车构建者，用来构建ofo单车</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 5:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OfoBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建车架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> {</span><br><span class="line">        bike.setFrame(<span class="string">"铝合金"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建车座</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> {</span><br><span class="line">        bike.setFrame(<span class="string">"橡胶"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> bike;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>具体建造者类创建完毕之后，接下来，我们来创建指挥者类，即Director。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 5:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> {</span><br><span class="line">    <span class="comment">// 声明Builder类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder; <span class="comment">// 在去创建Director对象的时候再为其赋值，所以在Director类里面我们得提供一个有参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装自行车的功能</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">        builder.buildFrame();</span><br><span class="line">        builder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> builder.createBike();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，编写一个测试类来进行测试，测试类的名称我们不妨就叫做Client。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 5:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建指挥者对象，此刻我们要生产的是摩拜单车，所以在Director类的有参构造中我们传入的是MobileBuilder对象</span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(<span class="keyword">new</span> <span class="title class_">MobileBuilder</span>());</span><br><span class="line">        <span class="comment">// 让指挥者指挥组装自行车</span></span><br><span class="line">        <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> director.construct();</span><br><span class="line"></span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类，打印结果如下，这说明咱们的摩拜单车已经组装好了。</p>
<p><img src="/./assets/1709439941238-7825a3d9-2c5e-4dd4-8af6-f6a47627076c.png" alt="img"></p>
<p>从上可以看到，对于客户端来说，它并不需要去关注底层实现，即复杂对象（Bike对象）的构建过程以及构建算法，而是直接调用指挥者类中的功能就可以构建出一个复杂对象了，继而客户端就能使用该复杂对象了。</p>
<p>这里，我还得给大家说一个注意事项，就是上面示例是Builder模式的常规用法，指挥者类 （即Director）在建造者模式中具有很重要的作用，它用于指导具体建造者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，比如说，对于上面示例而言，整个的系统结构还是比较复杂的，这样，对于程序员的要求是比较高的，所以我们可以去做简化，怎么去简化呢？这里我们可以这样去做，即把指挥者类和抽象建造者类进行结合，也就是说我们把指挥者类中的功能都给它加到抽象建造者类中，也即我们就不再需要指挥者类了。</p>
<p>来看下面这段代码，它就是抽象建造者类，和上面我们创建的几乎一模一样，只不过是给它里面多加了一个组装自行车的功能，这样，就不需要具体的指挥者类了，这也算是建造者模式的一种改进吧！对于这种改进，我就不编写具体的代码来进行演示了，大家如果有兴趣的话，不妨自己尝试着去做一下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.buildFrame();</span><br><span class="line">        <span class="built_in">this</span>.BuildSeat();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.createBike();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过，大家还得注意一点，就是这样做确实是简化了系统结构，但同时也加重了抽象建造者类的职责（不光要构建组件，还要进行组装，所以任务还是比较多的），也不是太符合单一职责原则，如果construct方法过于复杂，那么建议还是封装到Director类中。</p>
<hr>
<h3 id="4-5-4-优缺点"><a href="#4-5-4-优缺点" class="headerlink" title="4.5.4. 优缺点"></a>4.5.4. 优缺点</h3><p>通过以上案例，相信大家对于建造者模式的理解应该更加深刻了。接下来，我们便来探讨一下建造者模式的优缺点。</p>
<h4 id="4-5-4-1-优点"><a href="#4-5-4-1-优点" class="headerlink" title="4.5.4.1. 优点"></a>4.5.4.1. 优点</h4><p>第一个，建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p>
<p>这段话怎么去理解呢？产品类和建造者类一般而言是比较稳定的，唯一发生变化的就是指挥者类中组装的那个过程，如果它经常发生变化，那么我们只需要去修改指挥者类里面的代码就可以了。</p>
<p>第二个，在建造者模式中，客户端不必知道产品内部组成的细节，直接调用指挥者类里面的组装方法就可以组装一个产品出来，这样就将产品本身与产品的创建过程解耦了，使得相同的创建过程可以创建不同的产品对象。其实这个我也一直在强调，组装过程一样，如果需要的组件发生了变化，那么生产出来的产品肯定是不一样的。</p>
<p>第三个，可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p>从以上案例中你就能清晰地知道，我们确实是将复杂对象的创建步骤分解在不同的方法里面了，你要是不信的话，不妨再看一下Builder类的代码，你会发现它里面的buildFrame和buildSeat这俩方法创建的都是不同的组件。最终，客户端就会调用指挥者类中的组装方法进行一个组装，便生成了一个复杂对象。</p>
<p>第四个，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成（如果以上例为例，我现在要生产另外一个品牌的单车，那么我只需要再去创建一个新的建造者类就可以了），基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险了，这也符合了开闭原则。</p>
<h4 id="4-5-4-2-缺点"><a href="#4-5-4-2-缺点" class="headerlink" title="4.5.4.2. 缺点"></a>4.5.4.2. 缺点</h4><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，若产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到了一定的限制。</p>
<p>就拿上例来说，该案例生产的是自行车，如果现在要去生产一台电脑的话，那么此情此景下肯定是不适合使用建造者模式的，因为组装产品的组件都不一样。当然，虽说以上案例中生产的是自行车，但是我们可以再对其进行一个抽象（即抽取共有的），然后再去创建不同的子类，不过，我们在这里面并没有这样去做。</p>
<hr>
<h3 id="4-5-5-使用场景"><a href="#4-5-5-使用场景" class="headerlink" title="4.5.5. 使用场景"></a>4.5.5. 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示（即最终创建出来的复杂对象）是独立的，也就是说复杂对象装配的算法和其里面的组件是分离的</li>
</ul>
<p>根据以上两条法则，大家就可以去判断什么样的场景下适合使用建造者模式了。</p>
<h3 id="4-5-6-扩展-简化构造方法"><a href="#4-5-6-扩展-简化构造方法" class="headerlink" title="4.5.6. 扩展-简化构造方法"></a>4.5.6. 扩展-简化构造方法</h3><p>在这一小节，我们对建造者模式进行一个扩展。</p>
<p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性就会非常差，而且还很容易引入错误，那么此时就可以利用建造者模式进行重构了。</p>
<p>我们先不管利用建造者模式进行重构这件事，而是先来看一下最原始的设计方式，就拿我们现在要设计一个手机类来说事，手机里面是有很多组件的，例如cpu、屏幕、内存、主板等等，这样，当我们去创建一个手机对象时，肯定是要设置这些组件的数据的。不难想到在设计手机类时，我们应该提供了一个有参构造方法，而且方法里面的参数应有cpu、屏幕、内存以及主板等。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScreen</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span> {</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(String memory)</span> {</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMainboard</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMainboard</span><span class="params">(String mainboard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone{"</span> +</span><br><span class="line">        <span class="string">"cpu='"</span> + cpu + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", screen='"</span> + screen + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", memory='"</span> + memory + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", mainboard='"</span> + mainboard + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上Phone类的代码还是比较简单的，下面我们主要来看一下客户端的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 构建Phone对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">"intel"</span>, <span class="string">"三星屏幕"</span>, <span class="string">"金士顿"</span>, <span class="string">"华硕"</span>);</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大家看清楚在构建手机对象时所需要传入的参数了吧！现在还只是需要传入四个参数，如果需要传递更多的参数，那么你会发现写出来的代码的可读性将会非常差，并且使用成本也会比较高。所以，在这种情况下，我们就可以选择使用建造者模式对其进行重构了。那如何做到这一点呢，下面我就会讲到。</p>
<p>首先，在com.meimeixia.pattern.builder包下新建一个子包，即demo2，使用建造者模式进行重构的代码我们都放在了该包下。</p>
<p>然后，创建一个手机类，即Phone。由于该类的创建比较复杂，所以下面我会分步骤来为大家进行讲解。</p>
<p>第一步，在该手机类里面提供四个成员变量，分别用以表示cpu、屏幕、内存、主板等手机组件。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 6:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第二步，由于我们现在是使用建造者模式来进行重构，所以就不能让外界直接调用Phone类的构造方法了，也就是说我们应该私有Phone类的构造方法。那么构造方法里面需不需要传递什么参数呢？需要，需要传递一个构建器。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 6:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> { <span class="comment">// 构造方法里面需要传入一个构建器</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第三步，定义Builder构建器。在哪定义呢？就在Phone类中定义一个静态的内部类，Builder内部类定义完毕之后，我们还得在它里面提供四个成员变量，分别用以表示cpu、屏幕、内存、主板等手机组件，并且还要提供对应的方法进行这些组件的构建哟！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 6:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> { <span class="comment">// 构造方法里面需要传入一个构建器</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大家可以看到，方法名是和以上成员变量（或者属性）的名称保持一致的，并且方法最终返回的就是咱们的Builder</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cpu</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String cpu)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu; <span class="comment">// 把方法中的参数设置给成员变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 因为方法的返回值类型是Builder，所以我们得返回一个Builder对象，这样，不妨直接返回当前对象就哦了</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String screen)</span> {</span><br><span class="line">            <span class="built_in">this</span>.screen = screen;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String memory)</span> {</span><br><span class="line">            <span class="built_in">this</span>.memory = memory;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String mainboard)</span> {</span><br><span class="line">            <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第四步，完善Phone类中的构造方法，即把构建者对象中的成员变量直接赋给Phone类中的成员变量。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 6:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> { <span class="comment">// 构造方法里面需要传入一个构建器</span></span><br><span class="line">        <span class="built_in">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = builder.screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = builder.memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = builder.mainboard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大家可以看到，方法名是和以上成员变量（或者属性）的名称保持一致的，并且方法最终返回的就是咱们的Builder</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cpu</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String cpu)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu; <span class="comment">// 把方法中的参数设置给成员变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 因为方法的返回值类型是Builder，所以我们得返回一个Builder对象，这样，不妨直接返回当前对象就哦了</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String screen)</span> {</span><br><span class="line">            <span class="built_in">this</span>.screen = screen;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String memory)</span> {</span><br><span class="line">            <span class="built_in">this</span>.memory = memory;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String mainboard)</span> {</span><br><span class="line">            <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第五步，由于Phone类中的构造方法私有了，所以外界是不能直接调用Phone类的构造方法去创建Phone对象的。既然这样，那么我们只能使用Builder内部类去构建Phone对象了。因此，我们还得在Builder内部类里面定义一个创建Phone对象的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-03 6:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> { <span class="comment">// 构造方法里面需要传入一个构建器</span></span><br><span class="line">        <span class="built_in">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = builder.screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = builder.memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = builder.mainboard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大家可以看到，方法名是和以上成员变量（或者属性）的名称保持一致的，并且方法最终返回的就是咱们的Builder</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cpu</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String cpu)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu; <span class="comment">// 把方法中的参数设置给成员变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 因为方法的返回值类型是Builder，所以我们得返回一个Builder对象，这样，不妨直接返回当前对象就哦了</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String screen)</span> {</span><br><span class="line">            <span class="built_in">this</span>.screen = screen;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String memory)</span> {</span><br><span class="line">            <span class="built_in">this</span>.memory = memory;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String mainboard)</span> {</span><br><span class="line">            <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构建者创建Phone对象</span></span><br><span class="line">        <span class="keyword">public</span> Phone <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">            <span class="comment">// 在内部类中是可以直接去访问外部类中私有的方法的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="built_in">this</span>); <span class="comment">// 记住，我们要把当前对象（即this）给其传递过去，因为Phone类</span></span><br><span class="line">            <span class="comment">// 中只提供了一个构造方法，而且方法参数要的还是Builder对象</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone{"</span> +</span><br><span class="line">        <span class="string">"cpu='"</span> + cpu + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", screen='"</span> + screen + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", memory='"</span> + memory + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", mainboard='"</span> + mainboard + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，在Phone类中千万不要忘了重写toString方法哟，因为待会我们测试的时候便会用到。</p>
<p>至此，Phone类才算是创建完毕了。</p>
<p>创建完毕之后，接下来，我们就得创建一个测试类来进行测试了，在该测试类中我们如何去创建一个Phone对象呢？现在我们是不能直接去创建Phone对象的，而只能是通过Builder内部类来创建，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.builder.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 16:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建手机对象   通过构建者对象获取手机对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>.Builder()</span><br><span class="line">        .cpu(<span class="string">"intel"</span>) <span class="comment">// 由于cpu、screen等这些方法返回的都是当前对象，所以我们就可以使用链式编程了</span></span><br><span class="line">        .screen(<span class="string">"三星屏幕"</span>)</span><br><span class="line">        .memory(<span class="string">"金士顿内存条"</span>)</span><br><span class="line">        .mainboard(<span class="string">"华硕主板"</span>)</span><br><span class="line">        .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上测试类，可以看到打印结果如下，Phone对象确实是创建成功了，并且还为它里面的组件进行了赋值。</p>
<p><img src="/./assets/1709439941251-eba519e6-a312-4794-8b64-189c22cc474a.png" alt="img"></p>
<p>以上就是建造者模式的另外一种用法。这种做法和我们之前的原始方式有什么区别呢？</p>
<ul>
<li>第一个区别：构建哪个组件，我们是一目了然的。例如调用cpu方法，我们就知道要进行组装的就是cpu</li>
<li>第二个区别：对于原始的建造者模式来说，组件的构建顺序是由指挥者类来定夺的，而现在是把组件的构建顺序交给了客户，客户想怎么去构建，就按照他的顺序去构建就行了</li>
</ul>
<p>最后，我得多说一嘴，就是重构后的代码使用起来更方便，某种程度上也可以提高开发效率，因为我们可以链式编程了，而且代码的可读性比我们之前的程序更高了。此外，从软件设计上来说，对程序员的要求就比较高了，因为你能明显看到我们在设计以上Phone类时，比我们之前设计的要复杂太多，但是用起来很方便，嘿嘿！</p>
<hr>
<h2 id="4-6-创建型模式各个模式的对比"><a href="#4-6-创建型模式各个模式的对比" class="headerlink" title="4.6. 创建型模式各个模式的对比"></a>4.6. 创建型模式各个模式的对比</h2><p>建造者模式讲完了之后，创建型模式我们就已经全部讲解完毕了。想必大家都知道创建型模式总共包含了五个设计模式，它们分别是：</p>
<ol>
<li>单例设计模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ol>
<p>相信大家对于单例设计模式和原型模式应该不会混淆，但是对于其他的一些设计模式或许就会搞混了，因为它们在使用上面还是比较相似的。不知你在学习这些设计模式时，心中是否有一个小小的疑问，那就是它们好像在做同一件事耶！</p>
<p>所以，在这一小节，我有必要专门花些时间对工厂方法模式、抽象工厂模式以及建造者模式做一个对比说明。下面我们先来说一下工厂方法模式和建造者模式的一个区别。</p>
<h3 id="4-6-1-工厂方法模式-VS-建造者模式"><a href="#4-6-1-工厂方法模式-VS-建造者模式" class="headerlink" title="4.6.1. 工厂方法模式 VS 建造者模式"></a>4.6.1. 工厂方法模式 VS 建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p>
<p>我们举个简单例子来说明两者的差异，现在要制造一个超人，如果使用工厂方法模式，那么直接生产出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而若使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p>
<p>所以，工厂方法模式和建造者模式这两者的侧重点是不一样的，工厂方法模式侧重的是整体对象的创建，而建造者模式侧重的是部件构建的过程，你只要牢牢记住这一点就行了。</p>
<h3 id="4-6-2-抽象工厂模式-VS-建造者模式"><a href="#4-6-2-抽象工厂模式-VS-建造者模式" class="headerlink" title="4.6.2. 抽象工厂模式 VS 建造者模式"></a>4.6.2. 抽象工厂模式 VS 建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产就可以了。</p>
<p>举个例子来说，现在我要去组装一台计算机，那么计算机里面得有这么一些组件，如主板、硬盘、内存条、电源以及cpu等等，这些组件就可以理解成是一个产品家族，而抽象工厂模式就是用来生产这些产品家族里面的产品的。</p>
<p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。这样的话，你会发现，我们可以把抽象工厂模式和建造者模式整合到一块来设计汽车的生产过程，因为汽车配件可以使用抽象工厂模式来生产，而汽车的组装可以使用建造者模式来进行组装，如此就可形成一个完整的系统了。</p>
<p>所以，大家一定要注意了，我们以后真正去用设计模式的话，并不意味着只在某一种情况下只用一种设计模式，而更有可能是多种设计模式混合到一块去使用。</p>
<hr>
<hr>
<h1 id="5-结构型模式"><a href="#5-结构型模式" class="headerlink" title="5. 结构型模式"></a>5. 结构型模式</h1><p>从本讲开始，我们就进入到第三章内容的学习中了，而第三章内容讲的就是结构型模式，所以我们有必要知道什么是结构型模式。</p>
<p>什么是结构型模式呢？结构型模式描述如何将类或对象按某种布局组成更大的结构（可知，结构型模式强调的就是这个结构）。它分为类结构型模式和对象结构型模式，前者采用继承机制（或者实现机制）来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%80%A6%E5%90%88%E5%BA%A6&amp;spm=1001.2101.3001.7020">耦合度</a>低，满足”合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>知道了什么是结构型模式之后，接下来我们来看一下结构型模式总共可分为哪几种，如下所示，结构型模式分为以下7种：</p>
<ol>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ol>
<p>关于以上这7种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>，在后续的学习中，我都会为大家一一地进行详细介绍。而在本讲中，我会先为大家介绍第一种设计模式，即代理模式。</p>
<hr>
<h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1. 代理模式"></a>5.1. 代理模式</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1. 概述"></a>5.1.1. 概述</h3><p>什么是代理模式呢？这是我们必须要知道的。</p>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问，这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>以上这段话读完之后，你有什么感想啊？感觉好像字都认识，但连在一起就不知道是什么意思了，是不是啊！没关系，我会举几个现实生活中的例子为大家解释一下。例如，你现在有钱了，想要去买房，这时一般而言你是不可能直接去找到真正的房屋房主的，而是应该去找房屋中介，由房屋中介在中间进行一个牵线，那么这就是所谓的代理模式。再来举一个例子，你想要去买电脑，你总不可能直接去找对应的电脑厂商吧！而是应该去找对应的代理商，就如下图所示的一样。</p>
<p><img src="/./assets/1709441899058-8ca9ab8c-4611-42c3-868d-f69e1a010d4b.png" alt="img"></p>
<p>现在回过头来再来理解以上对代理模式的描述，应该不难理解吧！它说由于某些原因需要给<em>某对象</em>提供一个代理以控制对该对象的访问，很显然，这个<em>某对象</em>就是目标对象，对应上面卖电脑案例中的联想厂商；此外，它说还提供了一个代理对象，即对应上面卖电脑案例中的地方代理商，这就跟我们去买电脑，不直接去找联想厂商，而是去找地方代理商一样。</p>
<p>大家得好好理解一下代理模式的概念，即使它不是那么好懂。接下来，我们来看一下下面的描述。</p>
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLIB代理两种。</p>
<h3 id="5-1-2-结构"><a href="#5-1-2-结构" class="headerlink" title="5.1.2. 结构"></a>5.1.2. 结构</h3><p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法，也就是说，在抽象主题类中定义的是规范</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。对应上面卖电脑案例中的联想厂商</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。对应上面卖电脑案例中的地方代理商</li>
</ul>
<p>如果大家对以上三种角色还不是特别好理解的话，那么下面我再举个例子来为大家解释一下。例如，现在地方代理商不仅要代理联想，还得代理戴尔，那么此时我们就得要定义一些规范了，不然的话，就没有章法了，而该规范，我们可以把它定义成接口或者抽象类，也即代理模式中的抽象主题类角色。很显然，此时，代理模式中的真实主题类角色就是联想厂商或者戴尔厂商。</p>
<p><img src="/./assets/1709441899081-682b193b-83a9-4191-9f50-408c994561eb.png" alt="img"></p>
<h3 id="5-1-3-静态代理"><a href="#5-1-3-静态代理" class="headerlink" title="5.1.3. 静态代理"></a>5.1.3. 静态代理</h3><p>在该章节，我们通过一个案例来感受一下静态代理，这个案例就是火车站卖票。</p>
<p>如果要买火车票的话，那么首选是去火车站买票，但是这样会经历坐车到火车站、排队、买票等一系列复杂的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。</p>
<p>看完上面的一个描述之后，下面我们再来看一下以下类图，通过该类图我们再把静态代理模式里面的角色给区分一下。</p>
<p><img src="/./assets/1709441899079-39c3ff8e-0a29-454d-b941-81509e408e40.png" alt="img"></p>
<p>从以上类图中可以看到，有一个接口，即SellTickets，并且它里面还有一个卖票的方法，很显然，它是属于抽象主题类角色的，因为它义的是一套规范。然后，火车站及其代售点都得实现SellTickets接口并重写它里面卖票的方法，这是因为不仅火车站有卖票的功能，而且代售点也有卖火车票的功能。此外，大家还得注意一点，就是在代售点类中得聚合火车站类的对象，因为本质上代售点调用的也是火车站卖票的方法。最后，就是咱们的客户端类了，它直接访问的是代售点，而不直接去访问火车站。</p>
<p>分析完以上类图之后，接下来我们就得编写具体代码来实现以上案例了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即proxy.static_proxy，也即静态模式的具体代码我们是放在了该包下。</p>
<p>然后，新建SellTickets接口，即卖火车票的接口。对于火车站和代售点而言，它们都得去实现该接口，所以创建该接口也就是定义了一套规范，也即卖火车票的规范。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.static_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 卖火车票的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 20:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，新建火车站类，即TrainStation。记住，该类得去实现SellTickets接口并重写它里面的卖票方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.static_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火车站类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"火车站卖票"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，新建代售点类，即ProxyPoint。同理，该类也得去实现SellTickets接口并重写它里面的卖票方法，还要一点大家需要注意，从以上类图中可看出，在代售点类中聚合了火车站类的对象，因为代售点卖票本质上还是调用火车站里面的卖票功能进行卖票，所以在代售点类的代码中，我们得在成员位置处声明火车站类的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.static_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代售点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 21:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="comment">// 声明火车站类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">trainStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"代售点收取一些服务费用"</span>);</span><br><span class="line">        trainStation.sell();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上可以看到，代售点在调用火车站里面的卖票功能进行卖票时，还进行了一个增强，即收取了一些服务费用。</p>
<p>以上接口与类创建完毕之后，我们来区分一下它们分别代表的是什么角色？很显然，SellTickets接口是属于抽象主题类角色，TrainStation类是属于真实主题类角色，ProxyPoint类是属于代理类角色。</p>
<p>最后，我们来新建一个客户端类，通过该类来做测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.static_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 21:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建代售点类对象</span></span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">proxyPoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        <span class="comment">// 调用方法进行买票</span></span><br><span class="line">        proxyPoint.sell();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上客户端类的代码，打印结果如下图所示，可以看到确实是我们想要的结果，即代售点最终还是调用火车站卖票的方法进行卖票，只不过在卖票之前，它要收取一些服务费用。</p>
<p><img src="/./assets/1709441899095-0254b8b3-e18a-4049-a111-549c4fd81b12.png" alt="img"></p>
<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介，避免了访问对象直接去访问目标对象。同时也对sell方法进行了增强，也就是代理点收取了一些服务费用。</p>
<p>有关增强，我得多说一嘴，你想怎么增强都可以，比如说，</p>
<ul>
<li>对参数进行增强，当然目前是没有参数的，所以没办法去实现</li>
<li>对方法体进行增强</li>
<li>对返回值进行增强。目前来说，我们这里面只能对方法体进行增强</li>
</ul>
<p>至此，以上静态代理模式的案例，我就讲完了，不知大家有没有完全理解呢？</p>
<hr>
<h3 id="5-1-4-动态代理"><a href="#5-1-4-动态代理" class="headerlink" title="5.1.4. 动态代理"></a>5.1.4. 动态代理</h3><p>上面我也已经说过了，动态代理又分为JDK代理和CGLIB代理两种，所以下面我就分别来为大家详细介绍一下它们。</p>
<h4 id="5-1-4-1-JDK动态代理"><a href="#5-1-4-1-JDK动态代理" class="headerlink" title="5.1.4.1. JDK动态代理"></a>5.1.4.1. JDK动态代理</h4><h5 id="5-1-4-1-1-使用"><a href="#5-1-4-1-1-使用" class="headerlink" title="5.1.4.1.1. 使用"></a>5.1.4.1.1. 使用</h5><p>我们依旧还是通过以上火车站卖票的案例来学习JDK动态代理，只不过现在我们是对上面静态代理里面的卖火车票的案例进行了一个改进。在改进之前，咱们得先来说一说JDK提供的动态代理。</p>
<p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类（即不是我们上面所说的代理类），而是提供了一个创建代理对象的静态方法（即<strong>newProxyInstance方法</strong>）来获取代理对象。</p>
<p>为什么在JDK动态代理里面没有代理类呢？<br>这是因为动态代理是在程序运行阶段动态的在内存中去生成代理类。</p>
<p>明确了以上JDK动态代理的概念之后，接下来我们就要改进上面静态代理里面的卖火车票的案例了。</p>
<p>首先，在com.meimeixia.pattern.proxy包下新建一个子包，即jdk_proxy，也即JDK动态代理的具体代码我们是放在了该包下。</p>
<p>然后，将以上SellTickets接口和TrainStation类拷贝到jdk_proxy包下，因为在JDK动态代理里面，我们也要用到这个卖火车票的接口和火车站类。拷贝过来之后，在jdk_proxy包下再创建一个类，该类我们命名为ProxyFactory，即获取代理对象的工厂类。</p>
<p>由于该类写起来还是比较复杂的，所以我们先暂时将ProxyFactory类写成下面这样。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.jdk_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取代理对象的工厂类，代理类也实现了对应的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 23:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class="line">    <span class="comment">// 声明目标对象，目标对象就是火车站类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 既然ProxyFactory是工厂类，那么毋庸置疑，在它里面我们需要提供一个获取代理对象的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大家要记住，代理类也实现了对应的接口，因此该方法的返回值类型我们就写为了SellTickets接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取代理对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 返回代理对象。那么代理对象如何去创建呢？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proxy类中的newProxyInstance方法所需要的三个参数：</span></span><br><span class="line"><span class="comment">         *      ClassLoader loader：类加载器，用于加载代理类（我们说了，代理类是在程序运行过程中动态的在内存中生成的），可以通过目标对象获取类加载器</span></span><br><span class="line"><span class="comment">         *      Class&lt;?&gt;[] interfaces：代理类实现的接口的字节码对象。由于目标对象所属类也实现了同样的接口，所以我们可以通过目标对象来获取对应接口的字节码对象</span></span><br><span class="line"><span class="comment">         *      InvocationHandler h：代理对象的调用处理程序。不过要注意，InvocationHandler是一个接口，所以你不妨以匿名内部类的形式将该参数体现出来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">            station.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                    System.out.println(<span class="string">"invoke方法执行了"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>写至此，我觉得有必要将一些重要的部分拿出来详细讲讲。</p>
<p>第一点，Proxy类中提供了一个创建代理对象的静态方法（即newProxyInstance方法）来获取代理对象，这个想必大家都知道了，但是对于newProxyInstance方法所需要的参数，有些同学可能还并不是很清楚，所以我有必要为大家详细讲清楚newProxyInstance方法所需要的参数。</p>
<ul>
<li>第一个参数，ClassLoader loader：类加载器，用于加载代理类（我们说了，代理类是在程序运行过程中动态的在内存中生成的），可以通过目标对象获取类加载器哟~</li>
<li>第二个参数，Class&lt;?&gt;[] interfaces：代理类实现的接口的字节码对象。由于目标对象所属类也实现了同样的接口，所以我们可以通过目标对象来获取对应接口的字节码对象</li>
<li>第三个参数，InvocationHandler h：代理对象的调用处理程序。不过要注意，InvocationHandler是一个接口，所以我们可以以匿名内部类的形式将该参数体现出来</li>
</ul>
<p>对于newProxyInstance方法所需要的前两个参数，想必大家理解起来应该不难，但是对于第三个参数就不一定了，代理对象的调用处理程序所表示的含义是什么呢？</p>
<p>除了上面这个问题，我们还得搞清楚另外一个问题。从上面代码来看，我们是在newProxyInstance方法的最后一个参数处传入了一个匿名内部类，并且我们还在重写的invoke方法里面输出了一句话，那么有没有同学想过invoke方法是来干嘛的啊？以及它又是什么时候被调用的呢？</p>
<p>带着这些问题，我们编写一个客户端类来测试一下，从测试中来找答案。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.jdk_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="comment">// 1. 创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 使用factory对象的方法获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        <span class="comment">// 3. 调用卖票的方法</span></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大家觉得运行以上测试类的代码，invoke方法会不会执行呢？如下图所示，可以看到invoke方法执行了。</p>
<p><img src="/./assets/1709441899063-c6cc0b77-79ca-4e2b-9245-9b4d2f617eb7.png" alt="img"></p>
<p>现在我们就可以来说说代理对象的调用处理程序所表示的含义是什么了。我们通过代理对象去调用方法，其本质调用的就是invoke方法，而invoke方法执行的就是业务逻辑处理的代码，故调用invoke方法就能进行业务逻辑处理。</p>
<p>明确了代理对象的调用处理程序之后，咱们再来重点说一下invoke方法中的参数。</p>
<ul>
<li>第一个参数，Object proxy：将要创建的代理对象。和proxyObject对象是同一个对象哟，只不过它在invoke方法中基本不用</li>
<li>第二个参数，Method method：对接口中的方法进行封装的Method对象。在本案例中，它表示的就是sell方法，当然，如果接口里面还有其他方法的话，那么通过代理对象也能调用其他的方法</li>
<li>第三个参数，Object[] args：调用方法的实际参数。在本案例中，我们在调用sell方法时是没有传递任何参数的，所以这块的args参数并没有封装对应的数据。如果你有传递实际参数，那么args参数封装的就是你传递的实际参数</li>
</ul>
<p>明确了invoke方法中的参数所表示的含义之后，我们还得明确一下invoke方法的返回值，这个怎么去理解呢？我们通过代理对象调用sell方法时是没有返回值的，所以此时invoke方法的返回值就是一个null。如果通过代理对象调用sell方法时是有返回值的，那么该返回值就是由invoke方法返回的具体的值。</p>
<p>明确了invoke方法中的参数以及返回值的含义之后，接下来，我们得继续改进invoke方法中的代码了。</p>
<p>之前咱使用静态代理模式实现火车站卖票案例时就已说过，最终代售点去卖票，还是要去调用火车站卖票的功能，所以我们还得在invoke方法中调用目标对象的方法。那怎么去调用呢？很简单，通过反射的方式调用即可，因为invoke方法中的method参数代表的就是sell方法。</p>
<p><strong>最终代码</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.jdk_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取代理对象的工厂类，代理类也实现了对应的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 23:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class="line">    <span class="comment">// 声明目标对象，目标对象就是火车站类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 既然ProxyFactory是工厂类，那么毋庸置疑，在它里面我们需要提供一个获取代理对象的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大家要记住，代理类也实现了对应的接口，因此该方法的返回值类型我们就写为了SellTickets接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取代理对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 返回代理对象。那么代理对象如何去创建呢？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proxy类中的newProxyInstance方法所需要的三个参数：</span></span><br><span class="line"><span class="comment">         *      ClassLoader loader：类加载器，用于加载代理类（我们说了，代理类是在程序运行过程中动态的在内存中生成的），可以通过目标对象获取类加载器</span></span><br><span class="line"><span class="comment">         *      Class&lt;?&gt;[] interfaces：代理类实现的接口的字节码对象。由于目标对象所属类也实现了同样的接口，所以我们可以通过目标对象来获取对应接口的字节码对象</span></span><br><span class="line"><span class="comment">         *      InvocationHandler h：代理对象的调用处理程序。不过要注意，InvocationHandler是一个接口，所以你不妨以匿名内部类的形式将该参数体现出来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">            station.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * invoke方法中的参数：</span></span><br><span class="line"><span class="comment">                     *      Object proxy：代理对象，和proxyObject对象是同一个对象哟，只不过它在invoke方法中基本不用</span></span><br><span class="line"><span class="comment">                     *      Method method：对接口中的方法进行封装的Method对象。在本案例中，它表示的就是sell方法，当然，如果接口里面还有其他方法的话，那么通过代理对象也能调用其他的方法</span></span><br><span class="line"><span class="comment">                     *      Object[] args：调用方法的实际参数。在本案例中，我们在调用sell方法时是没有传递任何参数的，所以这块的args参数并没有封装对应的数据。</span></span><br><span class="line"><span class="comment">                     *                     如果你有传递实际参数，那么args参数封装的就是你传递的实际参数</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 返回值：方法的返回值</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                    <span class="comment">// System.out.println("invoke方法执行了");</span></span><br><span class="line">                    <span class="comment">// return null;</span></span><br><span class="line">                    System.out.println(<span class="string">"代售点收取一定的服务费用（JDK动态代理）"</span>);</span><br><span class="line">                    <span class="comment">// 执行目标对象（即火车站类对象）的方法</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                    <span class="keyword">return</span> obj; <span class="comment">// 注意，目前我们通过代理对象调用sell方法时是没有返回值的，所以invoke方法返回的就是null</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上invoke方法被我们改进完毕之后，接下来，我们来运行一下测试类，看其是否能正常运行。如下图所示，可以看到测试类运行成功了，而且我们还能看出代售点卖票其本质还是调用火车站卖票的功能，只不过我们对它进行了一个增强，也就是代售点在卖票之前要收取一定的服务费用。</p>
<p><img src="/./assets/1709441899780-99c13767-7ab1-467a-9a40-8229bff35eb1.png" alt="img"></p>
<p>至此，我们就对火车站类对象里面的sell方法进行了增强，而且我们还是在没有修改火车站类的基础上进行的增强，也就是说我们对火车站类对象进行了一个动态的增强。</p>
<p>这样，使用JDK动态代理模式改进火车站卖票案例我就讲完了.</p>
<hr>
<h5 id="5-1-4-1-2-JDK动态代理的底层原理"><a href="#5-1-4-1-2-JDK动态代理的底层原理" class="headerlink" title="5.1.4.1.2. JDK动态代理的底层原理"></a>5.1.4.1.2. JDK动态代理的底层原理</h5><p>我相信有些同学心里肯定有一个大大的问号，虽然是使用JDK动态代理模式改进了火车站卖票案例，但是对于JDK动态代理的底层原理我咋还不是特别理解呢！我感觉我整个人都是懵逼状态的啊😱！</p>
<p>没关系，下面我就来为大家讲讲JDK动态代理的底层原理。</p>
<p>现在大家不妨先思考一个问题，那就是上面火车站卖票案例里面的ProxyFactory是代理类吗？很显然，ProxyFactory并不是代理模式中所说的代理类，它只是一个工厂类，而该工厂类提供了一个获取代理对象的方法。大家一定要清楚一点，就是<strong>代理类是程序在运行过程中动态的在内存中生成的类</strong>，我们是看不到的。</p>
<p>所以，为了研究JDK动态代理的底层原理，我们得通过阿里巴巴开源的Java诊断工具（即Arthas，翻译为阿尔萨斯）去查看代理类的结构。</p>
<p>有些同学可能会问了，阿里巴巴开源的Java诊断工具（即Arthas）如何下载呢？一般而言都是从官网去下载，大家打开Google Chrome浏览器，直接在浏览器地址栏中输入如下url地址回车即可进行下载。</p>
<p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p>
<p>你会发现下载下来的是arthas-boot.jar这样一个jar包，该jar包下载下来之后，你想放在哪儿随意，不过我是将其放在了桌面上，因为待会使用起来可能会很方便。</p>
<p>此外，在通过Arthas查看动态生成的代理类的结构之前，我们得预先做好相应准备。回到客户端类当中，我们得预先做两件事情，第一件事是将代理类的名称打印出来；第二件事是让程序一直执行，想要让程序一直执行很简单，直接写一个死循环就可以了。有些同学可能会问了，为什么要让程序一直执行呢？因为代理类是在内存中动态生成的，如果我们的程序结束了，那么内存就会被释放掉，自然代理类我们就不会拿得到了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.jdk_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="comment">// 1. 创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 使用factory对象的方法获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        <span class="comment">// 3. 调用卖票的方法</span></span><br><span class="line">        proxyObject.sell();</span><br><span class="line"></span><br><span class="line">        System.out.println(proxyObject.getClass()); <span class="comment">// 先将代理类的名称打印出来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后让程序一直执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {}</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们来运行以上客户端类，如下图所示，可以看到打印出了com.sun.proxy.$Proxy0这样一个全类名，它就是在内存中动态生成的代理类的全类名。</p>
<p><img src="/./assets/1709441899854-9909e0aa-0579-4c9d-9299-f7ded1bdccf8.png" alt="img"></p>
<p>然后，我们就得通过arthas-boot.jar来获取代理类了。那如何进行获取呢？很简单，只要大家遵循下面的步骤就能获取到。</p>
<p>第一步，打开CMD命令行窗口，切到arthas-boot.jar所在的目录下。</p>
<p><img src="/./assets/1709441899902-592e8ed4-e276-4b2c-8727-715c1f96507d.png" alt="img"></p>
<p>第二步，使用java -jar arthas-boot.jar命令来执行arthas-boot.jar这个jar包。</p>
<p><img src="/./assets/1709441899969-d6245056-d0a5-4417-8538-88608e27ff31.png" alt="img"></p>
<p>这时，你会看到共有三个选项可供选择，那到底我们应该选择哪一项呢？看到第1个选项了没，它说是不是让我们去选择com.meimeixia.pattern.proxy.jdk_proxy.Client这个程序啊！那我们就去选择这个程序呗！也就是选择第1个选项。</p>
<p><img src="/./assets/1709441899907-1fe6d412-1dfc-48dc-a1eb-391636131c0c.png" alt="img"></p>
<p>第三步，使用jad com.sun.proxy.$Proxy0命令将在内存中动态生成的代理类拉取下来。</p>
<p><img src="/./assets/1709441900522-a8271bb3-3ad8-4f3a-ad8f-153926fcd74e.png" alt="img"></p>
<p>拉取下来之后，为了方便进一步研究，大家可以将以上代理类的代码拷贝到记事本或者Notepad++中。这里，为了让大家看清楚拉取下来的代理类的代码，我就将其贴出来了，如下所示，还挺长的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.meimeixia.pattern.proxy.jdk_proxy.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) {</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.meimeixia.pattern.proxy.jdk_proxy.SellTickets"</span>).getMethod(<span class="string">"sell"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]{object});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>温馨提示：关于阿里巴巴开源的Java诊断工具（即Arthas）的其他用法，大家可以去看看官网，或者在网上搜索一下其他的资料，例如别人写的博客之类的，但在这里我就不再具体讲解该工具的用法了，我们的关注点是要放在设计模式上。</p>
<p>以上代理类的代码太长了，不便于我们研究，所以我就做了一下调整，只将要研究的重点代码摘取出来了，精简成了下面这样。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.meimeixia.pattern.proxy.jdk_proxy.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) {</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        m3 = Class.forName(<span class="string">"com.meimeixia.pattern.proxy.jdk_proxy.SellTickets"</span>).getMethod(<span class="string">"sell"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，代理类的代码看着就更加清晰一些了。</p>
<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（即$Proxy0）不仅继承了Proxy类还实现了SellTickets接口。这也就印证了我们之前说的真实类和代理类实现了同样的接口</li>
<li>代理类（即$Proxy0）将我们提供了的匿名内部类对象传递给了父类</li>
</ul>
<p>第一点很容易就能看出来，倒是第二点就有点难了，不过也没关系，下面我分析以上代理类中的代码时就会向大家讲清楚。</p>
<p>大家注意看，在静态代码块里面，是先获取到SellTickets接口的字节码对象之后，再去获取它里面的方法对象，也就是说获取的是SellTickets接口里面的表示sell方法的Method对象。获取到之后立马就赋给了静态变量m3。</p>
<p>分析完以上代理类的静态代码块之后，我们再来分析一下其构造方法。发现该代理类并没有提供无参构造，而只是提供了一个有参构造，并且还接收了一个InvocationHandler接口类型的参数，接收之后还将其直接赋给了父类（即Proxy）。</p>
<p>所以，接下来，我们就来看一下Proxy类，发现该类里面有一个InvocationHandler接口类型的成员变量，如下图所示。</p>
<p><img src="/./assets/1709441900545-38a8716d-2798-4c8e-b0cd-0e39fd9460da.png" alt="img"></p>
<p>当我们使用Proxy类里面的静态方法（即newProxyInstance方法）来创建代理对象时，肯定是调用的代理类（即$Proxy0）中的有参构造方法，而该有参构造方法中需要传递一个InvocationHandler接口类型的东东，刚刚好，我们以匿名内部类的形式创建了一个InvocationHandler接口的子实现类对象，如下图所示。这样，该子实现类对象是不是直接赋给了父类（即Proxy）中protected InvocationHandler h这么一个成员变量啊！</p>
<p><img src="/./assets/1709441900612-ca53037d-36bf-44df-ba17-270190f4dc3a.png" alt="img"></p>
<p>由于我们现在是通过代理对象来调用sell方法的，而该代理对象就是以上代理类（即$Proxy0）的对象，所以我们就来看看代理类中的sell方法都做了些什么。<br><img src="/./assets/1709444088607-7481f11b-9bdd-459f-8359-2654f77e4511.png" alt="img"></p>
<p>很显然，在sell方法里面又调用了当前成员对象（即h，它是InvocationHandler接口类型的）里面的invoke方法，而这个h成员对象就是我们自己定义的InvocationHandler接口的子实现类对象，也就是说sell方法里面实际上调用的就是该子实现类对象中的invoke方法，如下图所示。</p>
<p><img src="/./assets/1709441900625-3bff302a-6e12-4b30-a8b9-90275aef9303.png" alt="img"></p>
<p>归根结底一句话，我们通过代理对象来调用sell方法，实质上调用的是以上invoke方法，不知大家明白了没？</p>
<p>至此，JDK动态代理的底层原理我就给大家讲解清楚了，相信大家对JDK动态代理的理解更加深刻了。</p>
<h5 id="5-1-4-1-3-JDK动态代理的代码执行流程"><a href="#5-1-4-1-3-JDK动态代理的代码执行流程" class="headerlink" title="5.1.4.1.3. JDK动态代理的代码执行流程"></a>5.1.4.1.3. JDK动态代理的代码执行流程</h5><p>了解了JDK动态代理的底层原理之后，接下来我们来看看JDK动态代理的代码执行流程是什么样子的。</p>
<p>上面我已经分析得差不多了，所以这里我就直接给出JDK动态代理的代码执行流程了。</p>
<ol>
<li>在测试类中通过代理对象调用sell方法</li>
<li>根据多态的特性，执行的是代理类（即$Proxy0）中的sell方法</li>
<li>代理类（即$Proxy0）中的sell方法又调用了InvocationHandler接口的子实现类对象的invoke方法，也就是调用了我们自己定义的InvocationHandler接口的子实现类对象的invoke方法</li>
<li>invoke方法通过反射执行了真实对象所属类（即TrainStation）中的sell方法。当然，我们还可以对其进行一个增强</li>
</ol>
<hr>
<h4 id="5-1-4-2-CGLIB动态代理"><a href="#5-1-4-2-CGLIB动态代理" class="headerlink" title="5.1.4.2. CGLIB动态代理"></a>5.1.4.2. CGLIB动态代理</h4><h5 id="5-1-4-2-1-介绍与依赖"><a href="#5-1-4-2-1-介绍与依赖" class="headerlink" title="5.1.4.2.1. 介绍与依赖"></a>5.1.4.2.1. 介绍与依赖</h5><p>这里，我们还是通过以上火车站卖票的案例来讲述CGLIB动态代理，即使用CGLIB动态代理来实现火车站卖票的案例。</p>
<p>如果没有定义SellTickets接口，而只是定义了TrainStation（即火车站类），那么此时JDK动态代理还能用吗？很显然JDK动态代理是无法使用了，因为JDK动态代理要求必须定义接口，它是对接口进行代理的，现在没有定义接口，那么自然就不能使用JDK动态代理了。</p>
<p>既然不能使用JDK动态代理，那么应该怎么办呢？我们可以使用CGLIB动态代理来实现哟！接下来，我们就来看一下什么是CGLIB。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包（也就是说CGLIB就是用来生成代码的，而且大家注意了，它也是在内存中动态的去生成哟😋）。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>总之，一句话，若有接口，则你可以使用JDK动态代理带来实现代理；若没有接口，则你就可以使用CGLIB进行代理了。</p>
<p>由于CGLIB是第三方提供的包，所以我们还需要在咱们的maven工程中引入对应jar包的坐标。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>引入成功了之后，接下来我们就要开始编写咱们的代码了。</p>
<p>首先，在com.meimeixia.pattern.proxy包下新建一个子包，即cglib_proxy，也即CGLIB动态代理的具体代码我们是放在了该包下。</p>
<p>然后，新建火车站类，即TrainStation。注意了，此时并不需要再新建SellTickets接口了，因为我们现在是要使用CGLIB进行代理。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.cglib_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火车站类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-21 20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"火车站卖票"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，新建工厂类，即ProxyFactory，该工厂就是用来获取代理对象的。理所应当地，我们应该在该工厂类中定义一个获取代理对象的方法，那么大家有没想过该方法的返回值类型应该是什么呢？大家一定要注意了，使用CGLIB进行代理的话，获得的代理类就是目标对象所属类的子类。</p>
<p>所以，很显然，获取代理对象的方法的返回值类型应该是目标对象所属类，即TranStation，因为生成的代理类就是属于该类的一个子类。</p>
<p>明确了上面这点之后，接下来我们就得逐步完善获取代理对象的方法了，就是怎么使用CGLIB来进行代理。</p>
<h5 id="5-1-4-2-2-使用"><a href="#5-1-4-2-2-使用" class="headerlink" title="5.1.4.2.2. 使用"></a>5.1.4.2.2. 使用</h5><p>那如何使用CGLIB来进行代理呢？很简单哟！只须遵守以下步骤即可。</p>
<ul>
<li><p>第一步，创建Enhancer类对象，该类有点类似于咱们JDK动态代理中的Proxy类。那么很明显，该类就是用来获取代理对象的。注意了，该类是属于CGLIB里面的，所以我们要导入相对应的包哟😁</p>
</li>
<li><p>第二步，设置父类的字节码对象。为啥子要这样做呢？因为使用CGLIB生成的代理类是属于目标类的子类的，也就是说代理类是要继承自目标类的。</p>
</li>
<li><p>第三步，设置回调函数。这一步特别重要，所以我需要着重给大家讲解一下。</p>
</li>
<li><ul>
<li>什么是回调函数呢？我们通过代理对象去调用sell方法时，你有没有想过，它执行的到底是哪一个方法呢？现在一时搞不清，没关系，我们换个思路出发，就来看看如何设置回调函数。</li>
<li>设置回调函数，其实很简单，无非就是调用Enhancer类对象里面的setCallback方法，可难的是应该向该方法中传递什么?</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enhancer.setCallback(MethodInterceptor接口的子实现类对象);</span><br></pre></td></tr></tbody></table></figure>

<p>其实，我们应该向该方法中传递一个对象，那么是哪个类的对象呢？注意了，是MethodInterceptor接口的子实现类对象哟！所以，在这里我们的做法就很简单了，即让工厂类去实现MethodInterceptor接口，并重写它里面的intercept方法.</p>
<p>现在，你该知道setCallback方法里面应该传递什么了吧！既然该方法要的是一个MethodInterceptor接口的子实现类对象，而ProxyFactory工厂类本身就是MethodInterceptor接口的子实现类，所以我们向setCallback方法传递ProxyFactory工厂类自身对象（即this）就可以了。</p>
<p>当然也可用匿名内部类实现MethodInterceptor接口,这里不做赘述</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.cglib_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理对象工厂，用来获取代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 17:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明火车站对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 1. 创建Enhancer类对象，它类似于咱们JDK动态代理中的Proxy类，很明显，该类就是用来获取代理对象的</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 2. 设置父类的字节码对象。为啥子要这样做呢？因为使用CGLIB生成的代理类是属于目标类的子类的，也就是说代理类是要继承自目标类的</span></span><br><span class="line">        enhancer.setSuperclass(TrainStation.class);</span><br><span class="line">        <span class="comment">// 3. 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 4. 创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        System.out.println(<span class="string">"方法执行了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>哎呀，一开始提出的问题还没解决啊！也就是我们通过代理对象去调用sell方法时，还不知道它执行的到底是哪一个方法呢？难道是上面这个intercept方法吗？又或者说intercept方法它是在什么时候执行的呢？别急，下面我就会讲到。</p>
<ul>
<li>第四步，创建代理对象。创建代理对象的话，我们使用的是Enhancer类对象里面的create方法，当然，想必大家也都知道了，该代理对象就是目标类的子类对象，所以这一块肯定是要进行一个强制类型转换的。</li>
</ul>
<p>经过上面四个步骤，相信你一定能写出像上面那样的ProxyFactory类的代码。我就不信我都讲得这么清楚了，你还写不出来。</p>
<p>接下来，为了搞清楚上面的一系列问题，我们就要新建一个客户端类来测试一下了，从测试结果中寻找问题的答案。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.cglib_proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 18:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        <span class="comment">// 调用代理对象中的sell方法进行卖票</span></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类，结果如下图所示，现在我们就可以得出这样一个结论了，即通过代理对象调用sell方法时，其实调用的intercept方法，这就是我们为什么要设置回调函数的原因。大家可千万要注意了，设置回调函数时，设置的是intercept方法所属类的对象哟！当然了，在本案例中，设置的就是this。</p>
<p><img src="/./assets/1709441900830-f727a24c-b8a5-4d4a-8df1-e8ff947b6c5d.png" alt="img"></p>
<p>明确了intercept方法什么时候被调用之后，接下来，我们就得增强目标对象的方法（即火车站对象的卖票方法）了。</p>
<p><strong>最终代码</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.proxy.cglib_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理对象工厂，用来获取代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 17:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明火车站对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 1. 创建Enhancer类对象，它类似于咱们JDK动态代理中的Proxy类，很明显，该类就是用来获取代理对象的</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 2. 设置父类的字节码对象。为啥子要这样做呢？因为使用CGLIB生成的代理类是属于目标类的子类的，也就是说代理类是要继承自目标类的</span></span><br><span class="line">        enhancer.setSuperclass(TrainStation.class);</span><br><span class="line">        <span class="comment">// 3. 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 4. 创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * intercept方法参数说明：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object o：代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Method method：真实对象中的方法的Method实例。在本案例中，它表示的就是sell方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object[] objects：调用方法的实际参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> MethodProxy methodProxy：代理对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="comment">// System.out.println("方法执行了");</span></span><br><span class="line">        <span class="comment">// return null;</span></span><br><span class="line">        System.out.println(<span class="string">"代售点收取一定的服务费用（CGLIB代理）"</span>);</span><br><span class="line">        <span class="comment">// 通过反射的方式去调用目标对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(station, objects);</span><br><span class="line">        <span class="keyword">return</span> obj; <span class="comment">// 注意，目前我们通过代理对象调用sell方法时是没有返回值的，所以invoke方法返回的就是null</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，再来运行客户端类的测试代码，结果如下图所示，发现通过代理对象调用sell方法，其根本也是调用火车站里面的卖票方法，只不过我们在代理对象中对卖票的功能进行了一个增强，因为代售点是要收取一定的服务费用的。</p>
<p><img src="/./assets/1709441901187-0a435289-c527-4ed5-b74f-32fadea8ec5f.png" alt="img"></p>
<p>以上就是CGLIB动态代理的一个实现案例，我就讲到这里了，应该是讲得非常清楚了。</p>
<h5 id="5-1-4-2-3-总结"><a href="#5-1-4-2-3-总结" class="headerlink" title="5.1.4.2.3. 总结"></a>5.1.4.2.3. 总结</h5><p>最后，我对CGLIB动态代理的实现做一个总结，如下。</p>
<p>大家一定要记住使用Enhancer类对象里面的create方法可以获取到代理对象，只是在这之前我们需要做两件事，分别是：</p>
<ol>
<li>指定父类（代理类的父类哟~）的字节码对象</li>
<li>当我们通过代理对象调用方法时，其本质调用的是MethodInterceptor规范接口里面的intercept方法。在以上案例中，我们通过代理对象调用具体的sell方法时，实际上执行的就是intercept方法</li>
</ol>
<hr>
<h3 id="5-1-5-三种代理的对比"><a href="#5-1-5-三种代理的对比" class="headerlink" title="5.1.5. 三种代理的对比"></a>5.1.5. 三种代理的对比</h3><p>在上面，我们使用CGLIB动态代理实现了火车站卖票的案例，相信大家对于CGLIB动态代理也有了一定的认识。当然，对于CGLIB动态代理的底层实现原理，在本讲我就不再为大家进行详细讲述了。有兴趣的同学可以自己使用阿里巴巴提供的Java诊断工具进行一个代理类的获取，然后自己去分析一下。</p>
<p>在本小节，我们来对比一下以上三种代理，即静态代理、JDK动态代理和CGLIB动态代理。</p>
<h4 id="5-1-5-1-JDK动态代理和CGLIB动态代理"><a href="#5-1-5-1-JDK动态代理和CGLIB动态代理" class="headerlink" title="5.1.5.1. JDK动态代理和CGLIB动态代理"></a>5.1.5.1. JDK动态代理和CGLIB动态代理</h4><p>使用CGLIB实现动态代理，CGLIB底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射的效率要高。唯一需要注意的是，CGLIB不能对声明为final的类或者方法进行代理，因为CGLIB原理是动态生成被代理类的子类（或者目标类的子类）。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLIB代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLIB代理。而现在几乎所有的公司基本上都是使用的JDK1.8及以上的版本，所以又可以这样说，JDK代理的效率要高于CGLIB的。</p>
<p>那么以后我们在真正使用的时候，到底应该使用的是JDK代理还是CGLIB代理呢？若有接口则使用JDK动态代理，若没有接口则使用CGLIB代理。</p>
<h4 id="5-1-5-2-动态代理和静态代理"><a href="#5-1-5-2-动态代理和静态代理" class="headerlink" title="5.1.5.2. 动态代理和静态代理"></a>5.1.5.2. 动态代理和静态代理</h4><p>动态代理与静态代理相比较，最大的好处是接口（也可以是类）中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）了。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转（或者重写）了。</p>
<p>以上这段话说的什么意思啊？这里我给大家解释一下。</p>
<p>如果是JDK动态代理的话，那么它集中都会调用invoke方法，因为JDK动态代理是对接口里面的方法进行代理的，而要是接口里面定义了多个方法，那么通过代理对象调用任何一个方法，最终执行的都是invoke方法，所以这是不是集中进行了一个处理啊！</p>
<p>对于CGLIB动态代理也是同样的一个道理，MethodInterceptor规范接口里面的intercept方法对我们目标对象中的方法进行一个增强，也即对目标类进行了一个代理，而要是目标类里面有多个方法的话，那么通过代理对象调用任何一个方法，最终执行的都将会是这个intercept方法，这是不是也集中进行了一个处理啊！</p>
<p>最后，如果接口增加了一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，这就增加了代码维护的复杂度。而动态代理则不会出现该问题，因为你在接口或者类里面去新添加了一个方法的话，我们的代理类不需要进行改变的，因为它是动态的在内存中生成的。</p>
<h3 id="5-1-6-代理模式的优缺点以及使用场景"><a href="#5-1-6-代理模式的优缺点以及使用场景" class="headerlink" title="5.1.6. 代理模式的优缺点以及使用场景"></a>5.1.6. 代理模式的优缺点以及使用场景</h3><p>接下来，我们来看下代理模式的优缺点以及使用场景。</p>
<h4 id="5-1-6-1-优缺点"><a href="#5-1-6-1-优缺点" class="headerlink" title="5.1.6.1. 优缺点"></a>5.1.6.1. 优缺点</h4><h5 id="5-1-6-1-1-优点"><a href="#5-1-6-1-1-优点" class="headerlink" title="5.1.6.1.1. 优点"></a>5.1.6.1.1. 优点</h5><p>代理模式的优点，我总结了下面三个。</p>
<ol>
<li>代理模式在客户端与目标对象之间起到了一个中介作用和保护目标对象的作用。有了代理模式之后，访问者只需要去访问代理对象而无须直接去访问目标对象了，这就对目标对象起到了一个保护的作用</li>
<li>代理对象可以扩展目标对象的功能。也就是说，代理对象可以对目标对象里面的功能进行增强，例如，在上面火车站卖票的案例中，代售点就是代理对象，它可以对火车站卖票的功能进行增强，增强的逻辑就是收取一些服务费用。当然了，你可以在你自己的业务里面进行相应的一个增强</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，注意，主要降低的是访问者和目标对象之间的一个耦合度</li>
</ol>
<h5 id="5-1-6-1-2-缺点"><a href="#5-1-6-1-2-缺点" class="headerlink" title="5.1.6.1.2. 缺点"></a>5.1.6.1.2. 缺点</h5><p>增加了系统的复杂度。对于代理对象，尤其是动态代理，你会发现实现起来还是稍微有点麻烦的，如果你在不了解它底层原理的情况下去实现，那么会特别特别麻烦，而且特别不好理解。</p>
<h4 id="5-1-6-2-使用场景"><a href="#5-1-6-2-使用场景" class="headerlink" title="5.1.6.2. 使用场景"></a>5.1.6.2. 使用场景</h4><p>使用场景的话，我也总结了下面三个。</p>
<ol>
<li>远程（Remote）代理本地服务通过网络请求远程服务（也就是说远程的去调用里面的方法或者功能）。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，我们应将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。其实，这个就是RPC思想，也即远程去调用方法。后期我们可能会用到很多RPC的框架，它底层就是这么一个思想，也就是远程代理，只不过在这儿我就不做详细的讲解了。</li>
<li>防火墙（Firewall）代理当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。其实，这个就是所谓的VPN，通过它我们就能访问外边的一些网络了。</li>
<li>保护（Protect or Access）代理控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。使用了代理模式之后，访问者直接访问的是代理对象而不再是目标对象，这样，在代理对象里面，我们就可以给不同的用户提供不同级别的使用权限了。</li>
</ol>
<hr>
<h2 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2. 适配器模式"></a>5.2. 适配器模式</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1. 概述"></a>5.2.1. 概述</h3><p>在学习<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">适配器模式</a>之前，我们先来看下下面这个场景。</p>
<p>如果去欧洲国家旅游的话，他们的插座如下图最左边，是欧洲标准，而我们使用的插头如下图最右边，很显然，我们的插头是不能直接插到欧标的插座上面的。因此我们的笔记本电脑、手机在当地都不能直接充电，所以此时我们就需要一个插座转换器了，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地就能使用了，也就是说我们的笔记本电脑、手机等在当地就可以正常的进行充电操作了。</p>
<p><img src="/./assets/1709450080814-0d26ee48-3bc4-40bc-9ecd-38d78e76535f.png" alt="img"></p>
<p>生活中这样的例子很多，手机充电器（将220v的电压转换为5v的电压）、读卡器等，其实它们就使用到了适配器模式。</p>
<p>以上我们通过一个案例简单的去认识了一下适配器模式，接下来我们就来看一下到底什么是适配器模式。</p>
<p><strong>适配器模式指的是将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</strong></p>
<p>上述适配器模式的概念是说的什么意思呢？我们还是结合上面那张图来分析一下。从上图中我们知道，我们希望的是能使用咱们两头插头的这样的一个接口，但是欧洲国家提供的都是欧标的接口（插座），这样，我们就需要将欧标接口转换成我们所希望使用到的接口了。要想做到这点，就不得不用到插座转换器了，有了它之后，我们就可以正常的使用咱们之前的充电头了，继而就能插入对应的插座对我们的笔记本电脑、手机进行充电了。不过，这一切都得借助于插座转换器。</p>
<p>相信经过我上面的解释，大家对于适配器模式的概念一定有了一个更深入的认识。接下来，我们再来看一下适配器模式的分类。</p>
<p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高（这是因为类适配器模式使用的是继承的方式，而对象适配器模式使用的是聚合或者组合的方式），且类适配器模式要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些，用的更多的还是对象适配器模式。</p>
<hr>
<h3 id="5-2-2-结构"><a href="#5-2-2-结构" class="headerlink" title="5.2.2. 结构"></a>5.2.2. 结构</h3><p>适配器模式里面总共拥有三个角色，它们分别是：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。以上面案例为例，目标接口指的就是我们所希望要的两头的插座，这样的插座在欧洲国家是没有提供的</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。对应上面案例中的欧标插座，该插座现在在欧洲国家里面是已经存在的了</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承（类适配器模式）或引用适配者的对象（对象适配器模式），把适配者接口转换成目标接口（也就是使用转换器将三头的欧标插座转换成适合我们使用的两头插座），让客户按目标接口的格式访问适配者。很显然，它对应上面案例中的插座转换器</li>
</ul>
<h3 id="5-2-3-类适配器模式案例"><a href="#5-2-3-类适配器模式案例" class="headerlink" title="5.2.3. 类适配器模式案例"></a>5.2.3. 类适配器模式案例</h3><h4 id="5-2-3-1-分析"><a href="#5-2-3-1-分析" class="headerlink" title="5.2.3.1. 分析"></a>5.2.3.1. 分析</h4><p>接下来，我们来实现一个类适配器模式的案例，不过在实现之前，我们先来看一下实现的方式。</p>
<p>类适配器模式实现的方式是定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>What’s Up（卧槽）！这说的是个啥意思啊？上面说的适配器类、当前系统的业务接口和现有组件库中已经存在的组件分别表示什么啊？别急，下面我就会给大家解释解释一下。</p>
<ul>
<li>适配器类：这个比较好理解，就是类适配器模式角色里面的适配器类</li>
<li>当前系统的业务接口：就是类适配器模式角色里面的目标接口，我们当前系统可以使用的接口就是目标接口</li>
<li>现有组件库中已经存在的组件：就是类适配器模式角色里面的适配者类</li>
</ul>
<p>所以，类适配器模式的实现方式就包含了类适配器模式里面的三个角色。</p>
<p>类适配器模式的实现方式明确之后，接下来，我们就来看一个具体的案例，即读卡器案例。</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。那如何来说实现呢？创建一个读卡器类（或者适配器类），将TF卡中的内容读取出来。</p>
<p>简单地分析了一下以上读卡器案例之后，接下来，我们来看下下面的类图，通过该类图再去了解一下该案例牵扯到了哪些类和接口以及接口和类之间的关系。</p>
<p><img src="/./assets/1709450080770-9a5f448b-6658-42ce-9bc5-80521c9c172e.png" alt="img"></p>
<p>首先，我们来看一下以上类图的右边部分，这一部分表示的其实是适配者类。在这一部分，我们为了给适配者类提供一个规范，所以就定义了一个接口（即TFCard），里面有两个方法，一个是从TF卡里面去读取数据，一个是往TF卡里面去写数据，读取数据的方法肯定是有返回值的，而写数据的方法未必有返回值，但是肯定是有参数的，只不过我在这里面没有体现出来而已。看完TFCard接口之后，再来看一下它的子实现类（即TFCardImpl），它里面重写了父接口中的两个方法。</p>
<p>然后，我们再来看一下以上类图的上边部分，这一部分表示的其实是目标接口。同样，我们也定义了一个接口（即SDCard），它里面也有两个方法，一个是从SD卡里面去读取数据，一个是往SD卡里面去写数据。同时，我们又给该接口提供了一个子实现类（即SDCardImpl），该子实现类同样重写了父接口中的两个抽象方法。</p>
<p>接着，我们来看一下Computer类，它是只能读取SD卡的，所以我们给它里面定义了一个从SD卡里面去读取数据的readSD方法。当然了，你也可以定义一个往SD卡里面去写数据的方法，只不过我在这里面没有定义出来而已，而只是通过readSD方法来模拟了。很显然，该方法需要一个SDCard接口类型的对象，返回的是一个字符串，所以Computer类和SDCard接口是属于依赖的关系。</p>
<p>最后，大家来思考一个问题，如果我们想要使用这台电脑去读取TF卡里面的数据，那么怎么办呢？能不能去创建TFCardImpl子实现类对象，把它作为参数进行一个传递呢？很显然肯定是不行的。不行的话那又该怎么办呢？此时，我们应该<strong>定义一个适配器类（即SDAdapterTF，也就是说SD卡来兼容TF卡），而且我们还要让该适配器类去实现SD卡的目标接口（即SDCard）</strong>，这是因为咱们的电脑只能读取SD卡，这样一来，该适配器类就要去重写SDCard接口中的两个抽象方法了。<strong>同时，我们还要让该适配器类去继承TFCardImpl类</strong>，这样的话，我们在适配器类中提供的两个方法看似好像是从SD卡里面去读取数据或者是往SD卡里面去写数据，但实际上我们用的是TF卡里面的功能。</p>
<p>以上就是我对以上类图的一个分析。当然了，我还没有带着大家分析一下客户端类（即Client），因为它很简单，就只是依赖了Computer、SDCardImpl、SDAdapterTF这三个类。</p>
<p>分析完以上类图之后，接下来，我们就得通过具体的代码来实现了。</p>
<hr>
<h4 id="5-2-3-2-实现"><a href="#5-2-3-2-实现" class="headerlink" title="5.2.3.2. 实现"></a>5.2.3.2. 实现</h4><p>上面我们简单分析了一下读卡器案例，并且详细地去分析了一下该案例所表示的类图里面涉及到的接口以及类，接下来，我们就要通过具体的代码来实现了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即adapter.class_adapter，也即类适配器模式的具体代码我们是放在了该包下。</p>
<p>然后，创建一个接口，我们不妨把该接口命名为TFCard。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从TF卡中读取数据</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 往TF卡中写数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上接口创建完毕之后，我们创建它的一个实现类，该实现类我们不妨就叫为TFCardImpl，其实，该实现类就是适配者类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注意，这里只是模拟从TF卡里面读取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">"TFCard read msg : hello world TFCard"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 往TF卡里面写数据时，我们是直接将拿到的数据输出到了控制台</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"TFCard write msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建目标接口，我们不妨把该目标接口命名为SDCard。为何说它是目标接口呢？因为咱们的电脑只能读取SD卡里面的数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从SD卡中读取数据</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 往SD卡中写数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>目标接口创建完毕之后，我们就要给它创建一个具体的实现类了，该实现类我们不妨就叫为SDCardImpl。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的SD卡类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注意，这里只是模拟从SD卡里面读取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">"SDCard read msg : hello world SD"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 往SD卡里面写数据时，我们是直接将拿到的数据输出到了控制台</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"SDCard write msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建Computer类。在该类里面，我们需要定义一个从SD卡里面去读取数据的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从SD卡中读取数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> { <span class="comment">// 读取数据的话，你得给我一个SD卡，我才能从里面去读取数据，是不是啊？</span></span><br><span class="line">        <span class="comment">// 所以，在这里我们的实现就是传递一个SDCard接口的子实现类对象。当然了，</span></span><br><span class="line">        <span class="comment">// 在这里我们声明的是接口类型，因为这样的话会更通用一些</span></span><br><span class="line">        <span class="keyword">if</span> (sdCard == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">"sd card is not null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Computer类创建完毕之后，咱们也先别着急着去创建适配器类，而是先来创建客户端类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建计算机对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 读取SD卡中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> computer.readSD(<span class="keyword">new</span> <span class="title class_">SDCardImpl</span>());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，我们运行一下以上客户端类，来看一下是不是我们想要的结果。如下图所示，读取到的内容确实是SDCard read msg : hello world SD，可见确实是从SD卡里面读取到的数据。</p>
<p><img src="/./assets/1709450081308-2d434c71-8b27-4b43-bf60-0568504d9a6a.png" alt="img"></p>
<p>现在我们有一个需求，就是使用该计算机读取TF卡中的数据，那么该怎么办呢？能直接去读取TF卡中的数据吗？很显然是不能够的，因为咱们的计算机是没有提供从TF卡里面读取数据的功能的。</p>
<p>所以，在这里我们就要去做一件事了，即去创建适配器类，该类我们就不妨命名为SDAdapterTF了，意思就是让SD卡适配TF卡。那么怎么去创建该适配器类呢？上面我讲过类适配器模式的实现方式，就是定义一个适配器类来实现当前系统的业务接口（目前业务接口就是SDCard），同时又继承现有组件库中已经存在的组件（目前已经存在的组件就是TFCardImpl）。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 22:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card"</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF(); <span class="comment">// 如果我们使用适配器的话，那么真正的读取数据是从TF卡里面去读取。所以，此处我们直接调用TFCardImpl类里面的readTF方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        writeTF(msg); <span class="comment">// 同理，此处我们直接调用TFCardImpl类里面的writeTF方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上适配器类创建完毕之后，回到咱们的客户端类中，测试一下使用该电脑读取TF卡中的数据是否可行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.class_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建计算机对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 读取SD卡中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> computer.readSD(<span class="keyword">new</span> <span class="title class_">SDCardImpl</span>());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        <span class="comment">// 使用该电脑读取TF卡中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg1</span> <span class="operator">=</span> computer.readSD(<span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>()); <span class="comment">// 创建适配器类对象，并进行一个传递</span></span><br><span class="line">        System.out.println(msg1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，我们运行一下以上客户端类，来看一下是不是我们想要的结果。如下图所示，在分割线下面读取到的内容确实是TFCard read msg : hello world TFCard，可见确实是从TF卡里面读取到的数据。</p>
<p><img src="/./assets/1709450080815-3363c5dd-0919-497d-b28b-a1851188219b.png" alt="img"></p>
<p>至此，我们就使用类适配器模式实现了电脑从TF卡里面去读取数据的需求。</p>
<p>不过，最后我要说一点，就是类适配器模式违背了合成复用原则，而且类适配器是客户类有一个接口规范的情况下可用，反之则不可用。这是啥意思呢？回看一下一开始的那张类图，如果我们没有定义SDCard接口，而只是就有一个类（即SDCardImpl），那么我们就不能使用类适配器模式来实现了。为什么呢？上面咱们使用了类适配器模式，可以看到适配器类不仅继承了适配者类，而且还实现了目标接口，要是没有目标接口而只有一个类的话，那么你猜一个类能不能同时继承两个类呢？很显然是不可以的啊！(java不能实现多继承)所以这不就没办法去实现了嘛！</p>
<hr>
<h3 id="5-2-4-对象适配器模式案例"><a href="#5-2-4-对象适配器模式案例" class="headerlink" title="5.2.4. 对象适配器模式案例"></a>5.2.4. 对象适配器模式案例</h3><h4 id="5-2-4-1-分析"><a href="#5-2-4-1-分析" class="headerlink" title="5.2.4.1. 分析"></a>5.2.4.1. 分析</h4><p>接下来，我们还是通过读卡器案例来学习一下适配器模式里面的对象适配器模式。在正式学习之前，我们先来看一下对象适配器模式的实现方式。</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中（当然，在这里我们使用的就是聚合方式），并且该类同时实现当前系统的业务接口的方式来实现。</p>
<p>明确实现方式之后，回过来我们再来看一下读卡器案例。由于现在我们要使用的对象适配器模式，所以我们就得对以上读卡器案例进行一个改进了。</p>
<p>使用对象适配器模式将读卡器案例进行改写之后的类图，如下所示。</p>
<p><img src="/./assets/1709450080796-a27e486a-bb36-4ee5-ae6e-89607a5d421d.png" alt="img"></p>
<p>可以看到，该类图和上面的类图基本上是一样的，只不过在适配器类中发生了一点变化，它聚合了TFCard，也就是说聚合了现有组件库的组件，因为我们要读取的就是TF卡里面的数据。</p>
<p>也就是说现在咱们的适配器类是聚合进来了适配者类，而不是再去直接继承它了，这样，其实就满足了合成复用原则。</p>
<p>上面我说过了，类适配器模式是客户类有一个接口规范的情况下可用，反之则不可用。那么对于对象适配器模式来说，还是这样吗？如果我们没有定义SDCard接口，而只是就有一个类（即SDCardImpl），那么现在咱们的适配器类是不是直接去继承该类了啊？毕竟现在咱们的适配器类还没有继承任何类呢，它当然就可以去继承其他类了啊，你说是不是啊！</p>
<p>分析至此，相信大家能得出来一个结论，就是对象适配器模式将类适配器模式的两个缺点全部已经弥补了，可能这就是对象适配器模式在开发中用的多的原因吧！</p>
<p>分析完以上类图之后，接下来，我们就得通过具体的代码来实现了。</p>
<h4 id="5-2-4-2-实现"><a href="#5-2-4-2-实现" class="headerlink" title="5.2.4.2. 实现"></a>5.2.4.2. 实现</h4><p>首先，在com.meimeixia.pattern.adapter包下新建一个子包，即object_adapter，也即对象适配器模式的具体代码我们是放在了该包下。</p>
<p>然后，将class_adapter包下的全部代码拷贝到object_adapter包下，拷贝过来之后，接下来，我们只需要修改适配器类（即SDAdapterTF）和客户端类（即Client）的代码即可。</p>
<p>我们先修改一下适配器类（即SDAdapterTF）的代码吧！现在适配器类不用再继承适配者类了，而是应该聚合适配者类，这就意味着我们应该在适配器类的成员位置声明适配者类，当然这里我们是以接口的形式来声明的，因为这样的话通用性会更好一些。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.object_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 22:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明适配者类</span></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在适配器类的成员位置声明好了适配者类之后，我们肯定是要对它进行赋值的，所以，我们在这儿就提供了一个有参构造方法，</span></span><br><span class="line"><span class="comment">     * 通过该有参构造方法为适配者类赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card"</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF(); <span class="comment">// 如果我们使用适配器的话，那么真正的读取数据还是从TF卡里面去读取。所以，此处我们应调用TFCardImpl类里面的readTF方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        tfCard.writeTF(msg); <span class="comment">// 同理，此处我们应调用TFCardImpl类里面的writeTF方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们的需求是这样的，使用该计算机读取TF卡中的数据，那么又应该如何去读取呢？大家不妨好好思考一下。我们最终是不是还得调用Computer类里面的读取方法（即readSD）啊，但是该方法只能读取SD卡里面的数据，而且还有返回值，是不是啊！不过，readSD方法中需要的就是一个SDCard接口的子实现类对象，而恰巧的是咱们的适配器类正好实现了SDCard接口，所以我们就可以直接往readSD方法里面传递一个SDAdapterTF适配器类的对象了。</p>
<p>思考完了，代码不就是这样写出来了吗？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.adapter.object_adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建计算机对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 读取SD卡中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> computer.readSD(<span class="keyword">new</span> <span class="title class_">SDCardImpl</span>());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        <span class="comment">// 使用该电脑读取TF卡中的数据</span></span><br><span class="line">        <span class="comment">// 创建适配器类对象</span></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">sdAdapterTF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(<span class="keyword">new</span> <span class="title class_">TFCardImpl</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg1</span> <span class="operator">=</span> computer.readSD(sdAdapterTF);</span><br><span class="line">        System.out.println(msg1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，我们运行一下以上客户端类，来看一下是不是我们想要的结果。如下图所示，在分割线下面读取到的内容确实是TFCard read msg : hello world TFCard，可见确实是从TF卡里面读取到的数据。</p>
<p><img src="/./assets/1709450081669-f6013541-ab5a-48f6-8689-04c76a5b344f.png" alt="img"></p>
<p>至此，我们就使用对象适配器模式实现了电脑从TF卡里面去读取数据的需求。</p>
<p>很明显，对象适配器模式要比类适配器模式要好一些，因为它满足了两个要求：</p>
<ol>
<li><strong>符合合成复用原则</strong></li>
<li><strong>如果客户类没有接口规范的话，那么我们也可以去使用它</strong></li>
</ol>
<hr>
<h3 id="5-2-5-接口适配器模式"><a href="#5-2-5-接口适配器模式" class="headerlink" title="5.2.5. 接口适配器模式"></a>5.2.5. 接口适配器模式</h3><p>最后，我还讲一个注意事项，还有一种适配器模式是接口适配器模式，当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，让它去实现所有方法，只是没有具体的实现体，而此时我们只需要继承该抽象类即可。当然了，因为这种接口适配器模式实现起来比较简单，所以我在这儿就不做具体的代码演示了。</p>
<h3 id="5-2-6-应用场景"><a href="#5-2-6-应用场景" class="headerlink" title="5.2.6. 应用场景"></a>5.2.6. 应用场景</h3><p>适配器模式的应用场景，我总结下来了下面两个。</p>
<ol>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。不一致的话，按照开闭原则，我们应尽可能的不要去修改之前的系统，此时，我们就可以使用适配器模式了，即创建一个适配器，让我们的新旧系统进行一个无缝的对接</li>
<li>使用第三方提供的组件，但组件接口定义和我们自己要求的接口定义不同。很明显我们是无法修改第三方提供的组件的，既然无法修改，那么此时我们就可以使用适配器模式了，让第三方组件和我们自己做的系统进行一个无缝的对接</li>
</ol>
<hr>
<h3 id="5-2-7-适配器模式在JDK源码中的应用"><a href="#5-2-7-适配器模式在JDK源码中的应用" class="headerlink" title="5.2.7. 适配器模式在JDK源码中的应用"></a>5.2.7. 适配器模式在JDK源码中的应用</h3><p>接下来，我们来看一下适配器模式在JDK源码中具体的应用。</p>
<p>先来看一下下面两个类：</p>
<ol>
<li>Reader：字符输入流顶层父类</li>
<li>InputStream：字节输入流顶层父类</li>
</ol>
<p>它俩之间的一个适配使用的就是InputStreamReader。</p>
<p>什么意思呢？就是说将字节数据转换成字符数据，我们使用的就是转换流InputStreamReader。而InputStreamReader是继承自java.io包下的Reader的，并且对它里面的如下两个read方法给出了实现，如下图所示。</p>
<p><img src="/./assets/1709450081732-a0abbe0b-763b-448d-937e-6acd7171f11e.png" alt="img"></p>
<p>一个是未带任何参数的read方法，一个是带有三个参数的read方法，它们位于Reader类里面的如下位置。</p>
<p><img src="/./assets/1709450081702-7a12402d-722f-40b8-a38a-31d767e417a6.png" alt="img"></p>
<p>从上可以看到，未带任何参数的read方法已经被实现了，而带有三个参数的read方法还是抽象的未实现的，但不管怎样，子类（即InputStreamReader）最终还是实现（或者重写）了父类（即Reader）中的以上两个方法。</p>
<p>相信大家也能看到，在InputStreamReader类中，实现（或者重写）了父类（即Reader）中的两个read方法都是直接调用了sd对象里面的read方法。那么，有些同学就会问了，这个sd是什么东东啊？其实，它就是StreamDecoder类的对象。</p>
<p>StreamDecoder类是流的一个解码操作。大家还记得什么是解码和编码吗？不记得，我帮大家回忆回忆。</p>
<ul>
<li>解码：将字节数据转换成字符数据</li>
<li>编码：将字符数据转换成字节数据</li>
</ul>
<p>现在大家就清楚了，StreamDecoder类是用来解码的，也就是将字节数据转换成字符数据。</p>
<p>上面我也说过了，在InputStreamReader类中，实现（或者重写）了父类（即Reader）中的两个read方法都是直接调用了sd对象里面的read方法。现在，大家应该能明白，<strong>在Sun的JDK实现中，InputStreamReader类中的两个read方法的实际的方法实现是就对sun.nio.cs.StreamDecoder类的同名方法的调用封装</strong>。</p>
<p>接下来，我们来看下下面的这张类图。</p>
<p><img src="/./assets/1709450082009-2c11a37f-38aa-4677-939b-c6d03720c968.png" alt="img"></p>
<p>以上类图中有一个InputStream，上面我也说过了，它就是字节输入流顶层父类，从上可以看到它里面有三个重载的read方法。而在StreamDecoder类里面，它聚合了InputStream，此外，它还重写了父类（即Reader）中的两个read方法。</p>
<p>我讲到这里，你就会发现StreamDecoder其实就是一个适配器类，而该适配器类继承了Reader类（注意了，Reader其实是一个抽象类），相信你也不难看出Reader类代表的就是适配器模式里面的目标接口角色，只不过该角色在这儿是以抽象类的形式体现出来的。StreamDecoder类除了继承了以上目标接口之外，还聚合了适配者类（即InputStream），嘻嘻😝，这不就是标准的对象适配器模式吗？其实，老实来说，这儿的对象适配器模式和InputStreamReader这个类的关系并不是特别大，只是Reader、InputStream以及StreamDecoder这三个类用到了标准的对象适配器模式。</p>
<p>再来看一下以上类图，可以看到：</p>
<ul>
<li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装</li>
<li>StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现，但我们知道它们对构造方法中的字节流类（即InputStream）进行了封装，其实就是把字节输入流类（即InputStream）聚合进来了，最终并通过该类进行了字节流和字符流之间的解码转换。也就是说，虽然字节输入流类（即InputStream）读取到的是字节数据，但是最终我们可以通过StreamDecoder类将字节数据转换成字符数据并返回，这就是所谓的解码操作😀</li>
</ul>
<p>通过上面我们的研究与分析，我们最终可以得出这样一个结论：<strong>从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换（也就是说InputStreamReader把字节流转换成了字符流）。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式，而且还是对象适配器模式。</strong></p>
<hr>
<h2 id="5-3-装饰者模式"><a href="#5-3-装饰者模式" class="headerlink" title="5.3. 装饰者模式"></a>5.3. 装饰者模式</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1. 概述"></a>5.3.1. 概述</h3><p>在学习装饰者模式之前，我们先来看一个快餐店的例子。</p>
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么这样计算总价就会显得比较麻烦。比如说客户点一份炒面，他还要再加一个鸡蛋和一根火腿，那么计算总价的时候就会很麻烦。</p>
<p>假设我们现在要设计这么一个计算总价的系统的话，那么用传统的方式应该如何去做呢？是不是立马想到了要用继承的方式去做啊！这时，所设计出来的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%9B%BE&amp;spm=1001.2101.3001.7020">类图</a>就应该是下面这个样子的。</p>
<p><img src="/./assets/1709452045637-7a5d8e76-3809-44e9-8650-0c7e5bfc0d9b.png" alt="img"></p>
<p>最上面的是快餐类，它里面有两个成员变量，一个是price（即价格），一个是desc（即描述，例如炒饭的描述就是炒饭，炒面的描述就是炒面），当然还为它们提供了对应的getter和setter方法，此外，该快餐类里面还有一个cost方法，它就是用来计算快餐总价格的。</p>
<p>然后，快餐类又有两个子类，一个是炒饭类（即FiredRice），一个是炒面类（即FiredNoodles），它俩都有各自对应的无参构造，除此之外，它俩都重写了父类中的cost方法，以计算总价格。</p>
<p>由于对于炒饭和炒面来说，它们都可以加鸡蛋或者培根，所以我就又为它们设计了不同的子类，对于炒饭类来说，它有两个子类，分别是加鸡蛋的炒饭类（即EggFriedRice）和加培根的炒饭类（即BaconFriedRice）；对于炒面类来说，它也有两个子类，分别是加鸡蛋的炒面类（即EggFriedNoodles）和加培根的炒面类（即BaconFriedNoodles）。</p>
<p>以上就是我们用传统继承的方式来实现咱们快餐店的案例。</p>
<p>那么使用继承方式去实现的话，会存在一个什么样的问题呢？使用继承的方式所存在的问题：</p>
<ul>
<li>扩展性不好如果要再加一种配料（比如火腿肠），那么我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（比如炒河粉）的话，那么就需要定义更多的子类了。为什么这么说呢？假设我们在以上类图中新添加了一个炒河粉的子类，那么它肯定是要继承自快餐类的，此时，它下面就要有三个子类了，分别是加鸡蛋的炒河粉类、加培根的炒河粉类以及加火腿肠的炒河粉类，你会发现类爆炸的情况就出现了</li>
<li>产生过多的子类</li>
</ul>
<p>问题既然出现了，那么我们应该如何对上面的快餐店案例进行一个改进呢？此时，我们就可以使用装饰者模式了。那装饰者模式到底是什么呢？下面我们就来看看它的概念。</p>
<p>装饰者模式是指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<p>在以上快餐店案例中，对于炒饭来说，给其增加一个额外的职责，其实就是给其加一个鸡蛋或者培根或者火腿肠。因此，对于该案例而言，我们就可以使用装饰者模式了。</p>
<h3 id="5-3-2-结构"><a href="#5-3-2-结构" class="headerlink" title="5.3.2. 结构"></a>5.3.2. 结构</h3><p>装饰者（Decorator）模式中的角色有如下四个：</p>
<ul>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。注意，此处的抽象接口既可以是接口也可以是抽象类。该角色对应以上快餐店案例中的快餐类</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。例如，以上快餐店案例中的炒饭类、炒面类都属于具体构建角色</li>
<li>抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例（也就是说将其聚合进来了），可以通过其子类扩展具体构件的功能。所以，装饰者模式巧妙就巧妙在这个位置</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</li>
</ul>
<p>省流总结:同类A组合同类B,从而增强B的功能</p>
<hr>
<h3 id="5-3-3-装饰者模式案例"><a href="#5-3-3-装饰者模式案例" class="headerlink" title="5.3.3. 装饰者模式案例"></a>5.3.3. 装饰者模式案例</h3><p>上面我们学习了装饰者模式的概念，以及知道了它里面所具有的角色。接下来，我们就使用装饰者模式来对以上快餐店案例进行一个改进，以此体会装饰者模式的精髓。</p>
<h4 id="5-3-3-1-分析"><a href="#5-3-3-1-分析" class="headerlink" title="5.3.3.1. 分析"></a>5.3.3.1. 分析</h4><p>咱们先看下下面的这张类图。</p>
<p><img src="/./assets/1709541427636-f273856a-6d69-41eb-8d02-55076263b633.png" alt="img"></p>
<p>先，我们应该明确要有一个快餐类，而且它还要是一个抽象类，它里面有两个成员变量，一个是price（即价格），一个是desc（即描述），当然还为它们提供了对应的getter和setter方法，此外，该快餐类里面还有一个cost方法，它就是用来计算快餐总价格的，当然该方法是抽象的，需要由子类具体来实现。</p>
<p>然后，快餐类又有两个子类，一个是炒饭类（即FiredRice），一个是炒面类（即FiredNoodles），它俩都有各自对应的无参构造，除此之外，它俩都重写了父类中的cost方法，以计算总价格。</p>
<p>以上类图的左半边部分我们分析完了之后，再来分析一下右半边部分。</p>
<p>可以看到有一个Garnish类，它是一个核心类，即装饰者。作为装饰者，首先它要去继承快餐类（即FastFood），并又聚合该类的对象，这样，我们就得为其提供一个有参构造和相应的getter、setter方法了。</p>
<p>接着，咱们的配料类，比如Egg、Bacon，就得提供对应的有参构造给父类（即Garnish）中的FastFood对象进行赋值了，并且还得重写父类中的cost方法和getDesc方法。重写父类中的cost方法好理解，就是为了计算总价，那为啥还要重写父类中的getDesc方法呢？这是因为如果某个快餐加了鸡蛋（或者培根）的话，那么它的描述肯定是不同了，所以我们就得重写父类中的getDesc方法来获取最终的一个描述了。</p>
<p>经过以上分析，大家一定要清楚，Garnish是最核心的一个类，它不仅继承了FastFood类还聚合了FastFood类。</p>
<p>分析完了以后，接下来，我们就要开始编写代码实现以上案例了。</p>
<h4 id="5-3-3-2-实现"><a href="#5-3-3-2-实现" class="headerlink" title="5.3.3.2. 实现"></a>5.3.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即decorator，也即装饰者模式的具体代码我们是放在了该包下。</p>
<p>然后，创建快餐类，这里我们命名为FastFood。注意，该类是一个抽象类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快餐类(抽象构件角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 13:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">private</span> String desc; <span class="comment">// 描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> {</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> {</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> {</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 计算总价。注意，该方法是一个抽象的方法，这是因为只有我们知道了具体的快餐之后，才能计算出来它的价格。</span></span><br><span class="line"><span class="comment">     * 例如，如果客户点的是炒饭，而一碗炒饭又是10块钱，那么最终返回的就是10块钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建两个快餐类的子类，一个是炒饭类，这里我们命名为FriedRice。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 炒饭类(具体构件角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 13:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在FriedRice类中，我们只需要给它提供一个无参的构造方法就可以了，但是我们得通过该无参构造给父类中的两个成员变量进行赋值。</span></span><br><span class="line"><span class="comment">     * 如果客户选择的是炒饭，而炒饭的价格又是固定的，比如10块钱，那么代码就应该向下面这样写。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">"炒饭"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> getPrice(); <span class="comment">// 由于我们刚才已经定义好了炒饭的价格是10块钱，所以此处我们直接调用</span></span><br><span class="line">        <span class="comment">// 父类中的getPrice方法就能获取到价格了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，如果我们想要点一份炒饭，那么是不是只需要创建FriedRice类的对象就可以了啦！而且这样就会自动将炒饭的价格设置为10块钱，描述那当然就是炒饭了啊！最终，我们去计算一份炒饭的餐费的话，那就是10块钱了，这是非常合情合理的。</p>
<p>FriedRice类还要一个子类，就是炒面类，这里我们命名为FriedNoodles。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 炒面类(具体构件角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 13:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在FriedNoodles类中，我们只需要给它提供一个无参的构造方法就可以了，但是我们得通过该无参构造给父类中的两个成员变量进行赋值。</span></span><br><span class="line"><span class="comment">     * 如果客户选择的是炒面，而炒面的价格又是固定的，比如12块钱，那么代码就应该像下面这样写。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">"炒面"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> getPrice(); <span class="comment">// 由于我们刚才已经定义好了炒面的价格是12块钱，所以此处我们直接调用</span></span><br><span class="line">        <span class="comment">// 父类中的getPrice方法就能获取到价格了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建最核心的类，即Garnish，它就是装饰者类。对于该装饰者类，大家一定要注意它设计的一个原则，就是它得去继承FastFood类，虽说是去继承，但是在这里我们就不重写它里面的方法了。注意了，我们应该将该装饰者类定义成抽象的。为什么呢？因为快餐具体要加哪种配料，我们是不明确的，不明确的话，那么总价就无法进行计算了，所以我们就需要把该装饰者类定义成抽象类了。</p>
<p>你觉得该装饰者类属于装饰者模式里面的哪种角色呢？很明显，它属于抽象装饰角色。注意了，上面我们还没说完Garnish类设计的原则呢，下面我们接着来说。</p>
<p>Garnish类除了要去继承FastFood类之外，还得聚合FastFood类的对象，所以我们就得在Garnish类的成员位置声明FastFood类的变量了，这是装饰者模式的一个显著特点。记住，定义完FastFood类型的成员变量之后，还得为其对应的getter和setter方法。</p>
<p>这样，Garnish类的代码就呼之欲出了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者类(抽象装饰者角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 13:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明快餐类的变量</span></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> {</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在Garnish类中，我们还得提供如下有参构造，价格与描述这两属性是直接调用父类中的方法来进行设置的，</span></span><br><span class="line"><span class="comment">     * 至于FastFood类型的属性，懂得都懂！！！</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意，后面的两个参数所代表的意思。</span></span><br><span class="line"><span class="comment">     *      float price：配料（例如鸡蛋）的价格。例如，一个炒鸡蛋是1块钱</span></span><br><span class="line"><span class="comment">     *      String desc：配料（例如鸡蛋）的描述。例如，鸡蛋的描述肯定就是鸡蛋了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> {</span><br><span class="line">        <span class="built_in">super</span>(price, desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>装饰者类创建完毕之后，接下来，我们就得开始创建配料类了。第一个配料类是鸡蛋类，即Egg，注意了，它得继承Garnish装饰者类。</p>
<p>继承完了之后，我们得来思考一下，对于该鸡蛋类来说，我们肯定是要提供构造方法的，那么是提供有参的构造方法还是无参的构造方法呢？很明显是提供有参的构造方法，因为我们还得给父类中的快餐类成员变量进行赋值呢！你不可能只要配料而不要具体的快餐吧！比如说你就去快餐店只点两个炒鸡蛋，而不来一份炒饭，当然了，你非得干吃两个炒鸡蛋那也不是不可以，只是这种情况很少很少。</p>
<p>除此之外，在该鸡蛋类中，我们还得重写父类中的cost方法以便计算快餐加配料之后的总价。如何来重写父类中的cost方法呢？很简单，鸡蛋的价格加上快餐的价格就计算出来了。</p>
<p>重写完父类中的cost方法之后，注意了，我们还得重写父类中的getDesc方法，重写也很简单，就是鸡蛋的描述拼接上快餐的描述就行了。</p>
<p>这样，第一个配料类（即Egg）的代码就呼之欲出了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鸡蛋类(具体的装饰者角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 13:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> {</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">1</span>, <span class="string">"鸡蛋"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 计算价格</span></span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().cost();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同理，第二个配料类（即Bacon）的代码就不难写出了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 培根类(具体的装饰者角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 13:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> {</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">2</span>, <span class="string">"培根"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 计算价格</span></span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().cost();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们就要编写一个客户端类来测试一下了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">// 打印炒饭的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，如下图所示，可以看到打印的炒饭的价格确实是10块钱，因为我们之前对炒饭的价格设置就是10块钱。</p>
<p><img src="/./assets/1709452045647-fada7706-7781-4da5-a783-fdf7a0ed4177.png" alt="img"></p>
<p>如果我们此时想在上面的炒饭里面加上一个炒鸡蛋，那么应该怎么去做呢？测试代码是不是应该像下面这样啊！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">// 打印炒饭的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 在上面的炒饭中加一个鸡蛋</span></span><br><span class="line">        food = <span class="keyword">new</span> <span class="title class_">Egg</span>(food);</span><br><span class="line">        <span class="comment">// 打印炒饭加上鸡蛋之后的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再运行以上客户端类，如下图所示，可以看到炒饭加了一个鸡蛋之后，总价确实变成了11块钱。</p>
<p><img src="/./assets/1709452045589-60623c8e-2d9d-48e2-b8b6-581320b15705.png" alt="img"></p>
<p>现在我还能在以上鸡蛋炒饭里面再加上一个炒鸡蛋吗？显然是可以的啊！测试代码如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">// 打印炒饭的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 在上面的炒饭中加一个鸡蛋</span></span><br><span class="line">        food = <span class="keyword">new</span> <span class="title class_">Egg</span>(food);</span><br><span class="line">        <span class="comment">// 打印炒饭加上鸡蛋之后的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 再加一个鸡蛋</span></span><br><span class="line">        food = <span class="keyword">new</span> <span class="title class_">Egg</span>(food);</span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再运行以上客户端类，如下图所示，可以看到鸡蛋炒饭加了一个炒鸡蛋之后，总价确实变成了12块钱。</p>
<p><img src="/./assets/1709452045624-0334ca75-1401-4618-85d3-beb39e2a1ba1.png" alt="img"></p>
<p>那么我们还能再给以上鸡蛋鸡蛋炒饭加一根培根吗？显然是可以的啊！测试代码如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">// 打印炒饭的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 在上面的炒饭中加一个鸡蛋</span></span><br><span class="line">        food = <span class="keyword">new</span> <span class="title class_">Egg</span>(food);</span><br><span class="line">        <span class="comment">// 打印炒饭加上鸡蛋之后的价格与描述</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 再加一个鸡蛋</span></span><br><span class="line">        food = <span class="keyword">new</span> <span class="title class_">Egg</span>(food);</span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        <span class="comment">// 再加一个培根</span></span><br><span class="line">        food = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food);</span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">" "</span> + food.cost() + <span class="string">"元"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再运行以上客户端类，如下图所示，可以看到鸡蛋鸡蛋炒饭加了一根培根之后，总价确实变成了14块钱。</p>
<p><img src="/./assets/1709452046662-8f15e199-0d2a-40ef-b07b-420d209ad411.png" alt="img"></p>
<p>当然，对于炒面，你也可以参照以上代码再去进行测试，只不过这里我就略过了。</p>
<p>最终，你会发现使用装饰者模式设计出来的系统会特别特别灵活，如果此时我们想要再去新增一个配料的话，例如火腿肠，那么我们只需要再去定义一个火腿肠类，然后让它去继承装饰者类就可以了。</p>
<hr>
<h3 id="5-3-4-装饰者模式的好处以及使用场景"><a href="#5-3-4-装饰者模式的好处以及使用场景" class="headerlink" title="5.3.4. 装饰者模式的好处以及使用场景"></a>5.3.4. 装饰者模式的好处以及使用场景</h3><h4 id="5-3-4-1-好处"><a href="#5-3-4-1-好处" class="headerlink" title="5.3.4.1. 好处"></a>5.3.4.1. 好处</h4><p>装饰者模式的好处，我总结出来了如下两个。</p>
<ol>
<li>装饰者模式可以带来比继承更加灵活性的扩展功能（这是因为装饰者模式本身就是在原有的基础上进行了一个扩展），使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果（比如说，你可以在炒饭的基础上加鸡蛋、加培根）。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任</li>
<li>装饰者类和被装饰者类可以独立发展，不会相互耦合，装饰者模式是继承的一个替代模式，装饰者模式可以动态扩展一个实现类的功能。上面这句话说的是啥意思啊？我用上面的快餐店案例来给大家详细解释一下。如果现在我们要再添加一种品类的快餐的话，例如炒河粉，那么是不是只需要再去定义一个炒河粉类，然后让它直接去继承FastFood类就可以了啊？而如果此时我们想要再去添加一个配料的话，例如火腿肠，那么是不是只需要再去定义一个火腿肠类，然后让它去继承装饰者类就可以了啊？这样，装饰者类和被装饰者类不就可以独立发展了嘛！而且它们还不会相互耦合</li>
</ol>
<h4 id="5-3-4-2-使用场景"><a href="#5-3-4-2-使用场景" class="headerlink" title="5.3.4.2. 使用场景"></a>5.3.4.2. 使用场景</h4><p>装饰者模式的使用场景，我总结出来了如下三个。</p>
<ol>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时，我们就可以使用装饰者模式了。不能采用继承的情况主要有两类：</li>
</ol>
<ul>
<li><ul>
<li>第一类是系统中存在大量独立的扩展（比如说配料或者快餐的品种），为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。而定义太多的子类会让系统变得更加的复杂</li>
<li>第二类是因为类定义不能继承（如final类）</li>
</ul>
</li>
</ul>
<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。哎，动态地撤销又该怎么去理解呢？我用上面的快餐店案例再来给大家详细解释一下。快餐店里面的鸡蛋卖完了之后，我们只需要动态地把Egg这个子类移除掉就可以了；又买了一些鸡蛋之后，再将该子类添加上就行，这就是所谓的动态地添加和撤销</li>
</ol>
<h3 id="5-3-5-装饰者模式在JDK源码中的应用"><a href="#5-3-5-装饰者模式在JDK源码中的应用" class="headerlink" title="5.3.5. 装饰者模式在JDK源码中的应用"></a>5.3.5. 装饰者模式在JDK源码中的应用</h3><p>接下来，我们来看下装饰者模式在JDK源码里面是如何应用的？</p>
<p>IO流中的包装类使用到了装饰者模式。而哪些属于包装类呢？像BufferedInputStream、BufferedOutputStream、BufferedReader以及BufferedWriter等这些都属于包装类。也就是说这些类都用到了装饰者模式。下面我们就以BufferedWriter举例来说明一下。</p>
<p>我们不妨先看看如何使用BufferedWriter类吧！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="comment">// 创建BufferedWriter对象</span></span><br><span class="line">        <span class="comment">// 创建FileWriter对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"C:\\Users\\liayun\\Desktop\\a.txt"</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        bw.write(<span class="string">"Hello Buffered"</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码很简单，我们是要去创建BufferedWriter对象的，但是其构造方法里面需要一个Writer的子实现类对象，所以我们得提前创建一个FileWriter对象，并把它作为参数进行一个传递。然后，我们就能使用缓冲流里面的write方法进行数据的一个写出操作了，最后就是释放资源。</p>
<p>当然以上代码我在这里就不给大家运行演示了，如果你要是有兴趣的话，不妨私下自己去跑一跑。</p>
<p>简单使用了一下BufferedWriter类之后，你会发现它使用起来感觉确实像是装饰者模式，那么到底是不是呢？我们来看一下下面这张类图。</p>
<p><img src="/./assets/1709452046677-019f1da8-b60f-4fa1-a367-15b6421922ae.png" alt="img"></p>
<p>可以看到，顶层父类是Writer，它是字符输出流的顶层父类，并且它还有几个子类，一个子类是InputStreamWriter（该类下面又有一个子类，即FileWriter），一个子类是BufferedWriter。</p>
<p>你注意看，BufferedWriter类同时又聚合了Writer类，也就是说BufferedWriter类不仅继承自Writer类，并且还聚合了Writer类，这很明显就是装饰者模式，装饰者模式的巧妙之处就在于这。</p>
<p>至此，通过以上类图，我们就分析出了BufferedWriter类确实是用到了装饰者模式。至于其他的几个类，大家有兴趣的话，可以自己去查看一下它们的源代码，看一下它们是不是也用到了装饰者模式，只是我在这里就不赘述了。</p>
<p>最后，我做一个小结，BufferedWriter使用装饰者模式对Writer子实现类进行了增强，即添加了缓冲区，提高了写数据的效率。</p>
<hr>
<h3 id="5-3-6-装饰者模式和静态代理的区别"><a href="#5-3-6-装饰者模式和静态代理的区别" class="headerlink" title="5.3.6. 装饰者模式和静态代理的区别"></a>5.3.6. 装饰者模式和静态代理的区别</h3><p>接下来，我们来说说静态代理和装饰者模式的一个区别，因为它俩很像很像，不熟悉它俩之间区别的人很容易把它们搞混到一块去。</p>
<h4 id="5-3-6-1-相同点"><a href="#5-3-6-1-相同点" class="headerlink" title="5.3.6.1. 相同点"></a>5.3.6.1. 相同点</h4><p>装饰者模式和静态代理的相同点：</p>
<ol>
<li>都要实现与目标类相同的业务接口。这是说的啥意思呢？我们不妨往上看一下上面的快餐点案例的类图，可以看到都得去继承（或者实现）FastFood抽象类，是不是啊？</li>
<li>在两个类中都要声明目标对象。也就是说，都要把你继承的那个类的子类对象给聚合进来</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ol>
<p>以上几点看下来，静态代理和装饰者模式是不是特像啊！</p>
<h4 id="5-3-6-2-不同点"><a href="#5-3-6-2-不同点" class="headerlink" title="5.3.6.2. 不同点"></a>5.3.6.2. 不同点</h4><p>装饰者模式和静态代理的不同点：</p>
<ol>
<li>目的不同。装饰者模式是为了增强目标对象，而静态代理是为了保护和隐藏目标对象。这话什么意思呢？回顾一下使用装饰者模式实现的快餐店案例的代码，在装饰者类（即Garnish）中，是不是声明了一个FastFood类型的成员变量啊！你注意了，在这儿我们并没有对该成员变量进行赋值，那么它应该由谁来赋值呢？谁使用，谁就对该成员变量进行赋值；而如果是静态代理的话，那么在这一块就是直接创建一个FastFood对象，并将其赋值给该成员变量了，这就相当于是保护和隐藏了目标对象</li>
<li>获取目标对象构建的地方不同。装饰者模式是由外界传递进来的，可以通过构造方法传递，当然我们也可以通过setter方法进行一个传递；而静态代理是在代理类内部创建的，也就是说如果代理类是Garnish这个类的话，那么在成员变量处就直接创建了FastFood对象，这样做的目的就是为了隐藏目标对象</li>
</ol>
<hr>
<h2 id="5-4-桥接模式"><a href="#5-4-桥接模式" class="headerlink" title="5.4. 桥接模式"></a>5.4. 桥接模式</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1. 概述"></a>5.4.1. 概述</h3><p>在向大家讲解桥接模式之前，我们先来看一个例子。</p>
<p>现在有一个需求，需要创建不同的图形，例如圆、长方形、正方形等等，并且每个图形都有可能会有不同的颜色，这样，我们就可以利用继承的方式来设计类之间的关系了。</p>
<p><img src="/./assets/1709469809009-dafbc6f1-f273-434e-a95e-8d7c9c5f811c.png" alt="img"></p>
<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色的话，你会发现需要创建更多的子类，极有可能会出现类爆炸的现象。</p>
<p>试想，在一个有多种可能会变化的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BB%B4%E5%BA%A6&amp;spm=1001.2101.3001.7020">维度</a>的系统中，用继承方式势必就会造成类爆炸的现象，扩展起来也不灵活，即使它满足了开闭原则。每次在一个维度上新增一个具体实现都要增加多个子类。此时，为了更加灵活的设计系统，我们便可以考虑使用桥接模式了。</p>
<p>那什么是桥接模式呢？下面我们来看一看它的概念。</p>
<p>桥接模式是指将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>有些同学看了桥接模式的概念之后，不明白什么叫抽象和实现，所以这里我给大家稍微解释一下。其实，抽象和实现就是两个维度，以上面的例子来说，图形的变化就是一个维度，而每一个图形颜色的变化就是另外一个维度，因此抽象和实现指的就是这两种维度的不同的变化。</p>
<h3 id="5-4-2-结构"><a href="#5-4-2-结构" class="headerlink" title="5.4.2. 结构"></a>5.4.2. 结构</h3><p>桥接模式的概念了解清楚之后，下面我们来看一下桥接模式里面有哪些角色？</p>
<p>桥接（Bridge）模式包含以下主要角色：</p>
<ul>
<li>抽象化（Abstraction）角色：定义抽象类，并且该抽象类还包含了一个对实现化对象的引用，也就是说该抽象类把实现化角色对象给聚合进来了</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。因为在父类中已经聚合了实现化角色对象，所以我们就可以调用实现化角色对象里面的业务方法了</li>
<li>实现化（Implementor）角色：定义实现化角色的接口（注意，这里可以是接口也可以是抽象类），供扩展抽象化角色调用</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现</li>
</ul>
<p>以上角色可能大家还不是特别理解，等会我们就通过一个具体的案例来深入理解一下桥接模式的概念以及其里面的角色。</p>
<h3 id="5-4-3-桥接模式案例"><a href="#5-4-3-桥接模式案例" class="headerlink" title="5.4.3. 桥接模式案例"></a>5.4.3. 桥接模式案例</h3><p>接下来，我就以一个视频播放器的案例来为大家讲解桥接模式了。</p>
<h4 id="5-4-3-1-分析"><a href="#5-4-3-1-分析" class="headerlink" title="5.4.3.1. 分析"></a>5.4.3.1. 分析</h4><p>我们先来看一下具体的需求：现在需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，而常见的视频文件格式包括RMVB、AVI、WMV等，这样，该播放器就包含了两个维度，操作系统属于一个维度，因为操作系统有分Windows、Mac、Linux等，视频文件又属于一个维度，因为视频文件有RMVB、AVI、WMV等格式的。所以，在这里我们就能使用桥接模式进行一个实现了。</p>
<p>然后，大家来看一下下面的这张类图。</p>
<p><img src="/./assets/1709469808476-62c58961-64d2-4496-836b-4ae789c4bb88.png" alt="img"></p>
<p>在以上类图的右边部分可以看到，有一个VideoFile接口，该接口就是实现化角色，当然了，你也可以将其定义成抽象类，只不过在这儿咱们是以接口的形式体现出来的。而且，该接口里面定义有一个decode方法专门用于进行解码，从上图中可以看到，解码时我们还需要向decode方法里面传递一个字符串类型的参数（即fileName），也就是视频文件的文件名。</p>
<p>从上图中还可以看到，VideoFile接口还有两个子实现类，一个是AVIFile，一个是RMVBFile，它俩都重写了父接口中的抽象方法，所以很明显它俩就是具体实现化角色。</p>
<p>明确以上类图的右边部分之后，咱们再来看一下左边部分。首先，有一个操作系统类（即OperatingSystem），它聚合了VideoFile接口，这也就意味着它是一个抽象化角色，因为抽象化角色是需要聚合实现化角色的。而桥接模式的巧妙之处主要就体现在这。</p>
<p>此外，该操作系统类同样也有两个子类，一个是Windows，一个是Mac，它俩都有各自对应的有参构造，并且它俩都重写了父类中的play方法，以便进行视频文件的一个播放。</p>
<p>以上类图分析完了以后，接下来，我们就要开始编写代码实现以上案例了。</p>
<h4 id="5-4-3-2-实现"><a href="#5-4-3-2-实现" class="headerlink" title="5.4.3.2. 实现"></a>5.4.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即bridge，也即桥接模式的具体代码我们是放在了该包下。</p>
<p>然后，创建一个接口，该接口我们就命名为VideoFile。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频文件（实现化角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 16:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建VideoFile接口的子实现类。我们先创建第一个子实现类，名字就起为AviFile，在该子实现类里面我们肯定是要去重写其父接口中的decode方法的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * avi视频文件（具体的实现化角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AviFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> {</span><br><span class="line">        System.out.println(<span class="string">"avi视频文件："</span> + fileName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建第二个子实现类，名字就起为RmvbFile，同理，该子实现类也要去重写其父接口中的decode方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rmvb视频文件（具体的实现化角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmvbFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> {</span><br><span class="line">        System.out.println(<span class="string">"rmvb视频文件："</span> + fileName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>截至到这里，我们就定义好了实现化角色和具体实现化角色。</p>
<p>紧接着，创建操作系统类，这里我们将其命名为OperatingSystem，注意，该类是一个抽象类。</p>
<p>在该类里面，我们要先声明VideoFile接口类型的变量，因为表示抽象化角色的该类要聚合表示实现化角色的VideoFile接口，这一点我在分析以上类图时就已经讲过了。注意，在OperatingSystem类里面声明VideoFile接口类型的变量时，我们不妨就使用protected权限修饰符，此时，只有其子类才可以直接继承使用。</p>
<p>声明完之后，在OperatingSystem类里面我们还得为其提供一个有参的构造方法，通过该有参构造给VideoFile接口类型的变量赋值。</p>
<p>不要忘了，在OperatingSystem类里面我们还得定义一个抽象的方法，专门用于播放视频文件。大家可能会问，为什么该方法要定义成抽象的呢？因为我们现在暂时还不明确该操作系统到底是Windows操作系统呢，还是Mac操作系统。</p>
<p>这样，OperatingSystem类的代码就呼之欲出了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的操作系统类（抽象化角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystem</span> {</span><br><span class="line">    <span class="comment">// 声明VideoFile变量</span></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystem</span><span class="params">(VideoFile videoFile)</span> {</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>抽象化角色定义好之后，接下来，我们来定义扩展抽象化角色。</p>
<p>从以上类图中得知，表示扩展抽象化角色的类有两个，一个是Windows，一个是Mac，它俩都得继承以上OperatingSystem类，并重写它里面的抽象方法（即play）。问题是如何重写该抽象方法呢？很简单，如果要播放视频文件的话，那么直接调用VideoFile接口类型对象里面的decode方法对视频文件进行一个解码就可以播放了，是不是啊！除此之外，它俩还得提供各自对应的有参构造为父类中声明的VideoFile接口类型的变量进行赋值。</p>
<p>这样，Windows操作系统类的代码就应该是下面这个样子的了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Windows操作系统（扩展抽象化角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 16:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> {</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> {</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同理，Mac操作系统类的代码就不难写出来了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mac操作系统（扩展抽象化角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> {</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> {</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个客户端类进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建Mac操作系统对象，注意，在创建时我们还得传递一个具体实现化角色对象，也就是告诉操作系统应播放什么格式的视频文件</span></span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">system</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mac</span>(<span class="keyword">new</span> <span class="title class_">AviFile</span>());</span><br><span class="line">        <span class="comment">// 使用操作系统播放视频文件</span></span><br><span class="line">        system.play(<span class="string">"战狼3"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类的测试代码，如下图所示，打印结果是avi视频文件：战狼3，这说明Mac操作系统可以播放AVI格式的视频文件。</p>
<p><img src="/./assets/1709469809070-ce2bd69a-e5fb-4c69-969d-8b809feae8c0.png" alt="img"></p>
<p>当然，如果你要去播放其它格式（比如RMVB）的视频文件的话，那么在创建Mac操作系统对象时，给其传递RmvbFile对象就可以了。</p>
<p>至此，使用桥接模式我们就实现了以上案例，通过这个案例，相信大家对桥接模式的概念及其所包含的角色有了一个更加深刻的认识，因为桥接模式里面所包含的角色确实有点抽象，令人难以理解！</p>
<hr>
<h3 id="5-4-4-桥接模式的好处以及使用场景"><a href="#5-4-4-桥接模式的好处以及使用场景" class="headerlink" title="5.4.4. 桥接模式的好处以及使用场景"></a>5.4.4. 桥接模式的好处以及使用场景</h3><p>接下来，我们来看看桥接模式的好处以及使用场景。</p>
<h4 id="5-4-4-1-好处"><a href="#5-4-4-1-好处" class="headerlink" title="5.4.4.1. 好处"></a>5.4.4.1. 好处</h4><p>桥接模式的好处，我总结出来了下面两个。</p>
<ol>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。例如，如果现在还有一种视频文件类型WMV，那么我们只需要再定义一个类实现VideoFile接口即可，其他类则不需要发生变化；如果现在还有一种操作系统Linux，那么我们只需要再定义一个类继承OperatingSystem抽象类即可，其他类则不需要发生变化。这样，系统的可扩展性就会比较好，而且我们在去添加子类时，也不需要添加太多的类，在这一过程中，由于其他类不需要发生变化，所以也满足了开闭原则</li>
<li>实现细节对客户透明</li>
</ol>
<h4 id="5-4-4-2-使用场景"><a href="#5-4-4-2-使用场景" class="headerlink" title="5.4.4.2. 使用场景"></a>5.4.4.2. 使用场景</h4><p>桥接模式的使用场景，我总结出来了下面三个。</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。此时，我们应避免在两个层次之间建立静态的继承联系，而是通过桥接模式使它们在抽象层建立一个关联关系，注意了，这里面主要指的是聚合关系。总之，应尽量避免去使用继承，因为上面已经说过了，虽然使用继承确实可行，但是它会导致类爆炸的现象发生</li>
</ol>
<hr>
<h2 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5. 外观模式"></a>5.5. 外观模式</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1. 概述"></a>5.5.1. 概述</h3><p>在向大家讲解外观模式之前，我们先来看一个例子。</p>
<p>有些人可能炒过股票，但其实大部分人都是不太懂里面的一些操作的，这种没有足够了解证券知识的情况下炒股票是很容易亏钱的，刚开始炒股时我们肯定都会想，如果有个懂行的帮帮手就好了，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构则是收取一定比例的托管管理费用。其实，</p>
<p>其实，以上所讲述的例子就用到了外观模式，这话又该怎么去理解呢？大家不妨思考一下，如果我们直接去买基金或者找专业的经理人，那么我们就不需要去了解股票具体的一些操作了，而且也不需要额外去了解债券、外汇等这些知识了，我们只需要把咱的资金交由经理人或者基金就行，至于经理人或者基金到底是投资股票，还是债券，还是外汇，我们并不需要去关注。这种思想就是今天我要讲的外观模式。</p>
<p>那到底什么是外观模式呢？接下来，我们就来看看外观模式的概念。</p>
<p>外观模式又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一的接口（你可以将其理解为上例中的基金，具体基金里面到底是投资股票，还是债券，还是外汇，咱们并不关注，因为这是由子系统来实现的），外部应用程序不用关心内部子系统的具体的细节，这样就大大降低了应用程序的复杂度，并提高了程序的可维护性。</p>
<p>还有一点需要大家知道，外观（Facade）模式是”迪米特法则”的典型应用。我们可以来看一下下面这张图。</p>
<p><img src="/./assets/1709469877076-900669f8-dd60-4187-b6c5-1579235bd1b5.jpeg" alt="img"></p>
<p>先看上图左边部分，大的矩形表示的就是一个子系统，子系统里面有很多很多的类，对于访问者来说，只有了解了子系统里面的实之后，他才能更好的去使用子系统，这是在没有使用外观模式的情况下对子系统的一个访问，很明显，这增加了访问者访问的难度。</p>
<p>再来看上图右边部分，这是在使用外观模式的情况下对子系统的一个访问，此时，对于访问者来说，他并不需要去关注这个子系统里面是如何实现的，而是只需要去调用对外提供的统一的接口就可以正常的去访问它了，比如上面我所讲述的基金，炒股者只需要去了解基金就可以了，至于基金最终到底是去投资股票，还是债券，还是外汇，炒股者并不需要去关注，这样是不是就可以大大地降低了访问者使用子系统类的一个成本啊？其实，这也是外观模式的一个好处。</p>
<h3 id="5-5-2-结构"><a href="#5-5-2-结构" class="headerlink" title="5.5.2. 结构"></a>5.5.2. 结构</h3><p>理解了外观模式的概念之后，接下来，我们来看一下外观模式所包含的角色。</p>
<p>外观（Facade）模式包含以下主要角色：</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ul>
<p>这样，对于访问者来说，他并不需要去关注子系统，而只需要关注外观角色就行，因为我们到时候是要通过外观角色去使用子系统里面的那些对象的。</p>
<h3 id="5-5-3-外观模式案例"><a href="#5-5-3-外观模式案例" class="headerlink" title="5.5.3. 外观模式案例"></a>5.5.3. 外观模式案例</h3><p>接下来，我们来实现一个外观模式的案例，通过该案例大家再去理解一下外观模式，这个案例就是智能家电控制。</p>
<h4 id="5-5-3-1-分析"><a href="#5-5-3-1-分析" class="headerlink" title="5.5.3.1. 分析"></a>5.5.3.1. 分析</h4><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了一个智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。</p>
<p>阅读完上面的描述，我们知道智能音箱代表的就是外观角色，客户只需要和这个智能音箱进行交互即可。</p>
<p>下面我们再来看一下这张类图。</p>
<p><img src="/./assets/1709469877098-0c8febd3-3a87-4ad6-aecc-870552ee2203.png" alt="img"></p>
<p>从以上类图中可以看到，有一个电灯类（即Light），它里面有两个方法，一个是开启电灯（即on方法），一个是关闭电灯（即off方法）；也有一个电视类（即TV），它里面也有两个方法，一个是开启电视（即on方法），一个是关闭电视（即off方法）；还有一个空调类（即AirCondition），它里面也是有两个方法，一个是开启空调（即on方法），一个是关闭空调（即off方法）。</p>
<p>以上类都不太重要，重要的是SmartAppliancesFacade类，它是一个外观类，它里面聚合了Light、TV、AirCondition等等这些类；除此之外，它里面还提供了一个无参构造及say方法，通过该say方法，我们就可以通过语音直接控制这些智能家电的开启和关闭了；最后，它里面还提供了两个方法，一个是用来一键开启所有智能家电的（即on方法），一个是用来一键关闭所有智能家电的（即off方法），注意了，这俩方法都是私有的，因为这俩方法都只在say方法里面被调用。</p>
<p>以上类图分析完了以后，接下来，我们就要开始编写代码实现以上案例了。</p>
<h4 id="5-5-3-2-实现"><a href="#5-5-3-2-实现" class="headerlink" title="5.5.3.2. 实现"></a>5.5.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即facade，也即外观模式的具体代码我们是放在了该包下。</p>
<p>然后，创建电灯类，即Light。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电灯类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 19:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开灯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"打开电灯......"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关灯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"关闭电灯......"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建电视机类，即TV。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电视机类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 19:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"打开电视机......"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"关闭电视机......"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建空调类，即AirCondition。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空调类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 19:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"打开空调......"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"关闭空调......"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再接着，创建智能音箱类，这里我们不妨起名为SmartAppliancesFacade。注意了，该类就是外观类，用户主要就是和该类对象进行交互。</p>
<p>经过对以上类图的分析，也相信大家能写出该类的代码来，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外观类，用户主要和该类对象进行交互</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 19:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合电灯对象、电视机对象、空调对象</span></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以上只是声明了三个成员变量，但是它们都还未赋值具体的对象，所以我们可以在SmartAppliancesFacade类</span></span><br><span class="line"><span class="comment">     * 中定义一个如下的无参的构造方法，在该无参构造里面为它们赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> {</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过语音控制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="keyword">if</span> (message.contains(<span class="string">"打开"</span>)) { <span class="comment">// 若用户说的语言里面包含了打开这样的一个字眼，则调用on方法一键打开所有智能家电</span></span><br><span class="line">            on();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (message.contains(<span class="string">"关闭"</span>)) { <span class="comment">// 若用户说的语言里面包含了关闭这样的一个字眼，则调用off方法一键关闭所有智能家电</span></span><br><span class="line">            off();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"我还听不懂你说的！！！"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一键打开功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> {</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一键关闭功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> {</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个客户端类来进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-31 19:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建智能音箱对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">// 控制家电</span></span><br><span class="line">        facade.say(<span class="string">"打开家电"</span>); <span class="comment">// 早上起来时，喊一声"打开家电"，那么所有的家电都会打开</span></span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        facade.say(<span class="string">"关闭家电"</span>); <span class="comment">// 晚上睡觉时，喊一声"关闭家电"，那么所有的家电都会关闭</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，确实如我们所想的一样，那么现在就可方便了，我们只需要和智能音箱进行交互就行了。当然，在这里，我只是简单地去模拟了一下通过语音来控制家电，但是大家要知道的一点是，现实中具体实现的细节还有很多很多，例如自然语言的识别，显然这已超出咱们的认知范围了，所以我也就不过多赘述了。</p>
<p><img src="/./assets/1709469877095-8ef09396-93ed-428a-b05d-f657b2757385.png" alt="img"></p>
<hr>
<h3 id="5-5-4-外观模式的优缺点以及使用场景"><a href="#5-5-4-外观模式的优缺点以及使用场景" class="headerlink" title="5.5.4. 外观模式的优缺点以及使用场景"></a>5.5.4. 外观模式的优缺点以及使用场景</h3><p>接下来，我们来看一看外观模式的优缺点以及使用场景。</p>
<h4 id="5-5-4-1-优缺点"><a href="#5-5-4-1-优缺点" class="headerlink" title="5.5.4.1. 优缺点"></a>5.5.4.1. 优缺点</h4><h5 id="5-5-4-1-1-优点"><a href="#5-5-4-1-1-优点" class="headerlink" title="5.5.4.1.1. 优点"></a>5.5.4.1.1. 优点</h5><p>外观模式的优点，我总结出来了下面两点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度（很显然，这是由外观类来降低的），使得子系统的变化不会影响调用它的客户端</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目（如果客户直接去访问这些子系统的话，那么就可能要去访问不同的子系统里面的多个对象了，这还是比较麻烦的），并使得子系统使用起来更加容易</li>
</ol>
<h5 id="5-5-4-1-2-缺点"><a href="#5-5-4-1-2-缺点" class="headerlink" title="5.5.4.1.2. 缺点"></a>5.5.4.1.2. 缺点</h5><p>外观模式是不符合开闭原则的，所以修改起来很麻烦。</p>
<p>比如说子系统里面发生了一个改变的话，那么我们就得去修改该子系统了，虽然客户端我们是不需要修改的，而且可能我们还需要去修改外观类里面的代码。</p>
<h4 id="5-5-4-2-使用场景"><a href="#5-5-4-2-使用场景" class="headerlink" title="5.5.4.2. 使用场景"></a>5.5.4.2. 使用场景</h4><p>外观模式的使用场景，我总结出来了下面三点。</p>
<ol>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。这句话如何来理解呢？我想有必要给大家讲一下。它说的是如果系统有分层结构（即高层调用底层）的话，那么我们在去调用的时候，直接去依赖具体的一个公共接口即可，而不是再依赖具体的实现了，这样，可以使得后期代码的扩展性更好一些，当然了，也可以简化系统之间的依赖关系</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。这也说明以后我们在去设计咱们的软件时，一定要满足这一点。其实，你在去使用别人写的框架时，你会发现框架底层做了很多很多的封装，这样，你使用起该框架来就会特别特别简单了，这个就是人家写的框架的一个好处</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。我们使用外观模式，可以降低（或者消除）客户端和多个子系统之间的一个耦合，这样，当我们去修改客户端代码时，就不用再去修改子系统里面的代码了，因为此时客户端和子系统是没有任何关系的。同理，当我们去修改子系统里面的代码时，客户端代码也就不需要再进行修改了</li>
</ol>
<hr>
<h3 id="5-5-5-外观模式在源码中的应用"><a href="#5-5-5-外观模式在源码中的应用" class="headerlink" title="5.5.5. 外观模式在源码中的应用"></a>5.5.5. 外观模式在源码中的应用</h3><p>接下来，我们来看一下之前学过的技术里面，哪一块用到了外观模式。</p>
<p>Tomcat相信大家一定都用过，我们主要是使用Tomcat作为一个web容器。使用Tomcat作为web容器时，接收浏览器发送过来的请求，Tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是，大家想一想，ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道doPost方法里面的request对象肯定是一个HttpServletRequest接口的子实现类对象，那大家又知不知道该request对象到底是哪个类的对象呢？相信大家之前在用的时候，都没有去关注过这个问题，这里我就为大家来揭晓这个问题的答案。</p>
<p><img src="/./assets/1709469877056-0ea73dcb-09ca-40e0-a690-5b64b3845c24.png" alt="img"></p>
<p>大家想要知道答案的话，其实也很简单，可以直接将该request对象打印出来，这样，你就可以看到它到底是哪个类的对象了。这里，我也就不卖关子了，直接告诉大家答案好了，该request对象其实是一个名为RequestFacade的类的对象，而该类就使用到了外观模式，为何这样说呢，下面我就为大家说道说道。</p>
<p>大家先看一下下面这张类图。</p>
<p><img src="/./assets/1709469877067-15239cc6-1d3f-4726-a0f5-2633b682aa7f.png" alt="img"></p>
<p>可以看到，最顶层是一个叫ServletRequest的接口，它下面有一个子接口，即HttpServletRequest，而该HttpServletRequest接口又有一个叫RequestFacade的子实现类。并且，在RequestFacade类中，还聚合了Request类的对象，注意，Request类也是HttpServletRequest接口的一个子实现类，这可从以上类图中看出。</p>
<p>那么问题来了，RequestFacade类到底有没有使用到外观模式呢？下面我们就来分析分析。</p>
<p>其实，RequestFacade类就是外观类，也即它代表的是外观角色，而Request类属于子系统角色，这样的话，我们只需要去和RequestFacade类的对象进行交互就行了，并不需要再直接去和Request类的对象进行交互了，因此，RequestFacade类确实是使用到了外观模式。</p>
<p>好，问题又来了，<strong>为什么在此处使用外观模式呢？</strong> 下面我们接着来分析。</p>
<p>定义RequestFacade类，让其分别实现ServletRequest和HttpServletRequest这俩接口，同时又在其里面定义了一个私有成员变量（Request类型的变量），很显然，RequestFacade类里面方法的实现会调用Request成员变量里面的方法，也就是说RequestFacade类里面的方法其本质上还是使用Request类中的方法。然后，我们在去使用的时候，Tomcat会将RequestFacade对象上转为ServletRequest（或者HttpServletRequest）并传给Servlet里面的service方法，这样即使在Servlet中被下转为RequestFacade，咱们也不能访问私有成员变量对象（即Request对象）中的方法，因为该私有成员变量对象（即Request对象）是受保护的，是不能直接去使用的。</p>
<p>可见，现在是既用了Request对象里面的方法，又能防止其中方法被外界不合理的访问（这是因为Request对象里面的一些方法是想对外进行一个屏蔽的），感觉还行啊！嘻嘻😋</p>
<hr>
<h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6. 组合模式"></a>5.6. 组合模式</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1. 概述"></a>5.6.1. 概述</h3><p>在学习组合模式之前，我们先来看下面这张图。</p>
<p><img src="/./assets/1709469973975-86b5ae0a-4ee1-4200-a9b5-a040c87a01c4.png" alt="img"></p>
<p>对于以上这张图大家应该很熟悉，我们可以将其看作是一个文件系统，其实说到底它就是Windows系统里面的一个目录结构，只不过对于Windows中的文件系统而言，它里面包含有C盘、D盘、E盘等等盘符，而这里我们只是以它里面的某一个盘符里面的目录结构为例来进行了一个描述。</p>
<p>对于这样的结构我们称之为树形结构。为啥叫树形结构呢？你看一下上图中的左边部分，最上面是不是有一个WINDOWS目录啊，而该WINDOWS目录下面又有很多的子目录或者子文件，这样，我们就能将其描述成上图右边部分的树形结构了，它是不是很像一棵倒着的树啊！既然是一棵树，那么它就只有一个树根了，很明显，这个树根就是最顶层的WINDOWS目录，在该目录下，自然就会生成许多的子文件或者子文件夹了，而如果要是子文件夹的话，那么它下面又可以有许多的子文件或者子文件夹了，以此类推，一棵参天大树就长成了。</p>
<p>对于这样一个文件系统而言，有几个概念大家需要知道一下，文件夹或者文件我们都可称之为节点，但是一般来说，我们称文件为叶子节点，称文件夹为树枝节点，这是因为树枝还可以再去生成子树枝或者子叶子。</p>
<p>在这样一个树形结构中，我们可以通过调用某个方法来遍历整棵树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作了。因此，我们不妨将这颗树理解成一个大的容器，容器里面包含有很多的成员对象（其实就是节点对象），这些成员对象既可以是容器对象（即文件夹，当然你也可以把它称作是树枝对象）也可以是叶子对象（即文件）。但是由于容器对象和叶子对象在功能上面有所区别（区别是很明显的，叶子对象，即文件，可以读写数据，但是它下面不可能再有子文件或者子文件夹了；而容器对象，即文件夹，它下面是可以再有子文件或者子文件的，但是它不能进行数据的一个读写操作），使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样一来就会给客户带来不必要的麻烦，对于客户来说的话，他始终是希望能够一致的对待容器对象和叶子对象。也就是说，对于客户而言，不管是文件夹还是文件，他都希望一致的去对待它们，即把它们都当作同样的一个对象来进行处理。</p>
<p>至此，我们就认识了一下以上树形结构，并且咱们还知道了该树形结构所存在的一个问题。那如何解决该问题呢？很明显，就要用到组合模式了，因为本文讲的就是组合模式嘛！</p>
<p>那什么是组合模式呢？下面我们来看看它的概念。</p>
<p>组合模式又名部分整体模式（啥又叫部分整体模式呢？上面不是说过嘛，我们可以将一棵树理解成一个大的容器，对于该容器而言，它就是整体；然后它下面不是又有子文件或者子文件夹嘛，这些子文件或者子文件夹我们就称之为部分，当然，部分下面是不是还可以再分出部分来啊！），是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>看完以上组合模式的概念之后，相信大家就能知道应该要使用组合模式来解决以上树形结构所存在的问题了，因为对于客户而言，他就能一致的去对待容器对象和叶子对象了，这样，他使用起来也会变得更加简单。</p>
<h3 id="5-6-2-结构"><a href="#5-6-2-结构" class="headerlink" title="5.6.2. 结构"></a>5.6.2. 结构</h3><p>组合模式主要包含有三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象具有的共有方法和属性，可以预先定义一些默认行为和属性。怎么来理解抽象根节点呢？还是通过上图来理解，不管是文件夹还是文件，我们都可以向上抽取，抽取出一个抽象类，而在这个抽象类里面，我们就可以去定义文件和文件夹中的共有行为和属性了。也就是说，正是因为客户他想要一致的去对待容器对象和叶子对象，所以他就可以定义出这么一个公共的抽象类了</li>
<li>树枝节点（Composite）：定义树枝节点的行为，即存储子节点，组合树枝节点和叶子节点形成一个树形结构。妙处:同时继承和组合抽象根节点</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h3 id="5-6-3-组合模式案例"><a href="#5-6-3-组合模式案例" class="headerlink" title="5.6.3. 组合模式案例"></a>5.6.3. 组合模式案例</h3><p>接下来，我们就通过一个案例再来理解一下组合模式，这个案例就是软件菜单。</p>
<h4 id="5-6-3-1-分析"><a href="#5-6-3-1-分析" class="headerlink" title="5.6.3.1. 分析"></a>5.6.3.1. 分析</h4><p>先来看一下下面这张图。</p>
<p><img src="/./assets/1709469974017-22a39236-66ff-4d0c-9317-20944e0a3ff5.png" alt="img"></p>
<p>相信大家还是比较熟悉以上这张图的，因为我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，就拿以上系统管理菜单来说，它下面有三个子菜单，分别是菜单管理、权限配置、角色管理，它们都是属于菜单，因为它们下面还可以有子菜单或者子菜单项。</p>
<p>对于菜单管理来说，它下面有五个子菜单项，分别是页面访问、展开菜单、编辑菜单、删除菜单、新增菜单，注意了，它们都是菜单项，下面不可能再有子菜单或者子菜单项了，故它们都是属于叶子节点；</p>
<p>而系统管理、菜单管理、权限配置、角色管理，它们均属于树枝节点，并且系统管理从根本上来说，它是属于根节点。因此，使用组合模式来描述以上菜单就很恰当了。</p>
<p>这样，我们的需求就是针对一个菜单，例如系统管理，打印出其包含的所有菜单以及菜单项的名称。</p>
<p>需求明确之后，接下来我们就要编写代码解决该需求了。首先，对于该需求，我们先设计出一个如下的类图。</p>
<p><img src="/./assets/1709469973988-ce267add-4d72-46bd-b054-4b2bdbfa6af7.png" alt="img"></p>
<p>从上图可以看出，不管你是菜单（即Menu），还是菜单项（即MenuItem），都应该继承自MenuComponent抽象类，至于MenuComponent抽象类的话，它就是属于抽象根节点，里面定义了一些共有的功能和属性，也就是有两个protected修饰的成员变量，它们分别是name和level，注意了，name指代的是菜单或者菜单项的名称，因此不管是菜单还是菜单项，它们都应该有name这个属性，而level描述的是菜单的一个层级，这个是什么意思呢？</p>
<p>参照软件菜单图，如果是系统管理菜单的话，那么它就应该是一级菜单，即它的层级就是1；如果是菜单管理、权限配置、角色管理这些菜单的话，那么它们就属于是二级菜单了，即它们的层级就是2；如果是菜单管理、权限配置、角色管理这些菜单里面的菜单项的话，那么它们就属于三级菜单了，即它们的层级就是3。</p>
<p>而且，我们还在MenuComponent抽象类里面定义了添加子菜单或者子菜单项、删除子菜单或者子菜单项、获取子菜单或者子菜单项等这样一些方法。除此之外，我们还在该抽象类里面定义了两个方法，一个是getName，因为不管是菜单还是菜单项，都要有一个方法（即getName）来获取菜单或者菜单项的名称；一个是print，该方法就是来满足我们的需求打印菜单或者菜单项的名称的，当然了，如果某个菜单下还有子菜单或者子菜单项的话，那么也要将它们的名称给打印出来。</p>
<p>看完MenuComponent抽象类之后，咱们再来看一下它下面的两个子类，一个是Menu，表示菜单，注意了，Menu类的一个巧妙之处就是它又聚合了MenuComponent抽象类，也就是说Menu类不仅继承自MenuComponent抽象类，而且还聚合了MenuComponent抽象类，只不过它里面是用一个List集合来表示的，为什么呢？这是因为一个菜单可以包含多个子菜单或者子菜单项。</p>
<p>此外，Menu类里面还提供了一个有参构造，并且重写了父类中的添加子菜单或者子菜单项、删除子菜单或者子菜单项、获取子菜单或者子菜单项等这些方法，当然了，该类最后还重写了父类中的print方法，而父类中的getName方法就不需要咱们去重写了，因为该方法在父类中已经被实现了。</p>
<p>MenuComponent抽象类下面还有一个子类，即MenuItem，表示菜单项。从上图可看出，它里面提供了一个有参构造，并且重写了父类中的print方法。注意了，它里面并没有去重写父类中的添加子菜单或者子菜单项、删除子菜单或者子菜单项、获取子菜单或者子菜单项等这些方法。为什么呢？这是因为对于菜单项来说，它是不可能再有子菜单或者子菜单项的。</p>
<p>至此，我们就明确以上案例的需求了，并且对于所设计出来的类图咱们也详细分析完了，接下来，就是编写代码来实现以上案例了。</p>
<h4 id="5-6-3-2-实现"><a href="#5-6-3-2-实现" class="headerlink" title="5.6.3.2. 实现"></a>5.6.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即combination，也即组合模式的具体代码我们是放在了该包下。</p>
<p>由于不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。注意了，这个统一的接口我们是将其声明为了一个抽象类，名字就叫MenuComponent，也即菜单组件。记住，在该菜单组件里面，我们要定义一些共有的属性和方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.combination;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜单组件：属于抽象根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-01 18:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 菜单组件的名称</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="comment">// 菜单组件的层级</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加子菜单或者子菜单项，也就是说既可以添加菜单，也可以添加菜单项</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 大家一定要注意，如果是菜单的话，那么可以调用该方法，因为菜单下面是可以有子菜单或者子菜单项的；</span></span><br><span class="line"><span class="comment">     * 但是，如果是菜单项的话，那么就不能调用该方法了，因为对于菜单项来说，它下面是不可以再有子菜</span></span><br><span class="line"><span class="comment">     * 单或者子菜单项的，所以在菜单组件里面，我们给该方法一个默认的实现，即抛出一个不支持的操作的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子菜单或者子菜单项</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 大家一定要注意，如果是菜单的话，那么它底下是可以有子菜单或者子菜单项的，所以就可以移除了；</span></span><br><span class="line"><span class="comment">     * 而如果是菜单项的话，那么它便没有该移除操作了，所以在这儿我们也是抛了一个不支持的操作的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定的子菜单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 大家一定要注意，如果是菜单的话，那么可以调用该方法；而如果是菜单项的话，那么就不能调用该方法了，</span></span><br><span class="line"><span class="comment">     * 所以在这儿我们也是默认抛了一个不支持的操作的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取菜单或者菜单项的名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印菜单名称（包含子菜单和子菜单项）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于菜单和菜单项来说，print方法的实现是不一样的，所以在这里我们就把它定义成抽象方法了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>菜单组件类我们定义完毕之后，接下来，我们来定义菜单类（即Menu）。</p>
<p>按照我对以上类图的一个描述，相信大家还是能写出下面这样一个菜单类（即Menu）出来的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.combination;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜单类：属于树枝节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-01 18:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为菜单可以有多个子菜单或者子菜单项，所以在这儿我们声明一个private修饰的List集合，而且List集合里面存储的还要是MenuComponent</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MenuComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个有参构造。我们可以通过该有参构造给菜单命名以及指定菜单的一个级别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name, <span class="type">int</span> level)</span> {</span><br><span class="line">        <span class="comment">// 为父类中的成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> {</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> {</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 打印菜单名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) {</span><br><span class="line">            System.out.print(<span class="string">"--"</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">// 打印子菜单或者子菜单项名称</span></span><br><span class="line">        <span class="keyword">for</span> (MenuComponent component : menuComponentList) {</span><br><span class="line">            component.print();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>菜单类我们定义完毕之后，接下来，我们来定义菜单项类（即MenuItem）。</p>
<p>同理，按照我对以上类图的一个描述，相信大家能写出下面这样一个菜单项类（即MenuItem）出来。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.combination;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜单项类：属于叶子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-01 19:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个有参构造。我们可以通过该有参构造给菜单项命名以及指定菜单项的一个级别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name, <span class="type">int</span> level)</span> {</span><br><span class="line">        <span class="comment">// 为父类中的成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 打印菜单项的名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) {</span><br><span class="line">            System.out.print(<span class="string">"--"</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>菜单项类我们定义完毕之后，接下来，我们就要编写一个客户端类（即Client）来进行测试了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.combination;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-01 19:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建菜单树</span></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">"菜单管理"</span>, <span class="number">2</span>);</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"页面访问"</span>, <span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"展开菜单"</span>, <span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"编辑菜单"</span>, <span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"删除菜单"</span>, <span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"新增菜单"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">"权限配置"</span>, <span class="number">2</span>);</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"页面访问"</span>, <span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"提交保存"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">"角色管理"</span>, <span class="number">2</span>);</span><br><span class="line">        menu3.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"页面访问"</span>, <span class="number">3</span>));</span><br><span class="line">        menu3.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"新增角色"</span>, <span class="number">3</span>));</span><br><span class="line">        menu3.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">"修改角色"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一级菜单</span></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">"系统管理"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将二级菜单添加到一级菜单中</span></span><br><span class="line">        component.add(menu1);</span><br><span class="line">        component.add(menu2);</span><br><span class="line">        component.add(menu3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印菜单名称（如果有子菜单，那么一块（递归）打印）</span></span><br><span class="line">        component.print();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到确实是我们所想要的一个结果，而且打印出来的结果还有层级结构，我们看起来也是一目了然。</p>
<p><img src="/./assets/1709469973943-3147c8c7-347d-40e0-91b1-9d9b61481e69.png" alt="img"></p>
<p>注意，在客户端类中去打印菜单名称时，是递归打印哟，这样，我们就不需要再做一些复杂的递归操作了，而是直接调用菜单组件里面的一个方法即可，这是不是简化了客户端代码的编写啊！</p>
<p>至此，我们就使用组合模式实现了以上软件菜单案例，希望通过这个案例大家能对组合模式有一个更加深入的认识。</p>
<hr>
<h3 id="5-6-4-分类"><a href="#5-6-4-分类" class="headerlink" title="5.6.4. 分类"></a>5.6.4. 分类</h3><p>接下来，我们来看一下组合模式的分类。</p>
<p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。注意了，这里说的抽象构件类其实就是咱们上例中的MenuComponent抽象类。</p>
<p>那么，咱们上例中使用的到底是哪种形式的组合模式呢？使用的是透明组合模式，而且透明组合模式也是组合模式里面的标准实现形式。接下来，我们就来具体地聊一聊这两种形式的组合模式。</p>
<h4 id="5-6-4-1-透明组合模式"><a href="#5-6-4-1-透明组合模式" class="headerlink" title="5.6.4.1. 透明组合模式"></a>5.6.4.1. 透明组合模式</h4><p>在透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在以上示例中MenuComponent抽象类声明了add、remove 、getChild等方法（我们很明确，只有菜单才拥有这些方法，而对于菜单项来说，它不应该具有这些方法），这样做的好处是确保所有的构件类都有相同的接口。这样的话，当我们去使用的时候，就不需要再去区分到底是菜单还是菜单项了，直接面向抽象编程即可。</p>
<p>透明组合模式也是组合模式的标准形式，所以我们在使用的时候尽量都使用透明组合模式。</p>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add、remove等方法是没有任何意义的，虽然这在编译阶段不会出错（因为这些方法我们是在抽象类中定义的，而子类是可以直接去继承的），但是在运行阶段如果调用这些方法，那么可能就会出错（如果没有提供相应的错误处理代码），这是因为如果是叶子节点调用这些方法的话，那么就会抛异常，你不妨看一下以上示例中的这些方法的默认实现，是不是都抛了一个异常啊！</p>
<h4 id="5-6-4-2-安全组合模式"><a href="#5-6-4-2-安全组合模式" class="headerlink" title="5.6.4.2. 安全组合模式"></a>5.6.4.2. 安全组合模式</h4><p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点Menu类中声明并实现这些方法。</p>
<p>我们不妨看一下以下类图。</p>
<p><img src="/./assets/1709469973965-17416e61-1ce4-42e2-b763-0227cd6f57b2.png" alt="img"></p>
<p>可以看到，我们并没有在MenuComponent抽象类里面去声明add、remove 、getChild等方法，这些方法是在具体的菜单类中声明并实现的。</p>
<p>安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，也就是说咱们必须去区别对待叶子构件和容器构件，因为只有区分开了，才能使用它们对应的那些方法。如果你用多态的形式（即通过父类引用指向子类对象），那么父类中没有定义的方法，子类是不能使用的，所以一旦使用了安全组合模式，那么就不能面向抽象编程了。</p>
<hr>
<h3 id="5-6-5-优点"><a href="#5-6-5-优点" class="headerlink" title="5.6.5. 优点"></a>5.6.5. 优点</h3><p>组合模式的优点，我总结出了以下四点。</p>
<ol>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。就拿以上示例来说，在设计时，我们是使用聚合方式来实现的树形结构，如此一来，对于客户端而言，全部或部分层次在使用的时候就没有任何差异了。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。举个例子，比如说现在有一个使用组合模式实现的非常复杂的菜单，当然，它里面必然是有菜单项的，这时，对于客户端而言，菜单和菜单项这俩对象都是一样的，因为它们里面的功能在父类中都已经声明过了，这同时也会简化客户端代码的编写。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合”开闭原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合（注意，咱们此处的递归组合使用的方式就是聚合），可以形成复杂的树形结构，但对树形结构的控制却非常简单。例如，我们去打印菜单名称时，当然，如果有子菜单，那么还须一块递归打印，只需要去调用菜单组件里面的print方法即可，我们并不需要明确该菜单到底有几层以及它里面是怎么实现的。</li>
</ol>
<h3 id="5-6-6-使用场景"><a href="#5-6-6-使用场景" class="headerlink" title="5.6.6. 使用场景"></a>5.6.6. 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如文件目录显示、多级目录呈现等树形结构数据的操作。</p>
<hr>
<h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7. 享元模式"></a>5.7. 享元模式</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1. 概述"></a>5.7.1. 概述</h3><p>什么是享元模式呢？享元模式是运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<p>知道享元模式的概念之后，我们来看一下现实生活中哪些地方大量的运用到了这种共享思想。大家不妨开动脑筋想一想，共享单车是不是就是啊！在没有共享单车的时候，如果你想骑自行车的话，那么你是不是就得需要自己去购买一辆自行车啊！可能你骑了两天的自行车，热度过了之后，你就不再想去骑它了，这样自行车就会闲置在家里，这本身就是资源的一种浪费。那现在如何去提高资源的一个利用率呢？</p>
<p>共享单车就应运而生了，生产一批自行车，把它们都投放在市面上，如果有人想骑的话，那么他只需要扫码进行一个租赁，然后去骑行即可，骑行完了之后，再进行一个归还，归还的目的就是供其他人进行使用，这就是共享思想，其目的主要就是为了提高资源的利用率。</p>
<h3 id="5-7-2-结构"><a href="#5-7-2-结构" class="headerlink" title="5.7.2. 结构"></a>5.7.2. 结构</h3><p>享元（Flyweight）模式中存在以下两种状态：</p>
<ol>
<li>内部状态（或者内部数据），即不会随着环境的改变而改变的可共享部分。也就是说，不管是我使用还是你使用，内部状态都是一样的。</li>
<li>外部状态（或者外部数据），指随环境改变而改变的不可以共享的部分。那么这一部分的数据，我们应该如何进行设置呢？很简单，外部数据可以作为方法的形式参数进行一个传递。</li>
</ol>
<p>享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</p>
<p>了解享元模式中存在的两种状态之后，接下来，我们就来看看享元模式里面有哪些角色。</p>
<p>享元模式主要有以下几个角色：</p>
<ul>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类里面公共的方法（现在大家明白，为什么要把该角色定义成接口或者抽象类了吧！其实就是为了进行一个抽取，以便定义成一套规范），这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。其实，上面我也说到了，外部数据（外部状态）可以作为方法的形式参数进行一个传递，这是因为每个人在使用的时候，外部状态都有可能是不一样的。</li>
<li>具体享元（Concrete Flyweight）角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间，这是因为内部状态是在内部进行一个存储的，并且每个人在使用的时候，内部状态都是一样的。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight）角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时，可以直接通过实例化创建，也就是说我们可以直接去创建该类的对象。注意，该非享元角色我们可以将其理解成外部状态（外部数据），若有多个外部数据的话，则可将它们封装起来。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，若存在则提供给客户；若不存在的话，则直接创建一个新的享元对象。</li>
</ul>
<hr>
<h3 id="5-7-3-享元模式案例"><a href="#5-7-3-享元模式案例" class="headerlink" title="5.7.3. 享元模式案例"></a>5.7.3. 享元模式案例</h3><p>接下来，我们就通过一个案例再来理解一下享元模式以及享元模式里面的两个状态（即内部状态和外部状态），这个案例就是俄罗斯方块。</p>
<h4 id="5-7-3-1-分析"><a href="#5-7-3-1-分析" class="headerlink" title="5.7.3.1. 分析"></a>5.7.3.1. 分析</h4><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，只要大家有玩过俄罗斯方块，你就一定对它特别特别熟悉。</p>
<p><img src="/./assets/1709470052593-4d808115-4860-4590-a8b5-15f668c95c04.jpeg" alt="img"></p>
<p>从上图中可以看到，有I图形、J图形、L图形、O图形、Z图形、T图形以及S图形等这些方块，这些方块就组合成了俄罗斯方块这个游戏。大家在玩俄罗斯方块这个游戏的时候，你会发现图形其实就这几个，只不过是每一个图形可能出现多次，而且颜色也有可能是不一样的，如果我们将每一个小方块都看作是一个实例对象的话，那么I图形出现多次，这就意味着要创建多个对象了。</p>
<p>也就是说，对于相同的图形来说的话，就要创建多个对象了，但这势必会占用过多的内存空间，为了解决这个问题，那么我们就要使用享元模式来进行实现了。这样，对于I图形来说的话，我们只需要去创建一个共享的对象即可，至于不同的颜色，我们可以将其看作是外部状态，这样一来，我们也就能通过参数传递的方式来进行一个实现了。</p>
<p>接下来，我们来看一下下面这张类图，理清楚以下类图涉及到了哪些类以及类和类之间的一个关系。</p>
<p><img src="/./assets/1709470052606-8bc7f23c-4abf-459e-be6e-2e23f7d36da6.png" alt="img"></p>
<p>可以看到，有一个AbstractBox类，从名字上就能知道该类是一个抽象类，想必大家都知道了它就是抽象享元角色。在该类中，提供了两个方法，第一个是getShape，用于获取图形，注意了，该方法去获取图形时结果是以字符串的形式返回的，例如对于I图形来说，返回的就是字符串I，此外，大家还要知道该方法是一个抽象的方法，这是因为只有具体的子类才能明确自己到底是什么样的一个图形；第二个方法是display，将具体的颜色传递进该方法后，该方法就会将其输入到控制台中，注意了，在AbstractBox类中，该方法有具体实现。</p>
<p>然后，AbstractBox类下面又有三个子类，它们分别是IBox、LBox以及OBox，这里我只设计出来了这三个子类，当然了，肯定还会有其他子类，只不过这里我没设计出来，有兴趣的同学不妨再设计出更多的子类，例如JBox、ZBox等等。很显然，这些子类是要去重写父类中的抽象方法的，因为不同的子类返回的图形结果字符串表示形式是不一样的。</p>
<p>接着，我们再来看一下BoxFactory类，它是一个工厂类。既然它是一个工厂类，那么我们得明确一点，就是该工厂类只需要有一个，所以我们在设计该工厂类的时候应将其设计为单例的，自然地，我们就要把单例设计模式融入到该案例里面中去了。当然了，对于IBox、LBox以及OBox这些子类，如果是只需要创建一个对象的话，那么大家同样也可以使用单例设计模式，只不过在此案例中，我们就不把它们三个设置为单例的了，而是只须把工厂类设置为单例的就行。</p>
<p>我们来继续看一下BoxFactory类里面的成员，从上可以看到，有一个HashMap&lt;String, AbstractBox&gt;类型的成员变量，它是用来存储那些图形的名称以及图形对象的。也就是说，有了该成员变量之后，那些图形对象就都存储在内存中了，这样，当咱们去获取具体的图形对象时，就不需要自己再去new了，而是直接通过该工厂类去获取，当然，你得根据图形名称去获取，例如传入一个字符串I，就能拿到一个IBox类的对象。</p>
<p>紧接着，我们再来看一下BoxFactory类里面的方法，映入眼帘的第一个方法就是构造方法，当然了，该构造方法私有了，这是因为我们要将该工厂类设计成单例的。将该工厂类设计成单例的之后，我们是不是还得对外提供一个方法供外界获取该工厂类的对象啊！而这个方法就是getInstance。除此之外，该工厂类里面还有一个方法，即getBox，它是根据图形名称去获取图形对象的。</p>
<h4 id="5-7-3-2-实现"><a href="#5-7-3-2-实现" class="headerlink" title="5.7.3.2. 实现"></a>5.7.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即flyweight，也即享元模式的具体代码我们是放在了该包下。</p>
<p>然后，创建AbstractBox类，记住，它是一个抽象类。根据我以上对类图的分析，相信大家应该不难写出下面这样一个类出来。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象享元角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 7:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图形的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图形及颜色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 传递外部状态（颜色，即color参数），然后再将其打印出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> {</span><br><span class="line">        System.out.println(<span class="string">"方块形状："</span> + getShape() + <span class="string">"，颜色："</span> + color);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建AbstractBox类的子类，这里我们不妨先创建一个叫IBox的子类，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I图形类（具体享元角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 7:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建一个叫LBox的子类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * L图形类（具体享元角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 7:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"L"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然了，根据以上类图咱们最后还得创建一个叫OBox的子类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * O图形类（具体享元角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 7:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"O"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建工厂类，这里我们就将该类起名为BoxFactory了。记住，我们是要将该类设计成单例的哟！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类，记住，我们是要将该类设计成单例的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 7:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, AbstractBox&gt; map; <span class="comment">// 注意，在这儿我们并没有为map成员变量赋值，而是在下面的构造方法中为其进行了初始化操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在构造方法中进行初始化操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> {</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        map.put(<span class="string">"I"</span>, <span class="keyword">new</span> <span class="title class_">IBox</span>());</span><br><span class="line">        map.put(<span class="string">"L"</span>, <span class="keyword">new</span> <span class="title class_">LBox</span>());</span><br><span class="line">        map.put(<span class="string">"O"</span>, <span class="keyword">new</span> <span class="title class_">OBox</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个方法获取该工厂类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BoxFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据图形名称获取图形对象</span></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大家不妨来回顾一下，对于以上工厂类的实现，它到底用的是单例模式里面的哪种方式呢？很显然是饿汉式，因为我们在一开始的时候就对BoxFactory类型的成员变量factory进行了初始化。</p>
<p>最后，创建一个客户端类，以便进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 7:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 获取I图形对象</span></span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">box1</span> <span class="operator">=</span> BoxFactory.getInstance().getBox(<span class="string">"I"</span>);</span><br><span class="line">        <span class="comment">// 为I图形传递（或者设置）颜色</span></span><br><span class="line">        box1.display(<span class="string">"灰色"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取L图形对象</span></span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">box2</span> <span class="operator">=</span> BoxFactory.getInstance().getBox(<span class="string">"L"</span>);</span><br><span class="line">        <span class="comment">// 为L图形传递（或者设置）颜色</span></span><br><span class="line">        box2.display(<span class="string">"绿色"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取O图形对象</span></span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">box3</span> <span class="operator">=</span> BoxFactory.getInstance().getBox(<span class="string">"O"</span>);</span><br><span class="line">        <span class="comment">// 为O图形传递（或者设置）颜色</span></span><br><span class="line">        box3.display(<span class="string">"灰色"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再获取O图形对象</span></span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">box4</span> <span class="operator">=</span> BoxFactory.getInstance().getBox(<span class="string">"O"</span>);</span><br><span class="line">        <span class="comment">// 为O图形传递（或者设置）颜色</span></span><br><span class="line">        box4.display(<span class="string">"红色"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"两次获取到的O图形对象是否是同一个对象："</span> + (box3 == box4));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类的代码，打印结果如下图所示，可以看到是我们所想要的结果，而且对于两次获取的O图形来说，虽然它们颜色不一样，但是它们仍然是同一个对象。这就使用到了享元模式，即对图形对象进行了共享操作。</p>
<p><img src="/./assets/1709470052654-8e8cea7d-b4bd-45c4-8c33-31e68bd2fcf2.png" alt="img"></p>
<h3 id="5-7-4-享元模式的优缺点以及使用场景"><a href="#5-7-4-享元模式的优缺点以及使用场景" class="headerlink" title="5.7.4. 享元模式的优缺点以及使用场景"></a>5.7.4. 享元模式的优缺点以及使用场景</h3><p>接下来，我们来看一下享元模式的优缺点以及使用场景。</p>
<h4 id="5-7-4-1-优缺点"><a href="#5-7-4-1-优缺点" class="headerlink" title="5.7.4.1. 优缺点"></a>5.7.4.1. 优缺点</h4><h5 id="5-7-4-1-1-优点"><a href="#5-7-4-1-1-优点" class="headerlink" title="5.7.4.1.1. 优点"></a>5.7.4.1.1. 优点</h5><p>享元模式的优点，我总结出来了下面两个。</p>
<ol>
<li>极大减少内存中相似或相同对象数量，节约系统资源（主要就是指的内存），提供系统性能。</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态。就拿上述示例来说，图形的颜色就是外部状态，颜色的改变并不影响图形（形状）。</li>
</ol>
<h5 id="5-7-4-1-2-缺点"><a href="#5-7-4-1-2-缺点" class="headerlink" title="5.7.4.1.2. 缺点"></a>5.7.4.1.2. 缺点</h5><p>为了使对象可以共享，需要将享元对象的部分状态外部化（例如，在上述示例中，我们就对图形的颜色进行了一个外部化，也即把图形颜色设置为了外部状态），分离内部状态和外部状态，使程序逻辑复杂。</p>
<p>试想一下，如果我们不进行分离的话，那么我们应该如何去做呢？是不是应该这样做啊！对于I图形来说，若它是红色，则我们要创建一个类的对象；若它是绿色，则我们还要创建一个类的对象，这样的话就会导致在内存中将会占用过多的内存资源，但是我们使用享元模式就不会有这个问题出现，虽然这将使程序的整个逻辑变得更加复杂。</p>
<h4 id="5-7-4-2-使用场景"><a href="#5-7-4-2-使用场景" class="headerlink" title="5.7.4.2. 使用场景"></a>5.7.4.2. 使用场景</h4><p>享元模式的使用场景，我总结出来了下面三个。</p>
<ol>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。就像在上述示例中，咱们就把图形的颜色作为方法的参数进行了一个传递。</li>
<li>在使用享元模式时需要维护一个存储享元对象的享元池（在上述示例中，我们是定义了一个HashMap用来存储图形对象，因此我们就可以把它理解成是享元池），而这需要耗费一定的系统资源（主要还是指内存资源），因此，应当在需要多次重复使用享元对象时才值得使用享元模式。如果我们在一开始就初始化了一些图形对象，但是这些图形对象在系统运行过程中压根就用不到，那么这就会无端占用一些内存空间了，这也是一种资源的浪费。</li>
</ol>
<hr>
<h3 id="5-7-5-享元模式在JDK源码中的应用"><a href="#5-7-5-享元模式在JDK源码中的应用" class="headerlink" title="5.7.5. 享元模式在JDK源码中的应用"></a>5.7.5. 享元模式在JDK源码中的应用</h3><p><strong>省流:</strong>  <strong>Integer会默认先创建并缓存</strong><strong>-128 ~ 127<strong><strong>之间数的Integer对象，当调用</strong></strong>valueOf**<strong>方法时若参数在</strong></strong>-128 ~ 127**<strong>之间则计算下标并从缓存（即数组）中返回，否则创建一个新的Integer对象。</strong></p>
<p>接下来，我们就来看一下享元模式在JDK源码里面的具体应用。</p>
<p>这里我就开门见山了，Integer类就使用到了享元模式。在研究Integer类的底层源码之前，咱们先看一下下面的这个例子。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.flyweight.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 8:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"i1和i2对象是否是同一个对象？"</span> + (i1 == i2));</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"i3和i4对象是否是同一个对象？"</span> + (i3 == i4));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于上述这段代码，我们不妨直接拿过来执行一下，结果如下图所示。</p>
<p><img src="/./assets/1709470052578-d6220d9d-8935-428f-92fa-bd30140faf33.png" alt="img"></p>
<p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false呢？而且从以上例子中，似乎我们能看出127是一个临界值，到底是不是这样呢？接下来，我们就来研究研究。</p>
<p>要想对以上问题进行研究，我们就得通过反编译软件对字节码文件进行一个反编译，反编译之后的代码如下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">127</span>);</span><br><span class="line">        Integer i2 Integer.valueOf((<span class="type">int</span>)<span class="number">127</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)<span class="string">"i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f"</span>).append((<span class="type">boolean</span>)(i1 == i2)).toString());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">128</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">128</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)<span class="string">"i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f"</span>).append((<span class="type">boolean</span>)(i3 == i4)).toString());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 valueOf方法 ，所以我们只需要去研究该方法即可。</p>
<p>接下来，我们来看一下valueOf方法底层是如何实现的。下面是我摘取Integer类源码里面的部分代码，大家不妨来看一下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> {</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                } <span class="keyword">catch</span>( NumberFormatException nfe) {</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，我们主要关注Integer类里面的valueOf方法，从上可以知道，该方法需要的是一个int类型的数据，并且最终会返回一个Integer对象。下面我们就来分析一下该方法的具体实现。</p>
<p>从上可以看到，valueOf方法里面有一个if判断，判断条件中涉及到了两个东东，它们分别是：</p>
<ul>
<li>IntegerCache.low：IntegerCache类是Integer类里面的静态内部类，从名字上我们就能知道它就是Integer类的缓存，至于low，它是IntegerCache类里面的一个静态变量，值为-128，表示的是Integer缓存里面的最小值。</li>
<li>IntegerCache.high：high也是IntegerCache类里面的一个静态变量，它表示的是Integer缓存里面的最大值。至于它的值是多少，我们就要进入IntegerCache静态内部类中去查看一下了。可以看到，在IntegerCache静态内部类的静态代码块中，为它赋了一个127的初始值。</li>
</ul>
<p>现在大伙知道valueOf方法里面的if判断到底做了一个什么判断吧！如果传递进来的int类型的数据大于等于-128，并且小于等于127，那么就会执行if判断里面的代码，否则，直接返回一个新new出来的Integer类型的对象，并且把传递进来的int类型的数据作为参数进行了一个传递。</p>
<p>搞清楚if判断条件之后，接下来，我们再来分析一下if判断里面的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，里面调用了IntegerCachen静态内部类里面的cache数组，既然如此，那么[]里面肯定是数组的索引了，也就是通过索引去拿数组里面的元素。</p>
<p>那么问题来了，数组里面的元素到底是什么呢？这得再去看看IntegerCachen静态内部类里面的静态代码块了。大家看不太懂也没关系，这里我会为大家解释一下。</p>
<p>其实，它说的是<strong>Integer会默认先创建并缓存</strong><strong>-128 ~ 127<strong><strong>之间数的Integer对象，当调用</strong></strong>valueOf**<strong>方法时若参数在</strong></strong>-128 ~ 127**<strong>之间则计算下标并从缓存（即数组）中返回，否则创建一个新的Integer对象</strong>。</p>
<p>这也很好地解释了一开始的例子所打印的结果了。一开始定义的两个Integer类型的变量的值都是127，所以这俩变量指代的都是同一个Integer对象，这样，在打印这两个Integer对象是否是同一个对象时，结果必然就是true了；而对于值是128的两个Integer类型的变量来说，由于128并不在-128 ~ 127范围之间，所以它是没有被缓存的，如此一来，每次都会new一个新的Integer对象了，自然在打印这两个Integer对象是否是同一个对象时，结果就是false了。</p>
<p>以上就是Integer类里面的valueOf方法源码的一个探究，正是该方法用到了享元模式。</p>
<hr>
<hr>
<h1 id="6-行为型模式"><a href="#6-行为型模式" class="headerlink" title="6. 行为型模式"></a>6. 行为型模式</h1><p>首先，我们来看一看什么是行为型模式。</p>
<p>行为型模式用于描述程序在运行时复杂的流程控制（我们之前学习过很多流程控制语句，例如if else、switch、for循环等等），即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>什么意思呢？也就是说如果是多个类的话，那么我们可以使用继承的关系来让其完成复杂的流程控制；如果是多个对象的话，那么我们可以通过对象的聚合或者组合来完成一个复杂的流程控制。而这里面必然会涉及到一些算法以及对象之间职责的一个分配，不同的模式，它所涉及的算法以及对象间职责的分配是不一样的。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分配行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足”合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。也就是说，我们在用的时候，对象行为模式用的是更多的。</p>
<p>接下来，我们就来看一下行为型模式总共包含了哪些模式。</p>
<p>行为型模式分为：</p>
<ul>
<li>模板方法模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>职责链模式</li>
<li>状态模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
</ul>
<p>对于这些行为型模式，我会后续的学习过程中为大家一一进行讲解。注意，对于上面的这11种行为型模式而言，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>
<hr>
<h2 id="6-1-模板方法模式"><a href="#6-1-模板方法模式" class="headerlink" title="6.1. 模板方法模式"></a>6.1. 模板方法模式</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1. 概述"></a>6.1.1. 概述</h3><p>省流 : 抽象类的具体方法调用自己的抽象方法</p>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但是某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务时一般要经过这4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户都是一样的，可以在父类中实现（因为可以提高代码的复用性），但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p>延迟到子类中实现的话，就得要在父类中声明抽象方法了，而且大家也要明确一点，就是对于以上4个流程，它们调用的顺序是固定的，也就是说客户得先取号，然后再去排队，接着办理具体业务，最后对银行工作人员进行评分，因此我们也可以把调用的顺序放在父类中，这就是模板方法模式。</p>
<p>那到底什么是模板方法模式呢？下面我们来看下其具体的概念。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个操作中的算法骨架（例如，上例中客户去银行办理业务时经过的4个流程，而且调用这4个流程时是有其固定顺序的。注意，算法骨架是需要在父类中去定义的），而将算法的一些步骤延迟到子类中（例如，上例中对于办理具体业务这一步骤而言，是因人而异的，所以我们就可以把这一步骤的实现推迟到子类中，前提是要在父类中进行抽象声明），使得子类可以在不改变该算法结构的情况下重定义该算法的某些特定步骤。</span><br></pre></td></tr></tbody></table></figure>

<p>看完模板方法模式的概念，我们应明白一点，就是我们要先把调用的功能（也可以说成是算法骨架中的步骤）在父类中声明好，然后子类只需要对里面的某一个步骤或者某些步骤进行一个重新定义（或者重写）就可以了。</p>
<p>最后，我再多说一嘴，就是如果我们在子类中要将父类中的流程控制的方法进行重写，那么在父类中的方法可以使用final来修饰吗？很显然，肯定是不行的，如果真要是使用final来修饰的话，那么子类就不能进行重写了。</p>
<h3 id="6-1-2-结构"><a href="#6-1-2-结构" class="headerlink" title="6.1.2. 结构"></a>6.1.2. 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
</li>
<li><ul>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。例如，上例中，取号、排队、办理具体业务、对银行工作人员进行评分这4个流程，它们调用的顺序是固定的，而调用这4个流程的方法，我们就将其称为模板方法，模板方法里面执行的顺序我们可以理解成就是算法的骨架，只不过在这儿基本上没有一些深入的算法。</li>
<li>基本方法：它是实现算法各个步骤的方法，是模板方法的组成部分。上面我已经说过什么是模板方法了，在模板方法里面，我们会调用取号、排队、办理具体业务、对银行工作人员进行评分等等这些功能，而这些功能我们就可以理解成是基本方法了，这些基本方法是模板方法的组成部分。基本方法又可以分为三种：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>抽象方法（Abstract Method）：一个抽象方法由抽象类声明，并由其具体子类实现，也即要求子类必须重写。</li>
<li>具体方法（Concrete Method）：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。那么现在我们来想一想，对于上例而言，哪些是抽象方法，哪些是具体方法呢？对于取号、排队和对银行工作人员进行评分这三个功能来说，它们都是属于具体方法，因为每个人的操作都是一样的，这样，我们就可以把这些功能定义在父类中了，或者就在父类中进行实现，这是不是可以提高代码的复用性啊！而对于办理具体业务这个功能来说，它是因人而异的（每个人办理的业务不一样），所以它就是抽象方法，应该把它推迟到子类中来实现。</li>
<li>钩子方法（Hook Method）：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。也就是说，一种是父类中已经实现了，一种是在父类中没有实现，而是要求子类必须去重写（或者实现）。对于上例来说，它是没有钩子方法的。对于钩子方法来说，一般它是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型一般都是boolean类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
</li>
</ul>
<h3 id="6-1-3-模板方法模式案例"><a href="#6-1-3-模板方法模式案例" class="headerlink" title="6.1.3. 模板方法模式案例"></a>6.1.3. 模板方法模式案例</h3><p>接下来，我们便通过一个案例来让大家再去理解一下模板方法模式以及它所蕴涵的思想，这个案例就是炒菜。</p>
<h4 id="6-1-3-1-分析"><a href="#6-1-3-1-分析" class="headerlink" title="6.1.3.1. 分析"></a>6.1.3.1. 分析</h4><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现在我们要通过模板方法模式来用代码进行模拟，那又该怎么做呢？</p>
<p>如果要通过模板方法模式来用代码进行模拟炒菜，那么肯定是要定义抽象类以及具体子类的，而且在抽象类里面，我们还要分别去定义模板方法和基本方法。</p>
<p>模板方法是什么，上面我也说到了，就是定义了算法的骨架（对于该案例而言，就是炒菜的步骤，因为炒菜的步骤都是一致的）。在该案例中，模板方法就是烹饪功能，它里面要调用倒油、热油、倒蔬菜、倒调料品、翻炒等这些功能。</p>
<p>那抽象类里面的基本方法又都有哪些呢？很简单嘛，不就是倒油、热油、倒蔬菜、倒调料品、翻炒等这些方法嘛！问题又来了，这些基本方法里面哪些又是抽象方法呢？其实，你会发现倒油、热油和翻炒这几个方法的具体实现都是一样的，只不过对于炒不同的蔬菜而言，倒的蔬菜以及调料品是不一样的，所以我们就可以将倒蔬菜和倒调料品这俩方法定义成抽象的了，至于其他的三个方法，我们只须定义成具体方法即可，如此一来，就能提高代码的复用性了。</p>
<p>分析完之后，我们再来看看下面这张类图。</p>
<p><img src="/./assets/1709470438664-21df4e92-4bcb-425c-84a6-ae2f39580c6a.png" alt="img"></p>
<p>可以看到，顶部有一个抽象类（即父类），它下面又有两个具体的子类，一个是爆炒包菜类，一个是爆炒菜心类，它俩都得重写父类中的倒蔬菜和倒调料品这两个方法，是不是很简单啊！</p>
<p>以上类图分析完了之后，接下来，咱们就要编写代码来实现以上案例了。</p>
<h4 id="6-1-3-2-实现"><a href="#6-1-3-2-实现" class="headerlink" title="6.1.3.2. 实现"></a>6.1.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即template，也即模板方法模式的具体代码我们是放在了该包下。</p>
<p>然后，创建抽象类，该抽象类我们不妨就命名为AbstractClass。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类（定义模板方法和基本方法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 18:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法定义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意，我们已经说过了，模板方法是定义了算法的骨架，而子类在继承父类时，是可以对该模板方法进行重写的，</span></span><br><span class="line"><span class="comment">     * 重写的话那就意味着子类可以去改变这个算法的骨架了，但是我们又不能让其去改变，所以我们就只好在该模板</span></span><br><span class="line"><span class="comment">     * 方法上加上final关键字进行修饰了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> {</span><br><span class="line">        pourOil();</span><br><span class="line">        heatOil();</span><br><span class="line">        pourVegetable();</span><br><span class="line">        pourSauce();</span><br><span class="line">        fry();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一步：倒油，属于具体方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不管炒啥都是一样的，所以直接实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"倒油"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二步：热油，属于具体方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不管炒啥都是一样的，所以直接实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"热油"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第三步：倒蔬菜，属于抽象方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意了，炒菜时倒的蔬菜是不一样的，例如爆炒包菜时倒的是包菜，爆炒菜心时倒的是菜心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第四步：倒调味料，属于抽象方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 既然炒菜时倒的蔬菜是不一样的，那么倒的调味料也必然是不一样的了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第五步：翻炒，属于具体方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不管炒啥都是一样的，所以直接实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"炒啊炒啊炒到熟啊"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建以上抽象类的子类，让其去重写里面的两个抽象方法。这里我会创建两个子类，一个是炒包菜类，该类我们起名为ConcreteClass_BaoCai。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 炒包菜类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 19:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是包菜"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是辣椒"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个是炒菜心类，该类我们起名为ConcreteClass_CaiXin。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 炒菜心类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 19:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是菜心"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是蒜蓉"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个测试类进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 19:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 现在我们来炒个包菜</span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        <span class="comment">// 调用炒菜的功能</span></span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上测试类，打印结果如下，可以看到爆炒包菜确实是按照上面所描述的那几个步骤来炒的。</p>
<p><img src="/./assets/1709470438648-52127881-72e4-4cdc-a3a7-e3dc09748e99.png" alt="img"></p>
<p>至此，炒菜这个案例我们就实现完毕了，以后如果我们要想炒其他的蔬菜，那么只须去定义一个子类，让它去继承（或者实现）AbstractClass类即可，而且由于AbstractClass类里面已经定义好了炒菜的步骤，所以子类就不再需要去关注它是如何进行一个翻炒的了，而是只需要去重写它里面的两个抽象方法（分别去指定倒的是什么蔬菜以及倒的是什么调料）就行。</p>
<p>学到这里，相信大家对模板方法模式有了一个更深入的理解。</p>
<hr>
<h3 id="6-1-4-模板方法模式的优缺点以及使用场景"><a href="#6-1-4-模板方法模式的优缺点以及使用场景" class="headerlink" title="6.1.4. 模板方法模式的优缺点以及使用场景"></a>6.1.4. 模板方法模式的优缺点以及使用场景</h3><p>接下来，我们就来看看模板方法模式的优缺点以及使用场景。</p>
<h4 id="6-1-4-1-优缺点"><a href="#6-1-4-1-优缺点" class="headerlink" title="6.1.4.1. 优缺点"></a>6.1.4.1. 优缺点</h4><h5 id="6-1-4-1-1-优点"><a href="#6-1-4-1-1-优点" class="headerlink" title="6.1.4.1.1. 优点"></a>6.1.4.1.1. 优点</h5><p>关于模板方法模式的优点，我总结出来了下面两个。</p>
<ol>
<li>提高代码复用性。在上述案例中，我们是将相同部分的代码放在了抽象的父类中（这样，子类就可以直接去继承使用了，也即提高了代码的复用性），而将不同的代码放入了不同的子类中（注意了，要由父类先声明成抽象的方法，再要求子类必须去重写）。</li>
<li>实现了反向控制。什么叫实现了反转控制呢？以前我们编写代码时，可能是这样的，在子类中去调用父类的方法，而现在我们是通过一个父类调用其子类的操作，这就是反向控制。通过一个父类调用其子类的操作，再通过对子类的具体实现扩展不同的行为，就实现了反向控制，这也符合”开闭原则”。后期如果我们想要去添加一些其他的操作的话，那么直接去定义子类就可以了，而不再需要对父类的代码进行修改了，也不再需要对原有的那些子类进行一个修改了。</li>
</ol>
<h5 id="6-1-4-1-2-缺点"><a href="#6-1-4-1-2-缺点" class="headerlink" title="6.1.4.1.2. 缺点"></a>6.1.4.1.2. 缺点</h5><p>关于模板方法模式的缺点，我也总结出来了下面两个。</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。注意了，类的数量增加也是有限的，并不会导致类的个数爆炸式增加，所以这个缺点也还能接受。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。刚刚我们说了，模板方法模式的优点是实现了反向控制，而它的缺点也是反向控制。为什么会这样说呢？因为如果实现了反向控制的话，那么就会提高代码阅读的难度了。以后，我们在去看别人写的框架的源码的时候，如果里面使用到了模板方法模式这种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">设计模式</a>，那么我们在看源码时可能就会稍微有一些难以理解了。</li>
</ol>
<h4 id="6-1-4-2-使用场景"><a href="#6-1-4-2-使用场景" class="headerlink" title="6.1.4.2. 使用场景"></a>6.1.4.2. 使用场景</h4><p>关于模板方法模式的使用场景，我列举出来了下面两个。</p>
<ol>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。也就是说，在父类中通过模板方法的形式把算法的整体架构定义出来，至于易变的个别部分（或者个别功能），则在父类中声明成抽象方法，然后要求子类必须去重写。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。这里其实会涉及到钩子函数，也就是说如果有这样的一个场景的话，那么我们就需要定义钩子函数了，只不过上述案例中并没有体现出来，这是因为我们的业务需求里面并不需要用到钩子函数。后期我们在做其他业务时，就可能需要定义钩子函数了。</li>
</ol>
<h3 id="6-1-5-模板方法模式在JDK源码中的应用"><a href="#6-1-5-模板方法模式在JDK源码中的应用" class="headerlink" title="6.1.5. 模板方法模式在JDK源码中的应用"></a>6.1.5. 模板方法模式在JDK源码中的应用</h3><p>接下来，我们就来看一看模板方法模式在JDK源码里面是如何来应用的。</p>
<p>在JDK源码里面，其实很多地方都用到了模板方法模式，而在本套系列课程中，我们只看一个类就行了，这个类就是InputStream，它就用到了模板方法模式。</p>
<p>在InputStream类中定义了多个read方法，如下所示，很明显它们是重载的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> {</span><br><span class="line">    <span class="comment">// 抽象方法，要求子类必须重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> read(); <span class="comment">// 调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        b[off] = (<span class="type">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) {</span><br><span class="line">                c = read(); <span class="comment">// 调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                b[off + i] = (<span class="type">byte</span>)c;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException ee) {</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，InputStream类首先是一个抽象类，因为有abstract关键字来修饰它。而且，在该抽象类里面，有三个重载的read方法，第一个是无参的，第二个是带一个参数的，当然这个参数是字节数组，第三个是带三个参数的。</p>
<p>现在我们就来想一想，如果想要一次性去读取多个字节数据，那么我们是不是得调用带一个参数的read方法啊！而在调用该方法时，我们发现它里面又调用了另外一个重载的read方法，即带三个参数的read方法。</p>
<p>那我们接下来就再看看带三个参数的read方法是如何来实现的呗！你会发现在该方法中的第10行、第19行又调用了无参的抽象的read方法，既然是抽象的，那么就意味着必须要求子类去重写了，所以在这两处调用无参的抽象的read方法，其本质上调用的是子类中的read方法，这就是反向控制，而反向控制正是模板方法模式的思想。</p>
<p>我们都知道无参的read方法是每次读取一个字节数据，那么读取到之后，这个字节数据又是如何处理的呢？其实是将其存储到了一个数组里面。而且，在带三个参数的read方法里面，现在是要读len个字节数据的，所以在该方法里面就用到了for循环，这样就能把每次读到的字节数据全部存储在数组里面了。也就是说，我们一次性读取了多个字节数据，并将其存储在了数组里面。</p>
<p>分析完以上代码之后，接下来，我们就来研究研究模板方法模式里面的角色在此处是如何体现的。</p>
<p>InputStream类就是模板方法模式里面的抽象类角色，我们都知道抽象类里面是有基本方法和模板方法的，那模板方法究竟是哪个呢？模板方法就是InputStream类中带三个参数的read方法，它里面定义了算法的骨架。从上可以看到，在该骨架中，多次调用了无参的抽象的read方法，并且每一次调用该方法都会将获取到的字节数据存储在数组里面。</p>
<p>分析至此，相信大家也知道了InputStream类中的无参的抽象的read方法就是基本方法里面的抽象方法，是要求子类必须去重写的。如果子类去重写的话，那么我们在带三个参数的read方法里面调用的就是子类中重写的方法，这便是反向控制。</p>
<p>以上就是我们对InputStream类源码的一个分析，它里面就用到了模板方法模式。</p>
<p>最后，我总结一下：<strong>在InputStream父类中已经定义好了读取一个字节数组数据的方法，具体实现是每次读取一个字节，并将其存储到数组的第一个索引位置，而且得读取len个字节数据。具体如何来读取一个字节数据则是由子类来实现</strong>。</p>
<h3 id="6-1-6-Spring中的应用"><a href="#6-1-6-Spring中的应用" class="headerlink" title="6.1.6. Spring中的应用"></a>6.1.6. Spring中的应用</h3><p>为什么实现了 <code>BeanPostProcessor</code> 接口后就能够在 Bean 生命周期的各个阶段进行拓展呢？</p>
<p>这<strong>使用了模板方法设计模式。</strong></p>
<p>现有如下代码，模拟 <code>BeanFactory</code> 构造 Bean：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">"构造 "</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">"依赖注入 "</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">"初始化 "</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>假设现在需要在依赖注入之后，初始化之前进行其他的操作，那首先能想到的就是在这个位置直接书写相关操作的代码，但这会使代码更加臃肿、增加耦合性，显然不是一种好方式。</p>
<p>可以定义一个接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>然后对 <code>MyBeanFactory</code> 进行修改：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">"构造 "</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">"依赖注入 "</span> + bean);</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : processors) {</span><br><span class="line">            processor.inject(bean);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"初始化 "</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProcessor</span><span class="params">(BeanPostProcessor processor)</span> {</span><br><span class="line">        processors.add(processor);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>之后如果需要拓展，调用 <code>MyBeanFactory</code> 实例的 <code>addProcessor()</code> 方法添加拓展逻辑即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">"解析 @Autowired"</span>));</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">"解析 @Resource"</span>));</span><br><span class="line">    beanFactory.getBean();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造 java.lang.Object@49097b5d</span><br><span class="line">依赖注入 java.lang.Object@49097b5d</span><br><span class="line">解析 @Autowired</span><br><span class="line">解析 @Resource</span><br><span class="line">初始化 java.lang.Object@49097b5d</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="6-2-策略模式"><a href="#6-2-策略模式" class="headerlink" title="6.2. 策略模式"></a>6.2. 策略模式</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1. 概述"></a>6.2.1. 概述</h3><p>先看下面的图片，我们去旅游选择出行方式能有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>
<p><img src="/./assets/1709470465966-8cdf9ff4-996c-454b-a9d9-3dfa25bd6d0f.png" alt="img"></p>
<p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，既可以选择IDEA进行开发，也可以使用Eclipse进行开发，也可以使用其他的一些开发工具。</p>
<p><img src="/./assets/1709470465933-3edc2bd7-0f33-4b46-85c8-b2424204c8ef.png" alt="img"></p>
<p>从第一张图可以看到，不管我们选择哪种交通方式，最终都是要到达目的地。从第二张图可以看到，不管程序猿使用哪个开发工具，他最终的目的就是开发出来一款软件。注意，这两个例子其实描述的就是策略模式。</p>
<p>那么什么是策略模式呢？接下来，我们就来看一看策略模式的概念。</p>
<p>策略模式定义了一系列算法，并将每个算法封装起来（你可以理解成IDEA就是一个算法，Eclipse也是一个算法，这些算法都是用来进行代码开发的，是不是啊！），使它们可以相互替换（也就是说既可以用IDEA进行开发，也可以用Eclipse进行开发），且算法的变化不会影响使用算法的客户（你可以把程序猿理解成就是客户，客户用IDEA进行代码开发或者用Eclipse进行代码开发，最终的目的都是一样的，所以算法的变化并不影响使用算法的客户）。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。当然，策略模式里面有一个角色，该角色就是专门对这些算法进行管理的，也就是说我们可以通过该角色去选择使用哪个算法来实现我们所想要达到的一个目的。</p>
<h3 id="6-2-2-结构"><a href="#6-2-2-结构" class="headerlink" title="6.2.2. 结构"></a>6.2.2. 结构</h3><p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。你想啊，IDEA底层的算法和Eclipse底层的算法是不一样的，但是咱们可以向上抽取啊，抽取出来一个抽象方法，这样就起到了一个规范的作用，用的时候我们不必管底层用的是什么算法，因为咱们最终的目的就是进行代码开发。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。注意了，这里说的环境类就是对算法对象进行管理的角色。</li>
</ul>
<hr>
<h3 id="6-2-3-策略模式案例"><a href="#6-2-3-策略模式案例" class="headerlink" title="6.2.3. 策略模式案例"></a>6.2.3. 策略模式案例</h3><p>接下来，我们便通过一个案例来让大家再去理解一下策略模式，这个案例就是促销活动。</p>
<h4 id="6-2-3-1-分析"><a href="#6-2-3-1-分析" class="headerlink" title="6.2.3.1. 分析"></a>6.2.3.1. 分析</h4><p>话说有一家百货公司在定年度的促销活动，针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。</p>
<p>下面我们就来分析一下该案例应该如何去实现。</p>
<p>针对于不同的节日推出不同的促销活动，那么不同的促销活动就是不同的算法，如果现有一个促销活动是买一送一，那么百货公司既可以将其应用在春节，也可以将其应用在中秋节，还可以将其应用在圣诞节；如果还有一个促销活动，即满200减50，那么也是同样的道理，百货公司也可以将其应用在春节、中秋节或者圣诞节。你会发现，这些促销活动的算法是可以相互替换的。</p>
<p>明确了这点之后，下面我们再来看一下下面这张类图。</p>
<p><img src="/./assets/1709470465981-4ea87881-4f78-4395-8d40-008fcdb67fe1.png" alt="img"></p>
<p>可以看到，在顶部我们定义了一个策略接口，当然它是属于抽象策略类角色，而且它里面定义了一个show方法，该方法就是用于展示促销活动的内容的。此外，该策略接口下面还有三个子实现类，而每一个子实现类就是具体算法的封装类，也就是具体策略类，当然它们都得要求去重写父接口中的show方法以便进行促销活动内容的一个展示。</p>
<p>注意了，以上类图的左侧还有一个促销员类，它在这儿充当的就是环境类角色。在该类里面，声明了一个策略接口的变量，该变量就是用来管理具体的策略算法的。此外，我们还为该类提供了一个有参构造，以便为策略接口对象进行赋值，当然了，在该类里面，你还可以为声明的策略接口变量提供对应的getter和setter方法，只不过在以上类图中我没有体现出来而已。最后，该类里面还有一个叫salesManShow的方法，它是由促销员给客户去展示促销活动内容的。</p>
<p>以上类图分析完了之后，接下来我们就要编写代码实现以上案例了。</p>
<h4 id="6-2-3-2-实现"><a href="#6-2-3-2-实现" class="headerlink" title="6.2.3.2. 实现"></a>6.2.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即strategy，也即策略模式的具体代码我们是放在了该包下。</p>
<p>然后，创建策略接口，即百货公司所有促销活动的共同接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象策略类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 20:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建具体的策略算法类。这里我们先创建一个StrategyA类，它表示的是买一送一的促销活动。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类，封装算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"买一送一"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建一个StrategyB类，它表示的是满200元减50元的促销活动。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类，封装算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"满200元减50元"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再再创建一个StrategyC类，它表示的是满1000元加1元换购任意200元以下商品的促销活动。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类，封装算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"满1000元加一元换购任意200元以下商品"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建促销员类，它对应策略模式里面的环境类角色。环境类是用于连接上下文的，在该案例中，它是用于把促销活动推销给客户的，所以这里可以理解为促销员（或者销售员）。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 促销员类（环境类）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 20:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合策略接口对象</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过以下有参构造为上面定义的成员变量赋值（即设置具体策略类对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> {</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Strategy <span class="title function_">getStrategy</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> {</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由促销员展示促销活动给用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span> {</span><br><span class="line">        strategy.show();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个客户端类进行测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-02 20:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 春节来了，使用春节促销活动</span></span><br><span class="line">        <span class="comment">// 创建促销员类对象，注意，在创建的时候必须传递具体的促销活动对象</span></span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(<span class="keyword">new</span> <span class="title class_">StrategyA</span>());</span><br><span class="line">        <span class="comment">// 促销员开始展示促销活动</span></span><br><span class="line">        salesMan.salesManShow();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========================="</span>);</span><br><span class="line">        <span class="comment">// 中秋节到了，使用中秋节的促销活动</span></span><br><span class="line">        salesMan.setStrategy(<span class="keyword">new</span> <span class="title class_">StrategyB</span>());</span><br><span class="line">        <span class="comment">// 促销员开始展示促销活动</span></span><br><span class="line">        salesMan.salesManShow();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========================="</span>);</span><br><span class="line">        <span class="comment">// 圣诞节到了，使用圣诞节的促销活动</span></span><br><span class="line">        salesMan.setStrategy(<span class="keyword">new</span> <span class="title class_">StrategyC</span>());</span><br><span class="line">        <span class="comment">// 促销员开始展示促销活动</span></span><br><span class="line">        salesMan.salesManShow();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到确实都展示出了相应的促销活动。</p>
<p><img src="/./assets/1709470465963-52911ca9-6067-433e-9046-3121e1d24ff8.png" alt="img"></p>
<p>以上就是策略模式的案例，大家通过这个案例再好好的去理解一下策略模式。</p>
<hr>
<h3 id="6-2-4-策略模式的优缺点以及使用场景"><a href="#6-2-4-策略模式的优缺点以及使用场景" class="headerlink" title="6.2.4. 策略模式的优缺点以及使用场景"></a>6.2.4. 策略模式的优缺点以及使用场景</h3><p>接下来，我们就来看看策略模式的优缺点以及使用场景。</p>
<h4 id="6-2-4-1-优缺点"><a href="#6-2-4-1-优缺点" class="headerlink" title="6.2.4.1. 优缺点"></a>6.2.4.1. 优缺点</h4><h5 id="6-2-4-1-1-优点"><a href="#6-2-4-1-1-优点" class="headerlink" title="6.2.4.1.1. 优点"></a>6.2.4.1.1. 优点</h5><p>关于策略模式的优点，我总结出来了下面三个。</p>
<ol>
<li>策略类之间可以自由切换。由于策略类都实现同一个接口（或者继承同一个抽象类），所以使它们之间可以自由切换。记住，策略类本身封装的就是算法，多个策略类，那么封装的就是多个算法，而算法和算法之间是可以相互替换的。</li>
<li>易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合”开闭原则”。</li>
<li>避免使用多重条件选择语句（例如if else），充分体现面向对象设计思想。对于策略模式来说的话，我们是要在多个算法之间进行一个选择的，而现在进行选择的话，就不需要使用if else语句了，而是使用策略模式来进行选择。</li>
</ol>
<h5 id="6-2-4-1-2-缺点"><a href="#6-2-4-1-2-缺点" class="headerlink" title="6.2.4.1.2. 缺点"></a>6.2.4.1.2. 缺点</h5><p>关于策略模式的优点，我总结出来了下面两个。</p>
<ol>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。使用策略模式虽然会产生很多策略类，但是对于同一个策略类来说，它里面的算法是一样的，那么我们就没有必要去创建多个策略类对象了，所以此时我们就可以使用享元模式来减少对象的数量。当然，这块就是策略模式和享元模式的混合使用了。</li>
</ol>
<h4 id="6-2-4-2-使用场景"><a href="#6-2-4-2-使用场景" class="headerlink" title="6.2.4.2. 使用场景"></a>6.2.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用策略模式了。</p>
<ul>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中，因为算法之间是可以相互替换的。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。也就是说，如果你的程序里面出现了大量的if else这样的语句，那么你就可以选择使用策略模式进行一个改进了。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。也就是说，作为一个用户，当他并不需要去关注算法底层的实现时，就可以选择使用策略模式将他和算法进行一个分离（或者解耦）。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ul>
<hr>
<h3 id="6-2-5-策略模式在JDK源码中的应用"><a href="#6-2-5-策略模式在JDK源码中的应用" class="headerlink" title="6.2.5. 策略模式在JDK源码中的应用"></a>6.2.5. 策略模式在JDK源码中的应用</h3><p>接下来，我们就来看一看策略模式在JDK源码里面是如何来应用的。</p>
<p>在JDK源码里面，其实很多地方都用到了策略模式，而在本套系列课程中，我们只看一个接口就行了，这个接口就是Comparator，它就用到了策略模式。</p>
<p>在Arrays类中有一个sort方法，方法定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> {</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">            sort(a);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，该sort方法是一个静态方法，它是用于对第一个参数所代表的数组里面的元素进行排序的。既然是排序，那么是以什么样的一个规则进行排序的呢？这就得看第二个参数了，即Comparator接口，很显然，我们在传参时，应该传递的是该接口的子实现类对象。这样，该sort方法就会根据我们传递的子实现类对象里面的策略（或者规则）对数组里面的元素进行排序了。</p>
<p>其实，Arrays就是一个环境角色类，它里面的这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序，就比如下面的测试类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Integer[] data = {<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>};</span><br><span class="line">        <span class="comment">// 调用Arrays里面的sort方法对以上数组实现降序排序</span></span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() {</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> {</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">// 最后排序的结果：[12, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大家不妨去运行一下以上测试类，但是打印的结果肯定是按从大到小的顺序排序之后的数组。</p>
<p>在以上测试类中，我们在调用Arrays类中的sort方法时，第二个参数传递的是Comparator接口的子实现类对象（当然了，是以匿名内部类的形式传递的）。所以，Comparator接口充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。很显然，环境角色类（Arrays）应该持有抽象策略的引用来调用，通过该引用它就可以调用具体策略中的方法进行一系列的操作了。</p>
<p>所以，现在我们只需要去验证一下Arrays类里面的sort方法到底有没有使用Comparator子实现类中的compare方法就行了，如果使用了的话，那么就表明用的正是策略模式。</p>
<p>继续查看Arrays类里面的sort方法的源码，可以看到它又调用了TimSort类中的sort方法，如果你传递了具体策略（即Comparator接口的子实现类对象），那么程序势必就要走这儿的代码。因此，接下来我们就要去看看TimSort类中的sort方法了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimSort</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi, Comparator&lt;? <span class="built_in">super</span> T&gt; c,</span></span><br><span class="line"><span class="params">                         T[] work, <span class="type">int</span> workBase, <span class="type">int</span> workLen)</span> {</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="literal">null</span> &amp;&amp; a != <span class="literal">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nRemaining</span>  <span class="operator">=</span> hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">initRunLen</span> <span class="operator">=</span> countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">         * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">         * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TimSort&lt;T&gt; ts = <span class="keyword">new</span> <span class="title class_">TimSort</span>&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRun</span> <span class="operator">=</span> minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">// Identify next run</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">runLen</span> <span class="operator">=</span> countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">force</span> <span class="operator">=</span> nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">                runLen = force;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        } <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，该方法也是一个静态方法，它里面的参数有很多很多，不过大家在这块只需要去关注c参数就行，因为它就是我们传递的Comparator接口的子实现类对象。而且，该方法里面的代码也挺多的，不过大家不用全部搞明白，只须跟随我的步伐就行。</p>
<p>在往下查看以上sort方法时，你会发现在countRunAndMakeAscending方法中用到了c参数，所以我们再跟踪进去countRunAndMakeAscending方法里面看看。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimSort</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi,</span></span><br><span class="line"><span class="params">                                                    Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> {</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="type">int</span> <span class="variable">runHi</span> <span class="operator">=</span> lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) { <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">            runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        } <span class="keyword">else</span> {                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">            runHi++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，该方法里面的参数也有很多很多，这里大家只需要去关注c参数就行。不知你看到没有，在该方法里面的if else判断语句中就用到了c参数，而且调用的是其里面的compare方法，所以我们就验证了一点，即Arrays类里面的sort方法对数组中的元素进行排序时，正好就用到了Comparator子实现类对象中的compare方法，这便是策略模式。</p>
<p>当然，这个策略模式可能跟我们上面所讲的那种标准的策略模式稍微有一些区别，但是大家在这儿主要理解的就是策略模式思想的运用，形式上虽有变化，但思想上是相通的。</p>
<hr>
<hr>
<h2 id="6-3-命令模式"><a href="#6-3-命令模式" class="headerlink" title="6.3. 命令模式"></a>6.3. 命令模式</h2><h3 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1. 概述"></a>6.3.1. 概述</h3><p>首先，我们先来看下这样一个场景：在日常生活中，我们出去吃饭都会遇到下面的场景。</p>
<p><img src="/./assets/1709612487651-d0b77534-f343-4681-b89c-6f20072fd348.png" alt="img"></p>
<p>顾客把订单交给女服务员，女服务员拿到这个订单之后放在订单柜台，然后喊一声：“订单来了！”，厨师拿到这个订单之后就开始准备餐点。</p>
<p>这里我们来思考一个问题，如果真要去实现以上这样一个场景的话，那么又该如何来实现呢？</p>
<p>大家想一想，服务员要下单的话，那么她是不是得把单下给某一个厨师呀！所以，要是按照之前的做法，那就是在服务员对象里面创建一个厨师对象，然后服务员下单的话就相当于是调用厨师对象中的方法进行餐点准备。但是，这样做的话，服务员对象和厨师对象就耦合在一起了，而这便会导致一个问题，就是如果后期餐馆要发展扩大，想要把原有的厨师换掉，改换另外一个厨师，那么此时你会发现服务员对象里面的代码也需要进行一个修改，而这就违背开闭原则了。</p>
<p>出现以上问题之后，我们又应该如何来解决呢？这时，我们就可以使用命令模式了。那什么是命令模式呢？下面我们就来看看它的概念。</p>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<p>看完上面命令模式的概念，一时半会看不懂咋办呢？我们可以结合一开始的例子来理解。</p>
<p>命令模式是说将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这里，我们结合一开始的例子可以这样来理解，发出请求的就是服务员对象，而执行请求的则是厨师对象，依据命令模式的概念，现在我们所要做的就是将厨师和服务员这俩对象进行分割，不能让它们耦合在一起。</p>
<p>这样，它们两者之间则通过命令对象进行沟通，服务员下命令，具体是谁去做，咱们不用过多的去关注，厨师对象拿到这个命令之后，开始准备餐点就行，而且具体是哪个服务员下的单，咱们也不需要去关注，这其实也是使用命令模式的一个好处。</p>
<p>理解了命令模式的概念之后，接下来，我们再来看看命令模式的结构，也就是说命令模式包含哪些角色。</p>
<h3 id="6-3-2-结构"><a href="#6-3-2-结构" class="headerlink" title="6.3.2. 结构"></a>6.3.2. 结构</h3><p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色：定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。命令下达之后，肯定要明确到底是由谁来执行，那么到底由谁来执行呢？接收者，例如一开始的例子中的厨师就属于接收者。</li>
<li>实现者/接收者（Receiver）角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。也就是说，人人都可以成为厨师，只要他能做饭。</li>
<li>调用者/请求者（Invoker）角色：要求命令对象执行请求，通常会持有命令对象，并且可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。如果请求者（或者调用者）要下发命令，那么它就得持有命令对象。注意了，上面例子中的服务员就属于请求者（或者调用者）。而且，请求者（或者调用者）可以持有很多的命令对象，这是因为一个服务员她可以下多个订单。此外，请求者（或者调用者）还相当于是使用命令对象的入口，也就是说服务员就是命令模式里面的入口，客户下单之后，总得由服务员去下发命令，是不是啊！</li>
</ul>
<h3 id="6-3-3-命令模式案例"><a href="#6-3-3-命令模式案例" class="headerlink" title="6.3.3. 命令模式案例"></a>6.3.3. 命令模式案例</h3><p>接下来，我们就要编写代码实现以上案例了，通过该案例大家再去好好理解一下命令模式。</p>
<h4 id="6-3-3-1-分析"><a href="#6-3-3-1-分析" class="headerlink" title="6.3.3.1. 分析"></a>6.3.3.1. 分析</h4><p>将上面的案例用代码实现，那么我们就需要分析出命令模式里面的角色在该案例中到底是由谁来充当的了。</p>
<p>首先，来看一下服务员她充当的是什么角色？服务员充当的是调用者角色，是由她来发起命令的，给谁发送命令呢？给厨师发送命令。</p>
<p>然后，来看一下厨师他充当的是什么角色？厨师充当的是接收者角色，真正命令执行的对象。</p>
<p>接着，再来看一下订单。它不是真正的命令，只不过命令中包含了订单。因为服务员发出命令之后，她得告诉厨师要去做什么样的一个餐品，所以命令里面就包含了订单。</p>
<p>搞清楚上面三个概念之后，下面我们再来看看这样一张类图。</p>
<p><img src="/./assets/1709612487639-3e7aaecd-f938-41dc-bf8d-8d14f52554b1.png" alt="img"></p>
<p>以上类图里面有很多类，而且它们的关系也比较复杂，下面我们一个一个来说说。</p>
<p>可以看到，有一个叫做SeniorChef的类，它就是厨师类，该类里面有一个制作食物的功能，而且该功能中有两个参数，分别表示食物的份数和名称。</p>
<p>然后，再来看一下叫做Order的类，它是订单类，该类里面有两个属性，分别是餐桌号和所点食物，而且在该类中我们还为这俩属性提供了对应的getter和setter方法。此外，大家一定注意了，所点食物是由一个Map集合来表示的，该Map集合里面的键其实就是食物的名称，而值就是食物的份数。</p>
<p>接着，我们再来看一下叫做Command的接口，它充当的是抽象命令类角色，里面只有一个方法，即execute（执行）。而且，它下面还有一个子实现类，即OrderCommand，该类里面聚合进来了厨师类变量和订单类变量。在该类里面，除了重写父接口里面的execute方法之外，它还提供了一个有参的构造方法为聚合进来的俩变量赋值。</p>
<p>总之，大家一定要搞清楚OrderCommand类，它既实现了Command接口，又聚合了订单以及厨师对象。</p>
<p>最后，我们再来看一下叫做Waitor的类，它是服务员类，它里面聚合了一个Command接口的List集合。为什么会这样呢？这是因为一个服务员她可以发出多个命令啊！</p>
<p>而且，从上可以看到，在该类里面，我们提供了两个方法：一个是setCommand，它是用来将Command接口类型的对象存储到List集合中去的；一个是orderUp，它是用来发出命令的。</p>
<p>当然了，以上类图里面还有一个客户端类，即Client，该类我们就不用过多的去关注它了，我们主要关注的是上面5个类或者接口，以及它们之间的关系。</p>
<h4 id="6-3-3-2-实现"><a href="#6-3-3-2-实现" class="headerlink" title="6.3.3.2. 实现"></a>6.3.3.2. 实现</h4><p>上面我们分析了一下点餐案例里面所涉及到的类，以及类和类之间的关系。接下来，我们就要编写代码来实现该案例了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即command，也即命令模式的具体代码我们是放在了该包下。</p>
<p>然后，创建订单类，这里我们就起名为Order了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-03 14:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所下的餐品及份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> {</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFood</span><span class="params">(String name, <span class="type">int</span> num)</span> {</span><br><span class="line">        foodDic.put(name, num);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建命令模式里面的接收者，即厨师类，这里我们就起名为SeniorChef了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 厨师类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-03 14:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制作食物的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(String name, <span class="type">int</span> num)</span> {</span><br><span class="line">        System.out.println(num + <span class="string">"份"</span> + name); <span class="comment">// 这儿输出的是多少份什么食物</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建命令模式里面的抽象命令类，这里我们是将其定义成了一个接口，名字就叫Command。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象命令类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-03 14:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>; <span class="comment">// 只需要定义一个统一的执行方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再紧接着，创建命令模式里面的具体命令类，即以上Command接口的子实现类，这里我们就起名为OrderCommand了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的命令类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-03 14:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体命令类通常会持有接收者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="comment">// 此外，具体命令类还得持有订单对象，因为要让厨师去做菜，还得告诉他需要做哪些菜</span></span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个有参构造方法为以上两个成员变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span> {</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">"桌的订单："</span>);</span><br><span class="line">        <span class="comment">// 发送命令，让厨师去做订单里面的菜...</span></span><br><span class="line">        Map&lt;String, Integer&gt; foodDic = order.getFoodDic();</span><br><span class="line">        <span class="comment">// 遍历Map集合</span></span><br><span class="line">        Set&lt;String&gt; keys = foodDic.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String foodName : keys) {</span><br><span class="line">            receiver.makeFood(foodName, foodDic.get(foodName));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">"桌的饭准备完毕！！！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>具体命令类创建完毕之后，接下来，我们创建命令模式里面的请求者，即服务员类，这里我们就起名为Waitor了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务员类（属于请求者角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-03 15:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求者可以持有多个命令对象，这是因为一个服务员她可以下多个订单，即发出多个命令</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Command&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span> {</span><br><span class="line">        <span class="comment">// 将cmd对象存储到List集合中</span></span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起命令的功能。这儿，服务员只需喊一声订单来了就行，然后厨师就开始去执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"美女服务员：叮咚，大厨，新订单来了......"</span>);</span><br><span class="line">        <span class="comment">// 遍历List集合</span></span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) {</span><br><span class="line">            <span class="keyword">if</span> (command != <span class="literal">null</span>) {</span><br><span class="line">                command.execute();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-03 15:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建第一个订单对象</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.setFood(<span class="string">"西红柿鸡蛋面"</span>, <span class="number">1</span>);</span><br><span class="line">        order1.setFood(<span class="string">"小杯可乐"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第二个订单对象</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setDiningTable(<span class="number">2</span>);</span><br><span class="line">        order2.setFood(<span class="string">"尖椒肉丝盖饭"</span>, <span class="number">1</span>);</span><br><span class="line">        order2.setFood(<span class="string">"小杯雪碧"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建接收者，即厨师对象</span></span><br><span class="line">        <span class="type">SeniorChef</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">// 将订单和接收者封装成命令对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用者，即服务员对象</span></span><br><span class="line">        <span class="type">Waitor</span> <span class="variable">invoke</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waitor</span>();</span><br><span class="line">        <span class="comment">// 设置命令</span></span><br><span class="line">        invoke.setCommand(cmd1);</span><br><span class="line">        invoke.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让服务员发起命令，即将订单带到柜台，并向厨师喊：订单来了</span></span><br><span class="line">        invoke.orderUp();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到确实是我们所想要的结果。</p>
<p><img src="/./assets/1709612487625-158b87d8-bd12-46b3-aeea-556a1650ef24.png" alt="img"></p>
<p>至此，以上点餐案例我们就做完了。做是做完了，但是大家不觉得现在这个系统结构变得越来越复杂了吗？是不是有这样一个感受啊！嘻嘻😘</p>
<hr>
<h3 id="6-3-4-命令模式的优缺点以及使用场景"><a href="#6-3-4-命令模式的优缺点以及使用场景" class="headerlink" title="6.3.4. 命令模式的优缺点以及使用场景"></a>6.3.4. 命令模式的优缺点以及使用场景</h3><p>接下来，我们就来看一下命令模式的优缺点以及使用场景。</p>
<h4 id="6-3-4-1-优缺点"><a href="#6-3-4-1-优缺点" class="headerlink" title="6.3.4.1. 优缺点"></a>6.3.4.1. 优缺点</h4><h5 id="6-3-4-1-1-优点"><a href="#6-3-4-1-1-优点" class="headerlink" title="6.3.4.1.1. 优点"></a>6.3.4.1.1. 优点</h5><p>关于命令模式的优点，我总结出了下面四点。</p>
<ol>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。说人话，降低的是谁和谁之间的耦合度啊？拿上面案例来说，降低的是调用者和接收者这两者之间的耦合度。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，即它满足”开闭原则”，对扩展比较灵活。也就是说，后期如果我们想要增加一个具体的命令的话，那么只需要再定义一个类就可以了，而不必再去改原有的代码。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，而这个组合命令我们就可以将其称为宏命令。当然了，上述案例中还未涉及到宏命令。</li>
<li>方便实现Undo和Redo操作。命令模式可以与后面我们即将要学习的备忘录模式结合，实现命令的撤销与恢复。什么是Undo，什么又是Redo呢？Undo指的是命令的撤销，例如下了一个订单之后，我现在又不想下了，那么这时系统就得支持撤销操作了；Redo指的是命令的恢复，例如我现在又想再次下单，那么这时系统就得支持恢复操作了。</li>
</ol>
<h5 id="6-3-4-1-2-缺点"><a href="#6-3-4-1-2-缺点" class="headerlink" title="6.3.4.1.2. 缺点"></a>6.3.4.1.2. 缺点</h5><p>关于命令模式的缺点，我总结出了下面两点。</p>
<ol>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。但是大家一定要清楚，它并不会导致类爆炸这种现象发生。</li>
<li>系统结构更加复杂。通过上述案例，相信大家能感受到我们的整个系统架构变得更加复杂了，相应地，这对程序员的要求就变得比较高了。</li>
</ol>
<h4 id="6-3-4-2-使用场景"><a href="#6-3-4-2-使用场景" class="headerlink" title="6.3.4.2. 使用场景"></a>6.3.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用命令模式了。</p>
<ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。这里，我还得强调一下，是调用者和接收者之间解除耦合。我为什么得强调这一点呢？因为我们之前学习过很多设计模式，它们都可以实现解除耦合，但是大家要注意解除耦合的角色是不一样的。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。这说的是啥意思啊？这里我稍微给大家解释解释，回到上述案例中，对于请求者来说，它里面用了一个List集合来存储多个命令对象，而在orderUp方法里面去执行命令时，我们是不是得遍历List集合啊，既然是遍历List集合，那么是不是得按照一个顺序进行遍历啊，这也就是说，谁先下单，那谁的餐就先做好，这便是将请求排队。</li>
<li>系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作。目前，撤销操作和恢复操作我们并没有实现，因为命令模式得和备忘录模式结合之后才能实现命令的撤销与恢复。</li>
</ul>
<h3 id="6-3-5-命令模式在JDK源码中的应用"><a href="#6-3-5-命令模式在JDK源码中的应用" class="headerlink" title="6.3.5. 命令模式在JDK源码中的应用"></a>6.3.5. 命令模式在JDK源码中的应用</h3><p>接下来，我们就来看一看命令模式在JDK源码里面是如何来应用的。</p>
<p>相信大家对Runable这个接口并不陌生，这里我要说的是该接口就用到了一个典型的命令模式。下面我就来说一下该命令模式里面角色的一个划分。</p>
<p>Runnable担当的是抽象命令角色，因为它是一个接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令接口（抽象命令角色）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Thread充当的是调用者角色，start方法就是其执行方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!started) {</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上可以看到，在Thread类的成员位置声明了一个Runable类型的变量，这是因为我们之前说过，调用者里面通常会持有命令对象。声明完这么一个变量之后，我们还得为其设置值，至于如何设置，我在这里就不做具体的分析了。</p>
<p>此外，在Thread类里面还有一个start方法，当咱们通过调用者对象去调用该<code>start方法</code>时，实质上就是去执行命令对象里面的run方法。而且，如果你仔细查看start方法的源码，那么你会发现它里面又调用了一个native方法，即<code>start0()</code>，该方法是调用系统资源来开启一个线程的。</p>
<p>接下来，再来看一下我创建的具体命令类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk Runnable 命令模式</span></span><br><span class="line"><span class="comment"> *		TurnOffThread：属于具体命令角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOffThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOffThread</span><span class="params">(Receiver receiver)</span> {</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        receiver.turnOFF();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，在TurnOffThread类的成员位置声明了一个Receiver类型的变量，想必大家都知道了，Receiver类充当的就是接收者角色，由于接收者是对程序员开放的，也就是说可以由开发者自己去定义接收者，所以大家可以自行去定义，只不过在这里我没有定义出来而已！</p>
<p>而且，之前我们也说过，具体命令类里面通常会持有接收者对象，这就是为何我们要在TurnOffThread类的成员位置声明一个Receiver类型的变量的原因。</p>
<p>此外，我们还能看到，TurnOffThread类除了重写命令接口里面的run方法之外，还提供了一个有参构造为Receiver类型的成员变量赋值。而且，大家还要注意，重写的run方法里面是直接去调用接收者对象里面的方法来进行具体的业务逻辑处理的。</p>
<p>以上就是我们分析出来的应用在JDK源码里面的命令模式的那些角色，相信大家这会还并不陌生。</p>
<p>当然了，最后还应该有一个测试类，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">        <span class="type">TurnOffThread</span> <span class="variable">turnOffThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOffThread</span>(receiver);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(turnOffThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里我就不运行以上测试类给大家看打印结果了，因为我们还没有定义出Receiver类（即接收者）来。</p>
<p>至此，大家体会到了命令模式在JDK源码里面的具体应用了吧！</p>
<hr>
<h2 id="6-4-责任链模式"><a href="#6-4-责任链模式" class="headerlink" title="6.4. 责任链模式"></a>6.4. 责任链模式</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1. 概述"></a>6.4.1. 概述</h3><p>在学习责任链模式之前，我们先来看一下下面这段描述。</p>
<p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但是每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了员工请假的难度。因为领导有很多，员工到底找哪位领导他还得自己判断，所以这会显得特别特别麻烦。这样的例子还有很多，如找领导出差报销、生活中的”击鼓传花”游戏等。</p>
<p>说了这么多，不知你有没有在公司请过假，要是你请过假，想想是不是这么一回事啊！很显然，在该例子中，请假就是一个请求，而且多个对象都可以处理该请求，有部门负责人、副总经理、总经理等，他们都可以进行批假，但是每个对象的处理条件或权限不同，比如部门负责人有可能只能批1~2天的假，一旦超过这一请假天数，员工就得去找部门负责人的顶头上司，也就是副总经理了，要是还超过了副总经理批假的一个范围的话，那么员工就得再去找总经理批假了，这是不是就增加了员工请假的难度啊！</p>
<p>既然问题出现了，那么又该如何去解决呢？使用责任链模式。那什么又是责任链模式呢？下面我们就来看一看它的概念。</p>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>很多人看完，完全不知道啥意思，这里我就为大家稍微解释解释。就以员工请假案例来说，请求发送者指的就是员工，因为是员工（例如张三）要请假的；多个请求处理者指的是部门负责人、副总经理、总经理等这些人。这样，张三请假的示意图就是下面这样了。</p>
<p><img src="/./assets/1709612575174-f18754a0-253f-462a-914e-9976221bd5ff.png" alt="img"></p>
<p>从上图中可以看到，张三要请假的话，那么他只需要去找自己部门的负责人就可以了，因为对于他来说，他肯定知道自己部门的负责人是谁。然后，部门负责人会根据张三请假的天数来决定是否批假，如果部门负责人能批假，那么自然就帮张三批了；可如果他不能批，那么他就会去找他的顶头上司，即副总经理，因为他们已经连成一条链了。同理，副总经理也是一样，他也会根据他所能批准的请假天数来判断，如果在自己的批准范围之内，那么废话不多说，直接批假；如果批不了的话，那么再去找对应他的顶头上司，即总经理。于此一来，当整个链走完，张三请假的流程就算是结束了。</p>
<p>理解了责任链模式的概念之后，接下来，我们再来看一下责任链模式的结构。</p>
<h3 id="6-4-2-结构"><a href="#6-4-2-结构" class="headerlink" title="6.4.2. 结构"></a>6.4.2. 结构</h3><p>责任链模式主要包含以下角色：</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接（即记住下一个对象的引用）。注意了，对于该角色，我们既可以定义成接口，也可以定义成抽象类，一般来说，我们都会定义成抽象类。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，若可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。也就是说，客户类不需要去找对应的对象进行处理，而只需将处理链创建好即可。就拿上述张三请假的示意图来说，他只需要找他自己的部门负责人即可，至于请假流程要经过哪几步，他并不需要去关注。</li>
</ul>
<h3 id="6-4-3-责任链模式案例"><a href="#6-4-3-责任链模式案例" class="headerlink" title="6.4.3. 责任链模式案例"></a>6.4.3. 责任链模式案例</h3><p>接下来，我们通过一个案例来让大家更好地去理解一下责任链模式。</p>
<h4 id="6-4-3-1-分析"><a href="#6-4-3-1-分析" class="headerlink" title="6.4.3.1. 分析"></a>6.4.3.1. 分析</h4><p>现需要开发一个请假流程控制系统。请一天以下的假只需要小组长同意即可；请1天到3天的假还需要部门经理同意；请3天到7天的假还需要总经理同意才行。</p>
<p>很明显，要想解决该需求，我们就得使用责任链模式。下面是我为该请假流程控制系统设计出的类图，大家可要好好看看哟！</p>
<p><img src="/./assets/1709615987584-100f04fa-5509-459a-83b5-72bd1326963e.png" alt="img">过以上类图，大家可以看到要设计的请假流程控制系统究竟都涉及到了哪些类，以及类和类之间的关系。下面，我就为大家稍微讲解一下以上类图。</p>
<p>可以看到，上图左侧有一个请假条类，即LeaveRequest，它里边包含有name、num和content这仨属性，它们分别表示请假人的名称、请假的天数以及请假的原因。而且，在该类里面，我们还提供了一个构造方法，在构造方法里面你需要传入三个参数分别为name、num和content这仨属性赋值，当然了，这仨属性肯定还应有各自对应的getter方法，不过大家在这里要注意，我们并没有为这仨属性提供对应的setter方法，这是因为我们已然通过构造方法为这仨属性赋值了，而不再需要通过setter方法来进行赋值了，当然了，你也可以提供，不过这个得根据你具体的需求来定了。</p>
<p>在上图右侧，我们能看到一个叫Handler的类，该类就充当着责任链模式里面的抽象处理者角色，它里面定义了三个常量，分别是NUM_ONE（值为1）、NUM_THREE（值为3）、NUM_SEVEN（值为7），很显然这三个常量的值就是请假天数的临界点。注意，它们都是protected来修饰的，这样，Handler类的子类就可以直接去使用它们了。</p>
<p>为啥要在Handler类里面定义三个常量呢？看一下最开始的需求，你就知道了。如果员工只请1天以下的假，那么小组长同意就可以了；如果员工请1-3天的假，那么部门经理同意就可以了；如果员工请3-7天的假，那么总经理同意就可以了，所以在Handler类里面我们就要定义NUM_ONE（值为1）、NUM_THREE（值为3）、NUM_SEVEN（值为7）这三个常量了，这样，我们用起来也会方便一些。</p>
<p>我们还是继续来看一下Handler类，可以看到它里面还定义了numStart和numEnd两个成员变量，它俩分别表示请假的开始时间和结束时间。啥意思呢？以员工请假1天以下来说，很显然，他就得找小组长来批假了，在小组长看来，请假的开始时间就是0天，而请假的结束时间则是1天。不知我这样解释，大家明白了没有？</p>
<p>此外，Handler类里面还定义有一个成员变量，那就是nextHandler，且还是Handler类型的，也即后继者，所以从上图中我们可以看到该类是自己聚合了自己。</p>
<p>其实，在讲责任链模式的概念时，我就讲过，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链。对此，在该案例里面是这样体现出来的：小组长的后继者是部门经理，而部门经理的后继者就是总经理。所以，大家明白了没？</p>
<p>当然了，Handler类里面还提供了两个构造方法，除此之外，它里面还有三个方法，一个是setNextHandler，用于设置后继者；一个是submit，用于提交请假的请求；还有一个是handleLeave，用于处理请假的请求。</p>
<p>至此，对于这个Handler类，我们就算是分析完了。接下来，我们就来看看Handler类的一些子类。</p>
<p>Handler类的子类在这里我设计出来了三个，一个是GroupLeader，即小组长；一个是Manager，即部门经理；还有一个是GeneralManager，即总经理。由于在父类（即Handler类）中定义了一个抽象的方法，即handleLeave，所以这仨子类就必须得去重写该方法了。当然了，它们都还分别定义有各自对应的构造方法。</p>
<p>以上就是我们对类图的分析，类图中所涉及到的类，以及类和类之间的关系，相信大家也已经搞清楚了。当然了，以上类图中还有一个客户端类，该类非常简单，不值得我们去关注它，所以我就没分析它了。</p>
<h4 id="6-4-3-2-实现"><a href="#6-4-3-2-实现" class="headerlink" title="6.4.3.2. 实现"></a>6.4.3.2. 实现</h4><p>上面我们已经分析过了案例里面所涉及到的类，以及类和类之间的关系，接下来我们就要编写代码来实现该案例了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即responsibility，也即责任链模式的具体代码我们是放在了该包下。</p>
<p>然后，创建请假条类，这里我们就起名为了LeaveRequest。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请假条类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-16 17:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请假人姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 请假天数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">// 请假内容</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建抽象处理者类，这个类我们就命名为Handler。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象处理者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-16 17:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义三个常量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart; <span class="comment">// 请假的开始时间。例如，对部门经理而言，他的numStart就是1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd; <span class="comment">// 请假的结束时间。例如，对部门经理而言，他的numEnd就是3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明后继者（即声明上级领导）</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> {</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> {</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置后继者（即设置上级领导）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各级领导处理请假条的方法。注意，该方法是一个抽象方法，因为不同的领导处理请假条可能稍微有点不一样</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交请假条。例如，张三要请假，那么他得进行一个提交，即将请假条提交给他的小组长，若小组长能处理则处理，</span></span><br><span class="line"><span class="comment">     *           若处理不了，则他就要把张三的请假条再提交给他的上级领导了，以此类推...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意了，该方法我们要声明成final的，这是因为要求子类不能去重写该方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span> {</span><br><span class="line">        <span class="comment">// 该领导进行审批</span></span><br><span class="line">        <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line">        <span class="comment">// 该领导审批完了之后，还得进行一个判断，判断他还有没有上级领导，以及请假天数是否超出他最大处理的请假天数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.nextHandler != <span class="literal">null</span> &amp;&amp; leave.getNum() &gt; <span class="built_in">this</span>.numEnd) {</span><br><span class="line">            <span class="comment">// 若还有上级并且请假天数超过了当前领导的处理范围，则提交给上级领导进行审批</span></span><br><span class="line">            <span class="built_in">this</span>.nextHandler.submit(leave);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 请假流程结束有两个条件：</span></span><br><span class="line"><span class="comment">             *      1. 当前领导没有上级领导了，也就是说当前领导就是最大的领导</span></span><br><span class="line"><span class="comment">             *      2. 请假天数在当前领导审批的范围之内</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *      例如，张三要请两天的假，由于小组长只能处理1天以下的假，所以他就会把请假条继续提交给部门经理进行审批，</span></span><br><span class="line"><span class="comment">             *      对于部门经理而言，张三请假的天数在他审批的范围之内，这样，部门经理直接审批就完事了，也就是说请假流程</span></span><br><span class="line"><span class="comment">             *      到部门经理这块就结束了，而不需要继续再往总经理那边走了。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">"流程结束！"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>抽象处理者类创建完毕之后，接下来我们就要开始创建它的一些子类了。</p>
<p>这里，我们先创建第一个子类，即小组长类，该类我们就命名为GroupLeader了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小组长类（具体的处理者）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-16 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 小组长能处理1天以下的请假</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="number">0</span>, Handler.NUM_ONE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> {</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">"请假"</span> + leave.getNum() + <span class="string">"天，"</span> + leave.getContent() + <span class="string">"。"</span>);</span><br><span class="line">        System.out.println(<span class="string">"小组长审批：同意"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建第二个子类，即部门经理类，该类我们就命名为Manager了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部门经理类（具体的处理者）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-16 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 部门经理能处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> {</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">"请假"</span> + leave.getNum() + <span class="string">"天，"</span> + leave.getContent() + <span class="string">"。"</span>);</span><br><span class="line">        System.out.println(<span class="string">"部门经理审批：同意"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧着再创建最后一个子类，即总经理类，该类我们就命名为GeneralManager了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总经理类（具体的处理者）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-16 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 总经理能处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> {</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">"请假"</span> + leave.getNum() + <span class="string">"天，"</span> + leave.getContent() + <span class="string">"。"</span>);</span><br><span class="line">        System.out.println(<span class="string">"总经理审批：同意"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，具体的处理者类我们就已经全部创建完毕了。可能有些同学会说，如果员工的请假天数超出了已知的最大处理范围，那么又该怎么办呢？很简单嘛，直接不予批准就可以了，所以大家就不要去提交这种无效的请假条了。</p>
<p>最后，我们来创建一个客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-16 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个请假条对象</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">"小明"</span>, <span class="number">4</span>, <span class="string">"身体不适"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建各级领导对象</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置处理者链，即每一个领导记住他的上一级领导</span></span><br><span class="line">        groupLeader.setNextHandler(manager);</span><br><span class="line">        manager.setNextHandler(generalManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小明提交请假申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到小明的请假天数是4天，那么就得经过小组长审批→部门经理审批→总经理审批这样一个请假流程，走完全程最终交给总经理来审批。</p>
<p><img src="/./assets/1709612575158-d42209c7-46e7-4bf1-9df0-c910c82aebd8.png" alt="img"></p>
<hr>
<h3 id="6-4-4-责任链模式的优缺点"><a href="#6-4-4-责任链模式的优缺点" class="headerlink" title="6.4.4. 责任链模式的优缺点"></a>6.4.4. 责任链模式的优缺点</h3><p>接下来，我们来看一看责任链模式的优缺点。</p>
<h4 id="6-4-4-1-优点"><a href="#6-4-4-1-优点" class="headerlink" title="6.4.4.1. 优点"></a>6.4.4.1. 优点</h4><p>责任链模式的优点还是比较多的，我总结出了如下几点。</p>
<ol>
<li>降低了对象之间的耦合度。这里，我们要明确责任链模式究竟降低了哪些对象之间的耦合度。我这里直接就给大家说了，责任链模式降低了请求发送者和请求接收者这俩之间的耦合度。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，例如，在上述案例中，如果后期员工请假还得经过董事长，那么我们只需要再去定义一个董事长类，然后在链中把董事长类的对象添加进来就可以了，这也满足了开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。例如，在上述案例中，如果后期员工请假还得经过董事长，那么我们只需要再去定义一个董事长类，然后在链中把董事长类的对象添加进来就可以了。如果后期员工请假不需要经过总经理了，那么我们只需动态地删除链内的总经理对象即可。这样，是不是就具有灵活性了啊！</li>
<li>责任链简化了对象之间的连接。一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这样就能避免使用众多的if或者if else语句了。看完上面这句话之后，有些人可能会说，这不对啊！在咱们上述案例的代码里面，不是也用到了if else语句了嘛，Handler类里面的submit方法就用到了啊！注意，这里大家一定要记住，这块所说的避免了使用众多的if或者if else语句，是针对客户端来说的。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ol>
<h4 id="6-4-4-2-缺点"><a href="#6-4-4-2-缺点" class="headerlink" title="6.4.4.2. 缺点"></a>6.4.4.2. 缺点</h4><p>关于责任链模式的缺点，我总结出了如下几点。</p>
<ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。例如，小明要是请假7天以上的话，那么他会发现没有任何领导可以处理他的请求。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。所以，职责链不易过长，适当就好。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用，就是说有可能我们会将职责链设置成了一个环形，这样运行的时候就会出问题，即造成循环调用。</li>
</ol>
<h3 id="6-4-5-责任链模式在JavaWeb源码中的应用"><a href="#6-4-5-责任链模式在JavaWeb源码中的应用" class="headerlink" title="6.4.5. 责任链模式在JavaWeb源码中的应用"></a>6.4.5. 责任链模式在JavaWeb源码中的应用</h3><p>接下来，我们来看一下责任链模式在我们学过的JavaWeb应用开发中的具体应用。</p>
<p>在JavaWeb应用开发中，FilterChain就是责任链（过滤器）模式的典型应用。下面，我们就来简单模拟一下FilterChain。注意，这里我就不再像之前那样把相关的类以及接口的源码拿出来分析了，因为源码的实现还是很复杂的，所以这里我只是简单地去模拟了一下FilterChain而已，目的主要是看一下FilterChain底层所用到的责任链模式。</p>
<p>首先，创建两个接口，一个是Request，它是模拟web请求的Request接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 22:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Request</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个是Response，它是模拟web响应的Response接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 22:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Response</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，在以上两个接口中我们并没有提供任何方法，因为意义不大，这俩接口创建出来也只是为了补全语法而已。</p>
<p>然后，再创建一个模拟web过滤器的Filter接口，它里面定义有一个doFilter方法，而且该方法需要传递三个参数，一个是Request，一个是Response，还有一个是FilterChain，至于FilterChain，你等会就能看到了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request req, Response res, FilterChain c)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建以上Filter接口的子实现类，也即模拟具体过滤器。这里，我们创建了两个子实现类，一个是FirstFilter，具体实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 23:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> {</span><br><span class="line">        System.out.println(<span class="string">"过滤器1 前置处理"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"过滤器1 后置处理"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个是SecondFilter，具体实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 23:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> {</span><br><span class="line">        System.out.println(<span class="string">"过滤器2 前置处理"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"过滤器2 后置处理"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上两个过滤器创建完毕之后，接下来我们来创建FilterChain类，也即模拟过滤器链。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 23:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChain</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Filter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 调用该方法，其实就是把过滤器添加到以上List集合里面。而且，该方法对外还有一个作用，创建过滤器链对象，即将过滤器链对象组建好。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> FilterChain <span class="title function_">addFilter</span><span class="params">(Filter filter)</span> {</span><br><span class="line">        <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//链式编程</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request request, Response response)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index == filters.size()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，这儿我只是简单地模拟了一下而已，要是大家感兴趣的话，不妨去看一下FilterChain类的源码，你大概就能知道它的底层实现了。</p>
<p>最后，创建一个测试类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.responsibility.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 23:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里我们声明了两个变量，一个是Request类型的req，还有一个是Response类型的res，</span></span><br><span class="line"><span class="comment">         * 而且它俩都被赋予了一个null的值，这是为了补全语法，不至于让程序在编译以及运行时报错！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">FilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChain</span>();</span><br><span class="line">        <span class="comment">// 组建过滤器链对象</span></span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">FirstFilter</span>()).addFilter(<span class="keyword">new</span> <span class="title class_">SecondFilter</span>());</span><br><span class="line">        filterChain.doFilter(req, res);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上测试类，打印结果如下图所示，可以看到这个结果和我们真正的去使用JavaWeb中的过滤器以及过滤器链时的结果是一样的。</p>
<p><img src="/./assets/1709612575130-a243d90a-3a6e-4c92-99e5-bd2be50802e3.png" alt="img"></p>
<p>接下来，我们就来分析一下打印结果为什么会是上面这样。</p>
<p>在测试类中可以看到，我们组建好过滤器链对象之后，旋即调用了FilterChain对象的doFilter方法，所以我们不妨进入到FilterChain类的doFilter方法中去看看。</p>
<p><img src="/./assets/1709612575150-03d8e935-ca3f-49d1-90fa-f328a57a7111.png" alt="img"></p>
<p>从上可知，doFilter方法里面首先会做一个判断，当然，此时是并不满足if判断条件的，因为现在List集合里面有两个元素，而index却是等于0，所以此时程序并不会进入到if判断语句中，而是向下执行。</p>
<p>程序向下执行时，可以看到会从List集合里面去获取0索引位置的过滤器对象，即FirstFilter类的对象，获取到该对象之后，index会先进行一个加加，然后再去调用该对象（即FirstFilter类的对象）的doFilter方法。</p>
<p>于是，我们进入到FirstFilter类的doFilter方法里面去看一看，看一下该方法是如何实现的。</p>
<p><img src="/./assets/1709612575822-7f0b1f63-5154-4087-a8fe-32a348609110.png" alt="img"></p>
<p>可以看到，doFilter方法先是打印了一句话，即过滤器1 前置处理，然后再调用了FilterChain对象里面的doFilter方法。注意，此时，后面的过滤器1 后置处理这句话还没打印呢，至于什么时候打印，我待会再来说。</p>
<p>很显然，我们又得回到FilterChain类里面的doFilter方法中来分析。由于刚才index++了，所以现在index的值已经变成1了，但是这依然满足不了if判断条件，故而程序还是不会进入if判断语句里面，而是向下执行。</p>
<p>程序向下执行时，可以看到又会从List集合里面去获取1索引位置的过滤器对象，即SecondFilter类的对象，获取到该对象之后，index会先进行一个加加，然后再去调用该对象（即SecondFilter类的对象）的doFilter方法。</p>
<p>于是，我们进入到SecondFilter类的doFilter方法里面去看一看，看一下该方法是如何实现的。</p>
<p><img src="/./assets/1709612575852-40a8fcf7-0a1b-4ee3-8858-959b13557ee6.png" alt="img"></p>
<p>可以看到，doFilter方法先是打印了一句话，即过滤器2 前置处理，然后再调用了FilterChain对象里面的doFilter方法。注意，此时，后面的过滤器2 后置处理这句话还没打印呢，至于什么时候打印，我待会再来说。</p>
<p>很显然，我们又得再次回到FilterChain类里面的doFilter方法中来分析了。由于刚才index++了，所以现在index的值已经变成2了，此时恰好满足了if判断条件，故而程序会进入if判断语句中，直接返回。</p>
<p>返回到哪去呢？返回到SecondFilter类的doFilter方法中，由于FilterChain对象里面的doFilter方法已经调用完了，所以此时会打印后面的过滤器2 后置处理这句话。</p>
<p>打印完之后，接着又会返回到FirstFilter类的doFilter方法中，由于FilterChain对象里面的doFilter方法已经调用完了，所以此时会打印后面的过滤器1 后置处理这句话。这样，最终打印的结果就是上面我们看到的那样了。</p>
<p>当然了，这里我只是简单地去模拟了一下FilterChain，目的就是希望大家再好好地理解一下责任链模式的思想，如果能理解个分毫，也算是没辜负我这片苦心了！</p>
<hr>
<hr>
<h2 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5. 状态模式"></a>6.5. 状态模式</h2><h3 id="6-5-1-状态模式引入案例"><a href="#6-5-1-状态模式引入案例" class="headerlink" title="6.5.1. 状态模式引入案例"></a>6.5.1. 状态模式引入案例</h3><p>在学习状态模式之前，我们先来看一个案例，通过该案例来引出状态模式。</p>
<p>这个案例就是通过电梯按钮来控制一个电梯的状态。一个电梯有开门状态、关门状态、停止状态、运行状态等四种状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，那么就不能进行开门操作。为什么呢？你想啊，现在电梯正处于运行状态呢，然后门开了，这是不是非常危险呀！所以，当电梯处于运行状态时是不允许执行开门操作的。而如果电梯门是停止状态，那么就可以执行开门操作了。</p>
<p>下面我们就来看一下对于以上案例所设计出来的类图。</p>
<p><img src="/./assets/1709612651469-98e0b200-1011-4555-a538-afcd39cfba0e.png" alt="img"></p>
<p>从以上类图中可以看到，我们首先定义了一个ILift接口，而且它里面声明有四个常量，即OPENING_STATE、CLOSING_STATE、RUNNING_STATE、STOPPING_STATE，它们分别是来表示电梯的四种状态的，即开启状态、关闭状态、运行状态和停止状态。</p>
<p>此外，ILift接口还提供了5个抽象方法，它们分别是：</p>
<ol>
<li>setState(int state)：设置电梯的状态。因为我们总得记录一下当前电梯的一个状态吧！</li>
<li>open()：电梯开门的方法</li>
<li>close()：电梯关门的方法</li>
<li>stop()：电梯停止的方法</li>
<li>run()：电梯运行的方法</li>
</ol>
<p>注意，ILift接口就是用于提高程序扩展性的，如果后期有其他的实体也拥有电梯的四种状态，那么我们完全可以让它去实现该接口。</p>
<p>然后，我们再来看一下ILift接口的子实现类，即Lift。可以看到，在该类里面定义了一个state属性，这个属性就是用来记录当前电梯状态的。除此之外，该类还重写了父接口中的所有抽象方法。</p>
<p>至于那个客户端类，我们就不用过多地去关注它了。所以，整个看下来，系统设计起来还是比较简单的。接下来，我们就得编写代码来实现以上案例了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即state.before，也即实现以上案例的具体代码我们是放在了该包下。</p>
<p>然后，创建电梯接口，这里我们就命名为了ILift。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电梯接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILift</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义四个电梯状态的常量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">OPENING_STATE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">CLOSING_STATE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">RUNNING_STATE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">STOPPING_STATE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置电梯状态的功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 电梯操作功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建电梯接口的子实现类，即电梯类，这里我们就命名为了Lift。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电梯类（ILift接口的子实现类）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lift</span> <span class="keyword">implements</span> <span class="title class_">ILift</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个记录当前电梯状态的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> {</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">switch</span> (state) { <span class="comment">// 判断当前电梯的状态</span></span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于开启状态，那么我们再去开门，这就没有任何意义了，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于关闭状态，那么我们就能开电梯门了</span></span><br><span class="line">                System.out.println(<span class="string">"电梯打开了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为开启状态</span></span><br><span class="line">                setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于停止状态，那么我们也是能开电梯门的</span></span><br><span class="line">                System.out.println(<span class="string">"电梯打开了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为开启状态</span></span><br><span class="line">                setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于运行状态，那么我们肯定是不能去开门的，因为电梯运行时是不能开门的，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) {</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于开启状态，那么我们就能关闭电梯门了</span></span><br><span class="line">                System.out.println(<span class="string">"电梯关门了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为关闭状态</span></span><br><span class="line">                <span class="built_in">this</span>.setState(CLOSING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于关闭状态，那么我们再去关门，这就没有任何意义了，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于运行状态，很显然，此时电梯门肯定是关着的，那么我们就不能再去关门了，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于停止状态，很显然，此时电梯门肯定也是关着的，那么我们就不能再去关门了，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) {</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于开启状态，那么我们肯定是不能让电梯运行的，因为电梯不能开着门就走，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于关闭状态，那么我们就能让电梯运行了</span></span><br><span class="line">                System.out.println(<span class="string">"电梯开始运行了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为运行状态</span></span><br><span class="line">                <span class="built_in">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于运行状态，那么我们再去运行电梯，这就没有任何意义了，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于停止状态，那么我们也是可以让电梯运行的</span></span><br><span class="line">                System.out.println(<span class="string">"电梯开始运行了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为运行状态</span></span><br><span class="line">                <span class="built_in">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) {</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于开启状态，那么我们再让电梯停止下来，就没有必要了，因为开门的电梯已经是停止的了（正常情况下），所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于关闭状态，那么我们就能让电梯停止下来了，因为电梯关门时才可以停止</span></span><br><span class="line">                System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为停止状态</span></span><br><span class="line">                <span class="built_in">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于运行状态，那么我们也是能让电梯停止的，因为电梯运行时本身就可以停止啊</span></span><br><span class="line">                System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">                <span class="comment">// 设置当前电梯状态为停止状态</span></span><br><span class="line">                <span class="built_in">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">// 如果当前电梯正处于停止状态，那么我们再去让电梯停止下来，这就没有任何意义了，所以这儿我们什么事都不做</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 11:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建电梯对象</span></span><br><span class="line">        <span class="type">Lift</span> <span class="variable">lift</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lift</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前电梯的状态</span></span><br><span class="line">        lift.setState(ILift.OPENING_STATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开</span></span><br><span class="line">        lift.open();</span><br><span class="line">        lift.close();</span><br><span class="line">        lift.run();</span><br><span class="line">        lift.stop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，下面我就来解释一下为何会打印出这样的结果。</p>
<p><img src="/./assets/1709612651483-a75c646e-3a08-41e3-be6b-41e153288ef9.png" alt="img"></p>
<p>当前电梯正处于开启状态，于是你再去开电梯门，那就没有任何意义了，所以执行电梯的open方法去开电梯门时，你会发现并没有任何输出。但是，现在关闭电梯门是可行的，所以在执行电梯的close方法时，你就能看到相应的输出结果了，而且此时电梯的状态就变成关闭状态了。</p>
<p>当电梯处于关闭状态时，你就能让电梯运行起来了，所以在执行电梯的run方法时，你就能看到相应的输出结果了，而且此时电梯的状态又变成了运行状态。</p>
<p>当电梯处于运行状态时，能让电梯停止吗？当然可以，所以在执行电梯的stop方法时，你就能看到相应的输出结果了，而且此时电梯的状态又变成了停止状态。</p>
<p>大家试想一下，如果将当前电梯的状态设置为运行状态，那么打印的结果又会是什么呢？</p>
<p><img src="/./assets/1709612651492-0e80f6ac-0113-4413-9afd-3ee4edc5c3f4.png" alt="img"></p>
<p>你会发现只打印了一句话，为什么会这样呢？因为当前电梯正处于运行状态，那么此时是不允许你去开电梯门的，要是你在电梯运行的过程中开门那得多危险啊！那去关电梯门，可不可以呢？大可不必啊，因为电梯在运行过程中，本身电梯门就是关闭的，你再去关电梯门，不是有点脱裤子放屁的意思吗？那去运行电梯，可不可以呢？同样的道理啊，大可不必，因为电梯本身就在运行过程中，你再去运行电梯，那就没有必要了。那去让电梯停下来呢？此时就可以了，所以在执行电梯的stop方法时，你就能看到相应的输出结果了，即电梯停止了…！</p>
<p><strong>以上设计存在的问题:</strong></p>
<ul>
<li>使用了大量的switch case这样的判断语句（当然了，有些人比较喜欢使用if else语句，不过效果都是一样)，使程序的可阅读性变得特别差。尤其是咱们Lift类中的方法，你会发现阅读起来体验特别特别差。</li>
<li>扩展性很差。如果新加了断电的状态，那么我们就需要修改上面的判断逻辑。其实，不光要修改上面的判断逻辑，我们还得在ILift接口里面定义一个表示断电状态的常量，然后再定义一个抽象的方法，接下来，在子类中还要去重写这个方法，并且对于前面已经定义好的四个方法也要进行一个修改，所以程序的扩展性是非常差的。</li>
</ul>
<p>问题既然出现了，那么应该如何解决呢？嘿嘿，此时，我们就要使用状态模式了。那什么是状态模式呢？下面我就会讲到。</p>
<hr>
<h3 id="6-5-2-概述"><a href="#6-5-2-概述" class="headerlink" title="6.5.2. 概述"></a>6.5.2. 概述</h3><p>上面我们做了一个电梯的案例，也引出了该电梯案例所存在的问题，并提出了解决方案，也就是使用状态模式来进行一个改进。那什么是状态模式呢？接下来，我们就来看一看它的概念。</p>
<p>对有状态的对象，把复杂的”判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>大家猛然看到状态模式的概念可能会有点懵！不过没关系，下面我会向大家一句一句来解释。</p>
<p>开宗明义，状态模式说的是有状态的对象，所以对于没有状态的对象，你就不能使用状态模式了。然后，状态模式说的是把复杂的”判断逻辑”提取到不同的状态对象中，对于这句话，我们该如何理解呢？试想一下我们之前的做法，是不是在每一个方法里面使用switch case或者if else语句来进行判断的啊？现在使用状态模式就不同了，我们会避免使用switch case或者if else这些判断语句，而是把它们提取到不同的状态对象中，通过面向对象的形式，把同样的逻辑给实现出来。</p>
<p>最后，状态模式说的是允许状态对象在其内部状态发生改变时改变其行为，对于这句话，我们该如何理解呢？举例来说，在上述电梯案例中，如果当前电梯现正处于运行状态中，那么我们还能执行开门的操作吗？很显然，肯定是不可以的，这也正说明了当前电梯状态发生改变会改变其行为。</p>
<p>以上就是我对状态模式概念的解释，如果大家还有什么不懂的，后面我会再通过一个案例来向大家进行详细的说明。</p>
<h3 id="6-5-3-结构"><a href="#6-5-3-结构" class="headerlink" title="6.5.3. 结构"></a>6.5.3. 结构</h3><p>状态模式包含以下主要角色：</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。注意，环境角色只是对外提供了一个接口，而且在它里面维护了一个当前状态，所以，具体执行操作的还是对应的当前状态对象。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li>
</ul>
<p>上面三个角色你不通过案例来理解，相信你是理解不了的，除非你是天选之子！这里我就不妨先举个例子来说说吧！还是以上述电梯案例来说，如果当前电梯正处于运行状态，那么我们就要创建一个电梯运行状态类了，另外还得去创建它的对象，并将该对象维护在环境角色里面。</p>
<h3 id="6-5-4-状态模式案例"><a href="#6-5-4-状态模式案例" class="headerlink" title="6.5.4. 状态模式案例"></a>6.5.4. 状态模式案例</h3><p>接下来，我们便通过状态模式来改进以上电梯案例，以此希望大家对状态模式的概念以及它里面所具有的角色有一个更深入的理解。</p>
<h4 id="6-5-4-1-分析"><a href="#6-5-4-1-分析" class="headerlink" title="6.5.4.1. 分析"></a>6.5.4.1. 分析</h4><p>对上述电梯案例使用状态模式进行改进之后的类图如下所示。</p>
<p><img src="/./assets/1709612651473-4749ceb6-0fe4-421e-b7b7-4358f79e0f47.png" alt="img"></p>
<p>接下来，我们就要分析一下以上类图中所涉及到的类，以及类和类之间的关系了。</p>
<p>可以看到，最上面有一个LiftState类，它充当的就是状态模式里面的抽象状态角色。在该类里面，我们声明了一个Context类型的成员变量，且它是protected修饰的，也就意味着子类可以直接去使用它了。那Context又是啥呢？它是环境角色类，在类图的最下面大家也能看到它，等一会我们再去详细说它啊！</p>
<p>另外，在LiftState类里面我们还提供了一个setContext方法，它是用来设置环境角色类对象的。除了它之外，我们还提供了四个操作电梯状态的方法，分别是open、close、stop和run等方法，而且它们都是抽象的，既然是抽象的，那就意味着要求子类必须去实现了。</p>
<p>然后，我们再来看一下LiftState类的四个子类，它们都是具体状态类，分别是电梯开启状态类、电梯关闭状态类、电梯停止状态类以及电梯运行状态类。对于这四个子类而言，它们必须去重写父类中的四个抽象方法。</p>
<p>最后，我们来看一下Context类，它充当的是状态模式里面的环境角色。在该类里面，我们定义了四个具体状态类对象的常量，除此之外，我们还定义了一个LiftState类型的成员变量，它是用来记录当前电梯状态的，并且为它我们也提供了对应的getter和setter方法。</p>
<p>当然了，在该类里面，我们还提供了open、close、stop以及run等这些方法，那你知道这些方法主要是来干嘛的吗？</p>
<p>看一下状态模式里面对环境角色的描述，它说的是将与状态相关的操作委托给当前状态对象来处理，所以，在Context类的open、close、stop以及run这些方法里面，到时候就会去调用当前状态对象里面对应的方法了。</p>
<h4 id="6-5-4-2-实现"><a href="#6-5-4-2-实现" class="headerlink" title="6.5.4.2. 实现"></a>6.5.4.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即state.after，也即使用状态模式对电梯案例改进的具体代码我们是放在了该包下。</p>
<p>然后，创建抽象状态类，即LiftState。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象状态类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 11:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LiftState</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明环境角色类变量</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> {</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 电梯开启操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 电梯关闭操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 电梯运行操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 电梯停止操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建四个具体状态类。这里，先创建电梯开启状态类，即OpeningState。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电梯开启状态类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 12:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpeningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前状态下要执行的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为当前电梯本身就处于开启状态，所以open方法就是当前电梯在开启状态下要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"电梯开启..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当电梯处于开启状态时，我们是可以关闭电梯门的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.CLOSING_STATE); <span class="comment">// 记录当前电梯的状态</span></span><br><span class="line">        <span class="comment">// 调用当前电梯状态对象中的Context对象中的close方法。记住，此时调用的是电梯关闭状态对象中的close方法</span></span><br><span class="line">        <span class="built_in">super</span>.context.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯门不能开着就跑，所以这里我们什么也不做</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 什么都不做</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯处于开启状态时，它本身就是停止的了，所以这里我们什么也不做</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 什么都不做</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>电梯开启状态类创建完毕之后，接下来其他的具体状态类就比较容易创建了，照葫芦画瓢呗！</p>
<p>创建的电梯运行状态类，即RunningState，代码如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电梯运行状态类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 12:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯运行的时候开电梯门？你疯了吗！电梯它不会给你开的，所以这里我们什么也不做</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当电梯处于运行状态时，电梯门本身就是关闭的，所以这里我们什么也不做</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前状态下要执行的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为当前电梯本身就处于运行状态，所以run方法就是当前电梯在运行状态下要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"电梯正在运行..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个事绝对是合理的，电梯光运行不停止，那还有谁敢坐这个电梯啊？估计只有上帝了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.STOPPING_STATE);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建的电梯停止状态类，即StoppingState，代码如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电梯停止状态类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 12:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoppingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当电梯处于停止状态时，我们是可以开电梯门的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.OPENING_STATE);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 委托给OpeningState类来执行开电梯门这个动作</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 当然了，以下代码你也可以替换为：super.context.open();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().open();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当电梯处于停止状态时，我们也是可以关电梯门的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.CLOSING_STATE);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 委托给ClosingState类来执行关电梯门这个动作</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 当然了，以下代码你也可以替换为：super.context.close();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯由停止状态再跑起来，正常的很</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.RUNNING_STATE);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 委托给RunningState类来执行运行电梯这个动作</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 当然了，以下代码你也可以替换为：super.context.run();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().run();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前状态下要执行的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为当前电梯本身就处于停止状态，所以stop方法就是当前电梯在停止状态下要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建的电梯关闭状态类，即ClosingState，代码如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电梯关闭状态类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 12:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClosingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前状态下要执行的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为当前电梯本身就处于关闭状态，所以close方法就是当前电梯在关闭状态下要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯门关了再打开，这是允许的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.OPENING_STATE);</span><br><span class="line">        <span class="built_in">super</span>.context.open();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯门关了就跑，这是再正常不过的了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.RUNNING_STATE);</span><br><span class="line">        <span class="built_in">super</span>.context.run();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电梯门关着，我就是不按楼层，你能怎么着我</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.STOPPING_STATE);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上四个具体状态类创建完毕之后，接下来，我们来创建环境角色类，即Context。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环境角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 12:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义对应电梯状态类对象的常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">OpeningState</span> <span class="variable">OPENING_STATE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpeningState</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ClosingState</span> <span class="variable">CLOSING_STATE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClosingState</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">RunningState</span> <span class="variable">RUNNING_STATE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunningState</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">StoppingState</span> <span class="variable">STOPPING_STATE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoppingState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个记录当前电梯状态的变量</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiftState <span class="title function_">getLiftState</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> liftState;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前电梯状态对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLiftState</span><span class="params">(LiftState liftState)</span> {</span><br><span class="line">        <span class="built_in">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">// 设置完当前电梯状态对象之后，别忘了，我们还得设置当前电梯状态对象中的Context对象</span></span><br><span class="line">        <span class="built_in">this</span>.liftState.setContext(<span class="built_in">this</span>); <span class="comment">// 现在我们就在Context类中，所以在setContext方法里面直接传递this就可以了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是四个操作电梯状态的方法，在这些方法里面我们都是直接去调用当前电梯状态对象里面各自对应的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.liftState.open();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.liftState.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.liftState.run();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.liftState.stop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们创建一个客户端类来用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.state.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 16:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建环境角色对象，因为我们之前就已经说过，环境角色就是对外提供访问的接口</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="comment">// 设置当前电梯状态</span></span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> <span class="title class_">RunningState</span>());</span><br><span class="line"></span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，下面我就来解释一下为何会打印出这样的结果。</p>
<p><img src="/./assets/1709612651513-6e6cc6bb-1244-4c4c-99a0-0fca738cea7d.png" alt="img"></p>
<p>当前电梯正处于运行状态，那么你就不能再去开电梯门了，要是允许你去开电梯门，那这得多危险啊！所以，当程序执行完context.open()这行代码时，你会发现压根就没有打印任何结果。</p>
<p>这时我们还能去关闭电梯门吗？电梯运行时，门本身就关闭着，你再去关闭电梯门，请问有什么意义呢？所以，当程序执行完context.close()这行代码时，你同样会发现没有打印任何结果。</p>
<p>然后，当程序执行完context.run()这行代码时，我们终于看到相应的输出结果了，这是因为run方法就是当前电梯在运行状态下要执行的方法。</p>
<p>接着，由于电梯在运行过程中，可以停下来，所以当程序执行完context.stop()这行代码时，我们也是能看到相应的输出结果的，只不过此时当前电梯的状态已经变成了停止状态。</p>
<p>至此，使用状态模式改进的电梯案例我们就算是实现了。在改进后的电梯案例中，你会发现在我们写的代码里面并没有if else或者switch case这样的语句，而且程序的扩展性也很好，因为后期如果我们想要再添加一个断电状态，那么只需要再创建一个LiftState类的子类就可以了，当然了，Context环境角色类也要进行一个修改，只不过我们修改的地方会少很多。</p>
<hr>
<h3 id="6-5-5-状态模式的优缺点以及使用场景"><a href="#6-5-5-状态模式的优缺点以及使用场景" class="headerlink" title="6.5.5. 状态模式的优缺点以及使用场景"></a>6.5.5. 状态模式的优缺点以及使用场景</h3><p>接下来，我们来看一下状态模式的优缺点以及使用场景。</p>
<h4 id="6-5-5-1-优缺点"><a href="#6-5-5-1-优缺点" class="headerlink" title="6.5.5.1. 优缺点"></a>6.5.5.1. 优缺点</h4><h5 id="6-5-5-1-1-优点"><a href="#6-5-5-1-1-优点" class="headerlink" title="6.5.5.1.1. 优点"></a>6.5.5.1.1. 优点</h5><p>关于状态模式的优点，我总结出了下面两点。</p>
<ol>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。在未使用状态模式改进的电梯案例中，我们就大量使用到了switch case或者if else这样的语句，这就不是面向对象的思想，而使用了状态模式之后，是不是更加面向对象了啊！此外，它还允许将状态转换逻辑和状态对象合为一体，这不是一举两得吗？</li>
</ol>
<h5 id="6-5-5-1-2-缺点"><a href="#6-5-5-1-2-缺点" class="headerlink" title="6.5.5.1.2. 缺点"></a>6.5.5.1.2. 缺点</h5><p>关于状态模式的优点，我总结出了下面三点。</p>
<ol>
<li><strong>省流:不如swich case简单, 直观</strong></li>
<li>状态模式的使用必然会增加系统类和对象的个数。在未使用状态模式改进的电梯案例中，其实也就创建了一个接口和一个类，而使用了状态模式进行了改进之后，你会发现有多少个状态就要创建多少个状态类，这样，类肯定是增加了，类增加了之后，那么相应的对象的个数肯定也会增加。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当，那么就会导致程序结构和代码的混乱。看一下咱们使用状态模式改进之后的电梯案例，在抽象状态类（即LiftState）里面就聚合了Context类的对象，而在Context类里面，你会发现又聚合了LiftState类的对象，所以程序的结构还是比较复杂的，这样的话，我们在设计的时候就一定要加倍小心了。</li>
<li>状态模式对”开闭原则”的支持并不太好。你想啊，后期如果我们想要添加一个新的状态，那么我们不光要添加一个新的状态类，还要去修改Context类里面的代码，并且对于那些具体状态类的代码我们也要稍微进行一个修改，所以我们才说状态模式对开闭原则的支持并不是特别好。</li>
</ol>
<h4 id="6-5-5-2-使用场景"><a href="#6-5-5-2-使用场景" class="headerlink" title="6.5.5.2. 使用场景"></a>6.5.5.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用状态模式了。</p>
<ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式了。状态模式主要体现的就是状态，只要一个对象的行为取决于它的状态（状态不一样，对象的行为也会不一样），那么这个时候你就可以考虑使用状态模式了。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。也就是说，如果你写的代码里面大量地运用到了switch case或者if else语句，那么这个时候你就不妨试试使用状态模式。</li>
</ul>
<hr>
<h2 id="6-6-观察者模式"><a href="#6-6-观察者模式" class="headerlink" title="6.6. 观察者模式"></a>6.6. 观察者模式</h2><h3 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1. 概述"></a>6.6.1. 概述</h3><p>我们先来看一看观察者模式的概念。</p>
<p>观察者模式又被称为发布/订阅（Publish/Subscribe）模式，它定义了一种一对多的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&amp;spm=1001.2101.3001.7020">依赖关系</a>，让多个观察者对象同时监听某一个主题对象（所以，观察者对象是多的一方，主题对象是一的一方）。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>以上观察者模式的概念，大家可以理解成之前学习过的监听机制。简单来说，就是我们创建一个监听器，并让该监听器去监听一个按钮，当该按钮的状态发生变化时，例如点击该按钮，监听器自动地执行某一操作。当然了，我们可以创建多个监听器去监听同一个按钮。</p>
<h3 id="6-6-2-结构"><a href="#6-6-2-结构" class="headerlink" title="6.6.2. 结构"></a>6.6.2. 结构</h3><p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每一个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加或者删除观察者对象。这里我得多说一嘴，如果你将抽象主题角色定义成了一个接口而不是一个抽象类，那么在该接口里面是不能定义一个集合来存储多个观察者对象的，因此你可以将其推迟到子类（也即具体主题角色）中来实现。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知，这样，具体观察者对象里面的方法就会被自动调用了。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。说白了，我们会为该角色定义一个接口，并在该接口中声明一个功能，当具体主题的内部状态发生改变时，该功能就会被自动调用。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。说白了，具体观察者会实现抽象观察者定义的更新接口，并重写里面的方法，而该方法会在具体主题的内部状态发生改变时被自动调用。</li>
</ul>
<h3 id="6-6-3-观察者模式案例"><a href="#6-6-3-观察者模式案例" class="headerlink" title="6.6.3. 观察者模式案例"></a>6.6.3. 观察者模式案例</h3><p>接下来，我们通过一个案例来让大家再去理解一下观察者模式的概念，以及它里面所包含的角色，这个案例就是微信公众号。</p>
<h4 id="6-6-3-1-分析"><a href="#6-6-3-1-分析" class="headerlink" title="6.6.3.1. 分析"></a>6.6.3.1. 分析</h4><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端，因此，我们就可以使用观察者模式来模拟这样的场景了。下面我们就来分析一下观察者模式里面的角色都是由谁来充当的。</p>
<p>对于微信公众号而言，如果它的内容发生改变的话，那么它是不是要通知关注它的微信用户端啊！所以对于微信公众号来说，它是属于主题角色，即被观察者，而对于微信用户端来说，它是属于观察者角色。</p>
<p>以上内容分析清楚了之后，接下来我们就来看一看下面的这张类图。</p>
<p><img src="/./assets/1709612749311-06325bf9-74d2-49e4-81c4-9a460d89f8ce.png" alt="img"></p>
<p>先看以上类图的右侧部分，上面定义了一个Subject接口，该接口充当的就是观察者模式里面的抽象主题角色，而且该接口里面声明有三个方法，它们分别是：</p>
<ol>
<li>attach(Observer observer)：添加观察者对象</li>
<li>detach(Observer observer)：删除观察者对象</li>
<li>notify(String message)：通知观察者对象进行更新</li>
</ol>
<p>不过它们都是抽象方法，需要子实现类来实现。所以，在Subject接口下面我们又定义了它的一个子实现类，即SubscriptionSubject，该子实现类重写了父接口中的所有抽象方法。当然，它里面还声明有一个List集合，里面存储的都是Observer类型的对象，只不过Observer是属于抽象观察者角色，而且还是一个接口，所以该子实现类里面的List集合存储的肯定就是Observer接口的子实现类对象了。从以上类图中，我们也能看到在SubscriptionSubject类里面聚合了Observer接口。</p>
<p>然后，我们来看以上类图的左侧部分，可以看到上面定义了一个Observer接口，该接口充当的就是观察者模式里面的抽象观察者角色，它里面声明了一个update方法，表示更新操作，该方法会在具体主题的内部状态发生改变时被自动调用。</p>
<p>由于Observer接口里面的update方法是一个抽象方法，所以在Observer接口下面我们又定义了它的一个子实现类，即WeiXinUser，该子实现类充当的就是观察者模式里面的具体观察者角色。而且，该子实现类里面还声明了一个String类型的name成员变量，它是用来记录微信用户的名称的，除此之外，该子实现类还提供了一个有参的构造方法，并且去重写了父接口中的update方法。</p>
<p>分析完以上类图之后，接下来我们就要编写代码实现以上微信公众号案例了。</p>
<h4 id="6-6-3-2-实现"><a href="#6-6-3-2-实现" class="headerlink" title="6.6.3.2. 实现"></a>6.6.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即observer，也即实现以上微信公众号案例的具体代码我们是放在了该包下。</p>
<p>然后，创建抽象观察者接口，这里我们将其命名为了Observer。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象观察者接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 17:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message：主题推送的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建具体观察者类，这里我们将其命名为了WeiXinUser。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的观察者角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 17:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiXinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeiXinUser</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> {</span><br><span class="line">        System.out.println(name + <span class="string">"-"</span> + message); <span class="comment">// 谁接收到了什么更新的消息</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建抽象主题接口，这里我们将其命名为了Subject。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象主题角色接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加订阅者（即添加观察者对象）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除订阅者（即删除观察者对象）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>抽象主题接口创建完毕之后，接下来我们就要创建具体主题类了，这里我们不妨将其命名为SubscriptionSubject。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体主题角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 17:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个集合，用来存储多个观察者对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weiXinUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> {</span><br><span class="line">        weiXinUserList.add(observer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> {</span><br><span class="line">        weiXinUserList.remove(observer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不知你有没有想过该方法什么时候执行呢？是不是当微信公众号里面的内容发生变化时，该方法才会执行啊？</span></span><br><span class="line"><span class="comment">     * 而且，当该方法执行时，它会通知所有的观察者对象去自动调用update方法。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message：通知的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weiXinUserList) {</span><br><span class="line">            <span class="comment">// 调用观察者对象中的update方法</span></span><br><span class="line">            observer.update(message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 19:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 1. 创建公众号对象</span></span><br><span class="line">        <span class="type">SubscriptionSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 订阅公众号</span></span><br><span class="line">        subject.attach(<span class="keyword">new</span> <span class="title class_">WeiXinUser</span>(<span class="string">"孙悟空"</span>));</span><br><span class="line">        subject.attach(<span class="keyword">new</span> <span class="title class_">WeiXinUser</span>(<span class="string">"猪悟能"</span>));</span><br><span class="line">        subject.attach(<span class="keyword">new</span> <span class="title class_">WeiXinUser</span>(<span class="string">"沙悟净"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 公众号更新，发出消息给订阅者（即观察者对象）</span></span><br><span class="line">        subject.notify(<span class="string">"李阿昀的专栏更新了！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到当咱们公众号里面的内容发生变化时，所有的订阅者都能接收到这个消息。</p>
<p><img src="/./assets/1709612749311-3cdc45d3-0640-4fe4-aadf-9437bfa34bce.png" alt="img"></p>
<p>至此，微信公众号案例我们就算是实现完了。你会发现，对于微信用户来说，只要他订阅了某个公众号，那么当公众号里面的内容发生变化时，该微信用户里面的update更新方法就会被自动调用，所以现在大家能理解观察者模式的概念了吧！</p>
<h3 id="6-6-4-观察者模式的优缺点以及使用场景"><a href="#6-6-4-观察者模式的优缺点以及使用场景" class="headerlink" title="6.6.4. 观察者模式的优缺点以及使用场景"></a>6.6.4. 观察者模式的优缺点以及使用场景</h3><p>接下来，我们来看一下观察者模式的优缺点以及使用场景。</p>
<h4 id="6-6-4-1-优缺点"><a href="#6-6-4-1-优缺点" class="headerlink" title="6.6.4.1. 优缺点"></a>6.6.4.1. 优缺点</h4><h5 id="6-6-4-1-1-优点"><a href="#6-6-4-1-1-优点" class="headerlink" title="6.6.4.1.1. 优点"></a>6.6.4.1.1. 优点</h5><p>关于观察者模式的优点，这里我总结出来了下面两点。</p>
<ol>
<li>降低了目标与观察者之间的耦合关系，注意，两者之间是抽象耦合关系。怎么看待这一点呢？大家要知道一点，就是这儿所说的目标指的就是被观察者对象（或者主题对象），有些人可能就会说，在下面代码处，不是也进行了一个耦合吗？<img src="/./assets/1709612749285-409732cd-26e2-437b-b2fd-049264a0e985.png" alt="img">但是，你要注意，这儿的耦合是属于抽象耦合，抽象耦合的扩展性相对而言还是比较高的。</li>
<li>被观察者发送通知，所有注册的观察者都会收到信息，因此通过该特性我们可以实现广播机制。</li>
</ol>
<h5 id="6-6-4-1-2-缺点"><a href="#6-6-4-1-2-缺点" class="headerlink" title="6.6.4.1.2. 缺点"></a>6.6.4.1.2. 缺点</h5><p>关于观察者模式的缺点，这里我也总结出来了下面两点。</p>
<ol>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会很耗时。大家不妨来看一下下面notify方法中的代码，现在我们是去遍历List集合，然后一个一个的去调用集合里面观察者对象的update方法。<img src="/./assets/1709612749293-209e50f8-254c-47d0-ba9a-43dcdb50ea0c.png" alt="img">如果观察者特别多的话，那么可能最后一个观察者收到的更新消息就会比较延时。</li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，这将会导致系统崩溃。也就是说，我们在使用观察者模式时，一定要搞清楚观察者模式里面的角色以及角色和角色之间的一个关系，这样才不至于让我们设计的整个系统出现问题。</li>
</ol>
<h4 id="6-6-4-2-使用场景"><a href="#6-6-4-2-使用场景" class="headerlink" title="6.6.4.2. 使用场景"></a>6.6.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用观察者模式了。</p>
<ul>
<li>对象间存在一对多关系，而且一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<hr>
<h3 id="6-6-5-JDK中提供的观察者模式的实现"><a href="#6-6-5-JDK中提供的观察者模式的实现" class="headerlink" title="6.6.5. JDK中提供的观察者模式的实现"></a>6.6.5. JDK中提供的观察者模式的实现</h3><h4 id="6-6-5-1-介绍"><a href="#6-6-5-1-介绍" class="headerlink" title="6.6.5.1. 介绍"></a>6.6.5.1. 介绍</h4><p>对于观察者模式，JDK源码里面也提供了实现，所以接下来我们就来看一看在JDK中提供的观察者模式的实现。</p>
<p>在Java中，通过java.util.Observable类（该类属于抽象主题角色）和java.util.Observer接口（该接口属于抽象观察者角色）定义了观察者模式，所以我们只要实现这俩类和接口就可以编写观察者模式实例了。</p>
<p>在编写观察者模式实例之前，我先为大家讲一下java.util.Observable类和java.util.Observer接口。</p>
<p><code>Observable类</code>是抽象主题类（即被观察者），它有一个Vector集合成员变量，用于保存所有要通知的观察者对象。</p>
<p><img src="/./assets/1709612749339-699ab24e-cefb-49e5-bb13-b9f473bb4ace.png" alt="img"></p>
<p>该Vector集合成员变量声明出来之后，并没有立即为其赋值，而是在无参构造里面对其进行赋值的。</p>
<h4 id="6-6-5-2-Observable类方法"><a href="#6-6-5-2-Observable类方法" class="headerlink" title="6.6.5.2. Observable类方法"></a>6.6.5.2. Observable类方法</h4><p><strong>该类里面最重要的3个方法，它们分别是：</strong></p>
<ol>
<li><code>void addObserver(Observer o)</code>：用于将新的观察者对象添加到集合中。<img src="/./assets/1709612749942-b422718f-6635-41d1-ba84-b6d8837f0e8d.png" alt="img">可以看到，该方法会首先判断Vector集合里面是否有要新添加的观察者对象，若有则做任何操操作，若没有则将新的观察者对象添加到集合中。</li>
<li><code>void notifyObservers(Object arg)</code>：调用集合中的所有观察者对象的update方法，通知它们数据发生了改变。通常越晚加入集合的观察者越先得到通知。<img src="/./assets/1709612750167-fdc374f1-8a41-460b-b625-378096cebd0e.png" alt="img">可以看到，该方法首先做的第一件事就是将Vector集合转换成了数组，然后倒序去遍历该数组，那做了些什么事情呢？无非就是拿到每一个观察者对象，并调用它里面的update方法，所以你现在该明白为什么通常越晚加入集合的观察者越先得到通知了吧！</li>
<li><code>void setChange()</code>：用来设置一个boolean类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers方法才会真正地去通知观察者。咱们还是来看一下以上notifyObservers方法，在该方法里面，你会发现如果changed标识为false的话，那么该方法就会直接返回了，就不会再执行下面的代码了，反之，才会继续执行下面的代码。然后，我们再来看看<code>setChange方法</code>，如下图所示，可以看到在该方法里面是直接给changed标识赋了一个true的值，所以只有调用了该方法，notifyObservers方法才会真正地去通知观察者，让它们去调用自个的update方法。<img src="/./assets/1709612750294-52730262-c074-46b9-b1a4-b645c0d0200d.png" alt="img">那什么时候changed标识才会被设置为false呢？大家注意看以上notifyObservers方法，你会发现它里面在将Vector集合转换成了数组之后，又调用了一个clearChanged方法，而clearChanged方法就会将changed标识设置为false。<img src="/./assets/1709612750346-db1209df-5dec-45fa-b180-8addc57cfec1.png" alt="img">所以，只要主题内容发生了更新，那么notifyObservers方法就会真正地去通知观察者，并且它还得做一件事，那就是把changed标识改为false。</li>
</ol>
<p>以上就是Observable类提供的3个重要的方法，大家一定要好好地理解一下哟！</p>
<h4 id="6-6-5-3-Observer接口"><a href="#6-6-5-3-Observer接口" class="headerlink" title="6.6.5.3. Observer接口"></a>6.6.5.3. Observer接口</h4><p>Observer接口是属于抽象观察者角色，它监视目标对象的变化（当然，你也可以理解成是主题对象的一个变化），当目标对象发生变化时，观察者得到通知，并调用update方法，进行相应的工作。</p>
<p>知道了以上Observable类和Observer接口之后，我们编写观察者模式实例就会很简单了:</p>
<ul>
<li>因为只需让具体主题类去继承Observable类</li>
<li>让具体观察者类去实现Observer接口就可以了。</li>
</ul>
<h4 id="6-6-5-4-案例"><a href="#6-6-5-4-案例" class="headerlink" title="6.6.5.4. 案例"></a>6.6.5.4. 案例</h4><p>下面我们就使用观察者模式来实现一个警察抓小偷的案例。</p>
<p>很明显，在该案例中，警察是观察者对象，而小偷是被观察者对象。既然该案例要使用到观察者模式，那么我们就可以使用JDK给我们提供的Observable类和Observer接口了。</p>
<p>首先，创建小偷类，这里我们就命名为Thief了。注意，由于小偷是一个被观察者，所以该类需要去继承Observable类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小偷类（被观察者对象）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-29 19:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thief</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小偷偷东西的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">steal</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"小偷：我偷东西了，有没有人来抓我啊！"</span>);</span><br><span class="line">        <span class="built_in">super</span>.setChanged(); <span class="comment">// 将changed标识改为true</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers(); <span class="comment">// 再去通知观察者，此时，观察者里面的update方法才会被执行</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建警察类，这里我们就命名为Policemen了。注意，由于警察是一个观察者，所以需要让其去实现Observer接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 警察类（观察者对象）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-29 19:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Policemen</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policemen</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"警察："</span> + ((Thief) o).getName() + <span class="string">"，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.observer.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-29 19:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建小偷对象</span></span><br><span class="line">        <span class="type">Thief</span> <span class="variable">thief</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thief</span>(<span class="string">"隔壁老王"</span>);</span><br><span class="line">        <span class="comment">// 创建警察对象</span></span><br><span class="line">        <span class="type">Policemen</span> <span class="variable">policemen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Policemen</span>(<span class="string">"老李"</span>);</span><br><span class="line">        <span class="comment">// 让警察盯着小偷</span></span><br><span class="line">        thief.addObserver(policemen);</span><br><span class="line">        <span class="comment">// 小偷偷东西</span></span><br><span class="line">        thief.steal();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到只要小偷一偷东西，就会调用通知方法去通知警察进行抓捕，然后警察类中的update方法就会被执行了。</p>
<p><img src="/./assets/1709612750354-943eb1e0-3198-476f-ba31-82f3c335f36c.png" alt="img"></p>
<p>对于JDK里面提供的观察者模式的实现，相信大家应该很清楚了，嘻嘻！</p>
<hr>
<hr>
<h2 id="6-7-中介者模式"><a href="#6-7-中介者模式" class="headerlink" title="6.7. 中介者模式"></a>6.7. 中介者模式</h2><h3 id="6-7-1-概述"><a href="#6-7-1-概述" class="headerlink" title="6.7.1. 概述"></a>6.7.1. 概述</h3><p>在学习中介者模式之前，我们先来看下面这段描述。</p>
<p>一般来说，同事类之间的关系是比较复杂的（其实，这儿所说的同事类就是中介者模式里面的一个角色，而在这里，你可以先把它当作一个普通的类来看待），多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020">架构</a>，既不利于类的复用，也不稳定。例如，下图中有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响，因为对象1所属类和对象2、对象4、对象5、对象6所属类之间是有关联关系的。如果对象2发生变化，那么将会有5个对象受到影响。所以，这种错综复杂的关系会让我们在后期维护起来特别特别麻烦，也就是说，同事类之间直接关联的设计是不好的。</p>
<p><img src="/./assets/1709706458379-45a4f2a6-d1f1-487b-8b60-f0860a21b2ea.png" alt="img"></p>
<p>那么我们应该如何来改进呢？这时不妨使用一下中介者模式，因为使用中介者模式的话，可以使得同事类之间的关系成为星型的结构，也就是我们下图右侧所展示出来的星型结构。</p>
<p><img src="/./assets/1709706458373-1b4a9cd2-dcc3-49f9-87df-c471396acfa3.png" alt="img"></p>
<p>从上图右侧部分可以看到，每一个同事类，它只和中介者进行一个相互关联，而它们相互之间是不需要进行任何关联的，这样，任何一个类的变动，只会影响到类本身以及中介者，也就是说，对象1所属类里面的业务逻辑发生变化了的话，那么对象1所属类以及中介者要发生一个改变，而对于其他对象的所属类则是不需要进行改动的，这样就减小了系统的耦合。</p>
<p>一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为，这个专门的类就是中介者。</p>
<p>下面我再举一个例子让大家好好理解一下。</p>
<p>如果我们攒够首付了，想要去买一套属于自己的房子，那么我们应该怎么办呢？我们作为一个购房者，是不会直接去找对应的房主的，因为房主有很多，我们找起来会非常麻烦，一个一个房主去找，会累坏我们，正确的做法就是去找房屋中介。对于房主而言，他只需要把自己房子的信息交给中介进行管理即可，而对于购房者来说，他只需要去找对应的房屋中介就行，房屋中介会根据他的需求去找对应的房主协商，并给购房者一些比较不错的建议。</p>
<p><img src="/./assets/1709706458388-c534f248-d85c-49d6-8e09-9dbf7ebf7f68.png" alt="img"></p>
<p>如果此时购房者的需求发生了变化，那么他并不需要把他的需求告知给所有的房主，而只需要告知给房屋中介即可，房屋中介会根据他的需求帮他去选择合适的房子，这就是中介者模式。</p>
<p>那什么是中介者模式呢？下面我们来看一下它的概念。</p>
<p>中介者模式又叫调停模式，它定义了一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p>
<p>上述中介者模式的概念，大家看着可能挺懵的，这没关系，下面我给大家稍微解释一下。</p>
<p>就拿上述购房者买房的案例来说，房屋中介就是中介者角色，它封装了房主以及购房者之间的交互关系，这样就会使得房主和购房者之间的耦合变得松散，要是没有房屋中介的话，购房者买房就只能去找房主了，一旦看的房子他不满意，他还需要再去找另外一个房主，还不满意的话，还得继续去找其他房主，那么这就非常耗时、耗资源了。并且对于房屋中介来说，它可以独立地改变购房者和房主之间的交互，因为购房者和房主之间要沟通的话，就得经过房屋中介。其实，从这里就可以看出，购房者和房主就是上面我所说的同事类。</p>
<p>理解了中介者模式的概念之后，接下来，我们就来看看中介者模式的结构，也就是它里面所拥有的角色。</p>
<h3 id="6-7-2-结构"><a href="#6-7-2-结构" class="headerlink" title="6.7.2. 结构"></a>6.7.2. 结构</h3><p>中介者模式包含以下主要角色：</p>
<ul>
<li>抽象中介者（Mediator）角色：它是中介者的接口（当然了，对于该角色而言，你既可以把它定义成接口，也可以把它定义成抽象类），提供了同事对象注册与转发同事对象信息的抽象方法，很显然，该方法由具体中介者角色来实现。</li>
<li>具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个List集合来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。看到这个角色，大家是不是想到了房屋中介啊！正是有了房屋中介，购房者买房时，就简单多了，房屋中介会根据购房者的需求去选择合适的房源以及找到对应的房主。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。注意了，在抽象同事类角色里面，一定要保存中介者对象。原因是很明显的，就拿购房者买房的案例来说，不仅房主要记住对应的中介，而且购房者也要记住对应的中介，不然的话，购房者又该如何去找房呢？</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。就拿购房者买房的案例来说，购房者要买房，房屋中介会根据他的需求去找对应的房主，也就是说购房者只需把他的需求告诉房屋中介即可，这样房屋中介就会根据他的需求去找对应房主商谈诸事宜。</li>
</ul>
<h3 id="6-7-3-中介者模式案例"><a href="#6-7-3-中介者模式案例" class="headerlink" title="6.7.3. 中介者模式案例"></a>6.7.3. 中介者模式案例</h3><p>接下来，按照惯例我们通过一个案例来让大家再去理解一下中介者模式的概念，以及它里面所包含的角色，这个案例就是租房。</p>
<h4 id="6-7-3-1-分析"><a href="#6-7-3-1-分析" class="headerlink" title="6.7.3.1. 分析"></a>6.7.3.1. 分析</h4><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。因此，房屋中介充当的是租房者与房屋所有者之间的中介者，而对于租房者与房屋所有者来说，他们都是属于同事类。</p>
<p>接下来，我们再来看一下下面的这张类图。</p>
<p><img src="/./assets/1709706458426-99f09caf-31b5-41c1-89ed-02d0d7fbad75.png" alt="img"></p>
<p>可以看到，有Mediator这么一个抽象类，很明显，该类充当的就是中介者模式里面的抽象中介者角色，它里面声明有一个方法，即和同事类进行交互的方法。</p>
<p>然后，我们再来看一看MediatorStructure类，该类充当的是中介者模式里面的具体中介者角色。很明显，该类继承了以上抽象中介者角色类，而且该类里面还聚合了HouseOwner类和Tenant类的对象，它俩分别代指的是房主和租房者。把这俩对象聚合进来之后，我们肯定是要给它们提供对应的getter和setter方法的，除此之外，该类里面还重写了父类中和同事类进行交互的方法。</p>
<p>接着，我们再来看一个类，即Person，该类充当的是中介者模式里面的抽象同事类角色。可以看到，该类里面有两个成员变量，一个是String类型的name变量，一个是中介者类型（即Mediator类型）的变量，所以从上图中你也能看到该类和Mediator类之间是聚合关系。除此之外，我们还能看到，该类还提供了一个有参的构造方法。</p>
<p>最后，我们来看一下以上抽象同事类的两个子类，一个是租房者类，即Tenant，一个是房屋拥有者类，即HouseOwner。这俩类除了定义各自对应的构造方法之外，还定义有和中介者进行交互的constact方法以及获取另外一个同事对象传递过来的信息的getMessage方法，当然，该信息是由中介者传递过来的。</p>
<p>分析完以上类图之后，接下来我们就要编写代码实现以上租房案例了。</p>
<h4 id="6-7-3-2-实现"><a href="#6-7-3-2-实现" class="headerlink" title="6.7.3.2. 实现"></a>6.7.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即mediator，也即实现以上租房案例的具体代码我们是放在了该包下。</p>
<p>然后，创建抽象中介者类，这里我们就命名为了Mediator。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象中介者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 20:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行沟通的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message：和中介沟通的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person：Person类是同事类顶层父类，这儿具体是哪个同事类和中介去沟通呢？这个得在具体中介者类中去明确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message, Person person)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建抽象同事类，这里我们就命名为Person了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象同事类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name; <span class="comment">// 租房者或者房主的姓名</span></span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator; <span class="comment">// 中介者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Mediator mediator)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建具体同事类。这里我们先创建租房者类，名称不妨就叫作Tenant。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的同事角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tenant</span> <span class="keyword">extends</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tenant</span><span class="params">(String name, Mediator mediator)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和中介联系（沟通）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span> {</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>); <span class="comment">// 这儿究竟是谁和中介去沟通呢？肯定是当前类的对象，是不是啊！所以这儿直接把this传递进来就可以了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message：房主反馈回来的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span> {</span><br><span class="line">        System.out.println(<span class="string">"租房者"</span> + name + <span class="string">"获取到的信息是："</span> + message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建房屋拥有者类，这里我们就命名为HouseOwner了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的同事角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseOwner</span> <span class="keyword">extends</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和中介联系（沟通）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span> {</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>); <span class="comment">// 这儿究竟是谁和中介去沟通呢？肯定是当前类的对象，是不是啊！所以这儿直接把this传递进来就可以了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message：租房者反馈回来的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span> {</span><br><span class="line">        System.out.println(<span class="string">"房主"</span> + name + <span class="string">"获取到的信息是："</span> + message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>抽象同事类和两个具体同事类创建完毕之后，接下来，我们来创建具体中介者类，这里我们不妨就起名为MediatorStructure。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的中介者角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 20:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorStructure</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合房主和租房者对象。为什么要聚合这俩对象呢？因为中介机构必须知道所有房主和租房者的信息！</span></span><br><span class="line">    <span class="keyword">private</span> HouseOwner houseOwner;</span><br><span class="line">    <span class="keyword">private</span> Tenant tenant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HouseOwner <span class="title function_">getHouseOwner</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> houseOwner;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseOwner</span><span class="params">(HouseOwner houseOwner)</span> {</span><br><span class="line">        <span class="built_in">this</span>.houseOwner = houseOwner;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Tenant <span class="title function_">getTenant</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tenant;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTenant</span><span class="params">(Tenant tenant)</span> {</span><br><span class="line">        <span class="built_in">this</span>.tenant = tenant;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message, Person person)</span> {</span><br><span class="line">        <span class="comment">// 中介机构和谁进行沟通，是不是得进行判断一下啊？</span></span><br><span class="line">        <span class="keyword">if</span> (person == houseOwner) { <span class="comment">// 若中介机构和房主进行沟通，则最终租房者应获得信息</span></span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 若中介机构和租房者进行沟通，则最终房主应获得信息</span></span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-17 23:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建中介者对象</span></span><br><span class="line">        <span class="type">MediatorStructure</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediatorStructure</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建租房者对象</span></span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tenant</span>(<span class="string">"李四"</span>, mediator);</span><br><span class="line">        <span class="comment">// 创建房主对象</span></span><br><span class="line">        <span class="type">HouseOwner</span> <span class="variable">houseOwner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseOwner</span>(<span class="string">"张三"</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介者要知道具体的房主和租房者</span></span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 租房者去跟中介沟通，这样中介就会将沟通的信息直接传递给具体的房主，房主就能获取到这个信息了。</span></span><br><span class="line">        tenant.constact(<span class="string">"我要租三室一厅的房子！！！"</span>);</span><br><span class="line">        <span class="comment">// 房主获取到信息之后，他也得和中介沟通，中介再把沟通的信息告诉给租房者</span></span><br><span class="line">        houseOwner.constact(<span class="string">"我这里有三室一厅的房子，你要租吗？"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到租房者首先会将他的需求告诉给房屋中介，而房屋中介会再将该要求告知给具体的房主，这样，房主就知道租房者的诉求了。然后，房主再反馈给房屋中介，而房屋中介会将该反馈信息告知给租房者，于是，租房者就能知道这个反馈信息了。</p>
<p><img src="/./assets/1709706458405-d4f98ed3-9a64-4e53-911c-fd11d949dd42.png" alt="img"></p>
<p>以上就是我们要实现的租房案例。在该案例中，你会发现，租房者和房主这俩对象现在是没有任何关联关系的，它俩都是通过房屋中介去关联的。因此，如果租房者的需求发生了一个变化的话（或者租房者类里面的业务逻辑进行了一个改变），那么他只需要去告知给对应的房屋中介即可，而且此时对于其他的房主类来说，代码是不需要进行改动的。</p>
<h3 id="6-7-4-中介者模式的优缺点以及使用场景"><a href="#6-7-4-中介者模式的优缺点以及使用场景" class="headerlink" title="6.7.4. 中介者模式的优缺点以及使用场景"></a>6.7.4. 中介者模式的优缺点以及使用场景</h3><p>接下来，我们就来看一看中介者模式的优缺点以及使用场景。</p>
<h4 id="6-7-4-1-优缺点"><a href="#6-7-4-1-优缺点" class="headerlink" title="6.7.4.1. 优缺点"></a>6.7.4.1. 优缺点</h4><h5 id="6-7-4-1-1-优点"><a href="#6-7-4-1-1-优点" class="headerlink" title="6.7.4.1.1. 优点"></a>6.7.4.1.1. 优点</h5><p>关于中介者模式的优点，这里我总结了三点。</p>
<ol>
<li>松散耦合。中介者模式通过把多个同事对象之间的交互封装到中介者对象里面（也就是说，多个同事对象之间的关联是在中介者对象里面体现出来的），从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样”牵一处而动全身”了。大家在这里一定要注意，如果某个同事类里面的逻辑发生了变化，那么相应的我们可能就要去修改中介者角色类的代码了，但是，大家要知道此时我们是不需要去修改和该同事类关联的其他同事类的代码的。</li>
<li>集中控制交互。多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了。当然，如果是已经做好的系统，那么就扩展中介者对象，而各个同事类则不需要做修改。也就是说，此时我们可以再去创建一个抽象中介者类的子类，而对于其他的同事类而言，基本上都不需要修改，因为对于同事类来说，它依赖的是抽象。<img src="/./assets/1709706459108-34a4daae-c9e6-4ba5-be57-24a29f283def.png" alt="img">说到集中控制交互，我就要多说一点了，如果大家想做一个聊天工具的话，那么就可以使用中介者模式来实现了。当然，这里我就不具体实现了，有兴趣的同学可以私下自己来试着实现一下。</li>
<li>一对多关联转变为一对一的关联。没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成了双向的一对一这种关系，这会让对象的关系更容易理解和实现。</li>
</ol>
<h5 id="6-7-4-1-2-缺点"><a href="#6-7-4-1-2-缺点" class="headerlink" title="6.7.4.1.2. 缺点"></a>6.7.4.1.2. 缺点</h5><p>当同事类太多时，中介者的职责将会很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<p>在上述租房案例里面，同事类也就两个，即租房者和房主，他俩之间相互关联的关系相对来说还是比较简单的，但是，一旦同事类特别多的话，那么中介者的责任将会变得很大，具体体现在具体中介者类里面的方法实现起来会比较麻烦。</p>
<h4 id="6-7-4-2-使用场景"><a href="#6-7-4-2-使用场景" class="headerlink" title="6.7.4.2. 使用场景"></a>6.7.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用中介者模式了。</p>
<ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。相信大家也看到了，正是基于这一场景，在上述租房案例中我们才使用了中介者模式。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。其实，这儿说的是想创建一个中介者角色类，因为中介者模式里面最重要的就是中介者角色，它在整个模式中起到了一个关键性的作用。</li>
</ul>
<hr>
<h2 id="6-8-迭代器模式"><a href="#6-8-迭代器模式" class="headerlink" title="6.8. 迭代器模式"></a>6.8. 迭代器模式</h2><h3 id="6-8-1-概述"><a href="#6-8-1-概述" class="headerlink" title="6.8.1. 概述"></a>6.8.1. 概述</h3><p>相信大家对于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&amp;spm=1001.2101.3001.7020">迭代器</a>并不会感到陌生，因为平时我们使用的还是比较多的，注意，在这儿我说的是使用。</p>
<p>在开发过程中我们会经常去遍历单列集合，既然要遍历，那么我们就可以选择使用迭代器去遍历了，而迭代器底层使用的就是迭代器模式。那么到底什么是迭代器模式呢？下面我们就来看看它的概念。</p>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p>看完迭代器模式的概念，相信大家一时半会还无法理解，不过没关系，下面我给大家解释一下。</p>
<p>迭代器模式是说提供一个对象来顺序访问聚合对象中的一系列数据，而这其实指的就是遍历，这句话中的聚合对象，大家可以理解成是集合（或者容器），自然地，聚合对象中的一系列数据就是指该集合（或者容器）里面存储的元素了。那么这样遍历有什么作用呢？不暴露聚合对象的内部表示，也就是说我们并不需要去关注集合（或者容器）内部是如何去存储元素的。</p>
<p>以上就是迭代器模式的概念，其实说到底，就是提供了一种遍历的方式。</p>
<p>理解了迭代器模式的概念之后，接下来，我们就来看看迭代器模式的结构，也就是它里面所拥有的角色。</p>
<h3 id="6-8-2-结构"><a href="#6-8-2-结构" class="headerlink" title="6.8.2. 结构"></a>6.8.2. 结构</h3><p>迭代器模式主要包含以下角色：</p>
<ul>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素（聚合元素，你可以理解成是容器里面存储的数据）以及创建迭代器对象的接口。注意了，该角色只是提供了这么一些抽象方法，而这些抽象方法是要由子类来实现的，这个子类就是具体聚合角色类。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含hasNext()、next()等方法，hasNext()方法是用于判断是否还有元素的，而next()方法是用于获取下一个元素的。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
</ul>
<p>下面我会通过一个具体的案例来让大家再深入认识一下以上迭代器模式的四个角色。</p>
<h3 id="6-8-3-迭代器模式案例"><a href="#6-8-3-迭代器模式案例" class="headerlink" title="6.8.3. 迭代器模式案例"></a>6.8.3. 迭代器模式案例</h3><p>接下来，按照惯例我们通过一个案例来让大家再去理解一下迭代器模式的概念，以及它里面所包含的角色。这个案例就是定义一个可以存储学生对象的容器对象，并将遍历该容器的功能交由迭代器实现。</p>
<h4 id="6-8-3-1-分析"><a href="#6-8-3-1-分析" class="headerlink" title="6.8.3.1. 分析"></a>6.8.3.1. 分析</h4><p>在该案例中，我们需要定义一个可以存储学生对象的容器对象，其实说到底就是让我们自定义一个集合，而这个集合里面存储的是学生对象。然后再将遍历该容器的功能交由迭代器实现，而这正好就要用到迭代器模式。</p>
<p>接下来，我们来看一下下面的这张类图。</p>
<p><img src="/./assets/1709706524778-2023d12f-ec4e-439c-aff3-1d0f9afc13b6.png" alt="img"></p>
<p>可以看到，以上类图的最下面有一个学生类，即Student，该类的对象就是容器里面要存储的元素。至于该类里面的属性和方法，你想定义什么都行（这不，该类我们是像上面类图那样设计的），因为该类的对象就是往容器里面去存的，也就是说容器里面只能存储学生对象。</p>
<p>然后，我们来看一下以上类图的左侧部分。可以看到，上面有一个接口，名称是StudentIterator，翻译过来就是学生迭代器，很明显，该接口充当的就是迭代器模式里面的抽象迭代器角色。而且，该接口里面定义了两个规范方法，分别是：</p>
<ol>
<li>boolean hasNext()：判断是否还有元素。</li>
<li>Student next()：获取下一个元素。注意，该方法的返回类型是Student类型，并不是特别通用，因为该方法只能获取学生对象。如果你想让该方法更通用，即能获取其他任意类型的对象，那么不妨用一下泛型。当然了，这儿我并没有这样去做啊，所以就不做过多的说明了。</li>
</ol>
<p>再来看下面，可以看到下面有一个类，名称是StudentIteratorImpl，很明显，该类就是以上抽象迭代器接口的子实现类，那么它充当的就是迭代器模式里面的具体迭代器角色。而且，该类里面声明了两个成员变量，一个是List<student>类型的成员变量，很显然，该成员变量里面存储的是学生对象。为什么要在该类里面声明这么一个类型的成员变量呢？这是因为到时候我们定义的容器里面存储的就是学生对象，当然了，使用的也是List集合来存储学生对象。此外，还有一个int类型的成员变量，该成员变量是用来记录遍历时的位置的。</student></p>
<p>大家也能看到，在该具体迭代器类中，我们还提供了一个有参的构造方法，它就是用于给List<student>类型的成员变量赋值的。除此之外，该类还重写了父接口里面的两个抽象方法。</student></p>
<p>最后，我们来看一下以上类图的右侧部分。可以看到，上面有一个接口，名称是StudentAggregate，该接口充当的是迭代器模式里面的抽象聚合角色。而且，该接口里面定义了一些规范方法，分别是：</p>
<ol>
<li>void addStudent(Student student)：往聚合对象里面添加学生对象。</li>
<li>void removeStudent(Student student)：从聚合对象里面删除学生对象。</li>
<li>StudentIterator getStudentIterator()：获取学生迭代器对象。</li>
</ol>
<p>注意，以上只是一些规范方法，具体应该由具体的子类来实现。</p>
<p>再来看下面，可以看到下面有一个类，名称是StudentAggregateImpl，很明显，该类就是以上抽象聚合接口的子实现类，那么它充当的就是迭代器模式里面的具体聚合角色。而且，从上还可以看到，该类的成员位置处定义了一个List集合，而集合里面存储的正是学生对象。当然，我们现在是在设计，肯定是知道这个聚合对象里面的具体的实现的，然而，对于使用者来说，他到时候就不用去关注于底层是如何实现的了。除此之外，该类还重写了父接口里面的三个抽象方法。</p>
<p>至此，对于以上类图中所涉及到的类和接口，我们就一一分析清楚了。至于类和类，以及类和接口之间的关系，大家看上图便知道了。</p>
<h4 id="6-8-3-2-实现"><a href="#6-8-3-2-实现" class="headerlink" title="6.8.3.2. 实现"></a>6.8.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即iterator，也即实现以上案例的具体代码我们是放在了该包下。</p>
<p>然后，创建学生类，这里我们就命名为Student了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String num; <span class="comment">// 学号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(String num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student{"</span> +</span><br><span class="line">        <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", num='"</span> + num + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建迭代器接口，这里我们不妨就命名为StudentIterator。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象迭代器角色接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 10:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否还有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为我们这儿是专门用来遍历学生对象的，所以该方法的返回值类型我们就设置为了Student。</span></span><br><span class="line"><span class="comment">     * 当然，如果你想让该方法更通用，那么不妨使用一下泛型，只是在这里我并没有这样去做！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建具体迭代器类，这里我们不妨就命名为StudentIteratorImpl。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体迭代器角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 声明一个List&lt;Student&gt;类型的成员变量，这样，该成员变量里面存储的就是学生对象了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么要在该类里面声明这么一个类型的成员变量呢？这是因为在具体聚合类中，本质上存储</span></span><br><span class="line"><span class="comment">     * 元素的就是List集合，所以在这里我们也声明一个List&lt;Student&gt;类型的成员变量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来记录遍历时的位置，也就是说我们遍历到了第几个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> {</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 从集合中获取指定位置的元素</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">currentStudent</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        <span class="comment">// 获取到当前学生对象之后，千万别忘了让位置发生一个变化，因为当前位置的元素我们已经获取了</span></span><br><span class="line">        position++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>抽象迭代器接口与具体迭代器类创建完毕之后，接下来我们就要创建抽象聚合接口与具体聚合类了。这里我们先创建抽象聚合接口，名称不妨就叫作StudentAggregate。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象聚合角色接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 10:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student stu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除学生功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student stu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器对象功能</span></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>很显然，这里我们就要创建具体聚合类了，名称不妨就叫作StudentAggregateImpl。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体聚合角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于该类的对象是一个聚合对象，所以我们应该先创建一个能存储元素的集合。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;(); <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student stu)</span> {</span><br><span class="line">        list.add(stu);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student stu)</span> {</span><br><span class="line">        list.remove(stu);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 注意，创建迭代器对象时，我们是把当前聚合对象里面的List集合作为一个参数进行了传递，</span></span><br><span class="line"><span class="comment">         * 这样，迭代器对象里面的List集合就和当前聚合对象里面的List集合保持一致了，所以，当</span></span><br><span class="line"><span class="comment">         * 我们使用迭代器遍历元素时，实际上我们获取的就是聚合对象里面的容器（List集合）中的元素！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 11:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建聚合对象</span></span><br><span class="line">        <span class="type">StudentAggregateImpl</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentAggregateImpl</span>();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        aggregate.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"张三"</span>, <span class="string">"001"</span>));</span><br><span class="line">        aggregate.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"李四"</span>, <span class="string">"002"</span>));</span><br><span class="line">        aggregate.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"王五"</span>, <span class="string">"003"</span>));</span><br><span class="line">        aggregate.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"赵六"</span>, <span class="string">"004"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历聚合对象</span></span><br><span class="line">        <span class="comment">// 1. 获取迭代器对象</span></span><br><span class="line">        <span class="type">StudentIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> aggregate.getStudentIterator();</span><br><span class="line">        <span class="comment">// 2. 遍历</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">            <span class="comment">// 3. 获取元素</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(student.toString());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类，打印结果如下图所示，可以看到确实是按照学生对象添加的顺序将添加进去的学生列表给打印出来了。</p>
<p><img src="/./assets/1709706524837-e84da83d-8ba8-4338-97fd-f3d4d3c3347d.png" alt="img"></p>
<p>以上就是迭代器模式在开发中的一个具体应用。当然，相信大家对于以上客户端类的代码应该是无比熟悉的，因为使用迭代器对单列集合进行遍历的代码和上面是一模一样的，只是这里我给大家主要讲的是设计的思想。</p>
<h3 id="6-8-4-迭代器模式的优缺点以及使用场景"><a href="#6-8-4-迭代器模式的优缺点以及使用场景" class="headerlink" title="6.8.4. 迭代器模式的优缺点以及使用场景"></a>6.8.4. 迭代器模式的优缺点以及使用场景</h3><p>接下来，我们就来看一看迭代器模式的优缺点以及使用场景。</p>
<h4 id="6-8-4-1-优缺点"><a href="#6-8-4-1-优缺点" class="headerlink" title="6.8.4.1. 优缺点"></a>6.8.4.1. 优缺点</h4><h5 id="6-8-4-1-1-优点"><a href="#6-8-4-1-1-优点" class="headerlink" title="6.8.4.1.1. 优点"></a>6.8.4.1.1. 优点</h5><p>关于迭代器模式的优点，这里我总结了三点。</p>
<ol>
<li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。假设我们自己要去定义一个迭代器的子类的话，那么应该怎么办呢？首先，肯定是得让它去实现StudentIterator接口，然后还需要稍微修改一下具体聚合类的代码，即在获取迭代器对象的方法中返回我们自己定义的迭代器对象。</li>
<li>迭代器简化了聚合类。由于引入了迭代器，所以在原有的聚合对象中不再需要自行提供数据遍历等方法，这样就可以简化聚合类的设计了。</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，所以满足了”开闭原则”的要求。</li>
</ol>
<h5 id="6-8-4-1-2-缺点"><a href="#6-8-4-1-2-缺点" class="headerlink" title="6.8.4.1.2. 缺点"></a>6.8.4.1.2. 缺点</h5><p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<p>其实，对于我们来说，使用迭代器模式所带来的这个缺点也是能够接受的，无非就是多引入了抽象迭代器角色和具体迭代器角色这俩角色。</p>
<h4 id="6-8-4-2-使用场景"><a href="#6-8-4-2-使用场景" class="headerlink" title="6.8.4.2. 使用场景"></a>6.8.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用迭代器模式了。</p>
<ul>
<li>当需要为聚合对象提供多种遍历方式时。此时我们就可以考虑使用迭代器模式了，因为迭代器模式说到底主要就是给聚合对象提供遍历方式。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<p>其实，以上三种使用场景归根结底无非就是说迭代器模式为聚合对象提供了一种遍历方式，所以，只要牵扯到和遍历相关的操作，我们就可以考虑使用迭代器模式了。</p>
<hr>
<h3 id="6-8-5-迭代器模式在JDK源码中的应用"><a href="#6-8-5-迭代器模式在JDK源码中的应用" class="headerlink" title="6.8.5. 迭代器模式在JDK源码中的应用"></a>6.8.5. 迭代器模式在JDK源码中的应用</h3><p>接下来，我们就来看一下迭代器模式在JDK源码中的具体应用。</p>
<p>迭代器模式在Java的很多集合类中都被广泛应用到了，只是这里所说的集合特指单列集合。接下来，我们就来看看Java源码中是如何使用迭代器模式的。</p>
<p>先来看下面这一段代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); <span class="comment">// list.iterator()方法返回的肯定是Iterator接口的子实现类对象。那到底是哪个子实现类的对象呢？别着急，后面我就会讲到。</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看完这段代码是不是很熟悉啊，与我们上面案例里面写的代码基本类似。</p>
<p>既然单列集合都使用到了迭代器，那么接下来我们就以ArrayList举例来说明它是如何使用迭代器模式的。</p>
<p>首先，我们先来分析一下ArrayList使用的迭代器模式里面各个角色所对应的类和接口分别是哪些。</p>
<ul>
<li>List：抽象聚合接口</li>
<li>ArrayList：具体聚合类</li>
<li>Iterator：抽象迭代器接口</li>
<li>list.iterator()：ArrayList类里面的iterator方法返回的是实现了Iterator接口的具体迭代器对象。</li>
</ul>
<p>问题来了，究竟具体迭代器对象是Iterator接口的哪个子实现类的对象呢？下面我们就来具体看看ArrayList类的源码实现，从源码中来寻找答案。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        Itr() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里，我只是摘出了ArrayList类中我们要分析的代码。可以看到，ArrayList类实现了List接口，并重写了iterator方法，当然该方法的返回值类型是Iterator，大家要注意的是它是一个接口，所以我们就知道了iterator方法返回的肯定是Iterator接口的子实现类对象。而且，从iterator方法内部我们也知道了这个子实现类的名称就叫Itr，那该子实现类是在哪定义的呢？</p>
<p>其实，该子实现类就定义在iterator方法下面，也就是说Itr是ArrayList里面定义的私有成员内部类，并且它还实现了Iterator接口，重写了hasNext和next这俩方法，所以，Itr就是具体迭代器类。</p>
<p>分析完ArrayList使用的迭代器模式里面各个角色所对应的类和接口分别是哪些之后，你就知道迭代器模式在JDK源码中的具体应用了。</p>
<p>最后，我总结一点：<strong>当我们在使用Java开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<strong><strong>java.lang.Iterable</strong></strong>接口并实现其中的iterator()方法使其返回一个<strong><strong>java.util.Iterator</strong></strong>接口的子实现类就可以了</strong>。</p>
<hr>
<hr>
<h2 id="6-9-访问者模式-双分派"><a href="#6-9-访问者模式-双分派" class="headerlink" title="6.9. 访问者模式 (双分派)"></a>6.9. 访问者模式 <strong>(双分派)</strong></h2><h3 id="6-9-1-概述"><a href="#6-9-1-概述" class="headerlink" title="6.9.1. 概述"></a>6.9.1. 概述</h3><p>先来看一下访问者模式的概念。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</span><br></pre></td></tr></tbody></table></figure>

<p>上述访问者模式的概念看完之后，相信大家都懵了，没关系，下面我给大家解释解释。</p>
<p>访问者模式是说封装一些作用于某种数据结构中的各元素的操作，这句话表示什么含义呢？其实就是说将数据结构和元素的操作进行了一个分离，分离之后，访问者模式就可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<p>可能我这样解释了之后，大家可能还不是特别理解，但没关系，后面我会通过一个案例再来对访问者模式进行一个讲解，相信大家一定能明白访问者模式的概念。</p>
<p>知道了访问者模式的概念之后，接下来，我们就来看看访问者模式的结构，也就是它里面所拥有的角色。</p>
<h3 id="6-9-2-结构"><a href="#6-9-2-结构" class="headerlink" title="6.9.2. 结构"></a>6.9.2. 结构</h3><p>访问者模式包含以下主要角色：</p>
<ul>
<li>抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（即Element抽象元素角色类的实现类的个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。看完抽象访问者角色的概念，哎，你会发现概念中提到了元素这一东东，这不禁让我们想到了集合，因为集合里面存储的就是元素，所以在这儿必定会有一个容器性质的对象，这个留待我们后续再说。另外，我也不知道大家有没有看懂以上抽象访问者角色的概念，要是没看懂的话，我这里再来重新解释一遍。<strong>一般来说，我们会将抽象访问者角色定义成一个接口，然后在该接口中定义对每一个元素访问的方法，当然了，方法的参数就是可以访问的元素，所以有多少个具体元素角色类，那么该接口里面就要提供多少个方法。这也就是说，理论上讲，方法个数应与元素类个数（即Element抽象元素类的实现类的个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变，如果改变了的话，那么你就不能使用访问者模式了。所以，使用访问者模式的要求还是比较苛刻的，相信大家也不难看出访问者模式在实际开发中使用的其实并不是特别多！</strong></li>
<li>具体访问者（Concrete Visitor）角色：给出对每一个元素类访问时所产生的具体行为。说到底其实就是对抽象访问者角色里面方法的一个实现。</li>
<li>抽象元素（Element）角色：定义了一个接受访问者的方法（即accept），其意义是指，每一个元素都要可以被访问者访问。注意了，该角色只是定义了一个规范，而该规范由谁来实现呢？由具体元素角色类来实现。</li>
<li>具体元素（Concrete Element）角色：提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
<li>对象结构（Object Structure）角色：定义当中所提到的对象结构（其实指的就是访问者模式概念里面所提到的数据结构），对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会包含一组元素（Element），并且可以迭代这些元素，供访问者访问。</li>
</ul>
<p>相信大家看完以上访问者模式所包含的角色之后，应该是一脸懵逼的😥，不过这没关系，下面我会通过一个具体的案例来让大家再深入认识一下以上访问者模式的五个角色。</p>
<h3 id="6-9-3-访问者模式案例"><a href="#6-9-3-访问者模式案例" class="headerlink" title="6.9.3. 访问者模式案例"></a>6.9.3. 访问者模式案例</h3><p>接下来，按照惯例我们通过一个案例来让大家再去理解一下访问者模式的概念，以及它里面所包含的角色，而这个案例就是给宠物喂食。</p>
<h4 id="6-9-3-1-分析"><a href="#6-9-3-1-分析" class="headerlink" title="6.9.3.1. 分析"></a>6.9.3.1. 分析</h4><p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗、猫等，要给宠物喂食的话，不仅主人可以喂，其他人也是可以进行喂食的。</p>
<p>接下来，我们就来分析一下访问者模式里面的各个角色在该案例中分别是由谁来充当的。</p>
<ul>
<li>抽象访问者角色：给宠物喂食的人。</li>
<li>具体访问者角色：主人、其他人。</li>
<li>抽象元素角色：动物抽象类。</li>
<li>具体元素角色：宠物狗、宠物猫。</li>
<li>结构对象角色：主人家。</li>
</ul>
<p>分析完之后，我们就来看一下下面这张类图。</p>
<p><img src="/./assets/1709986308920-a919ddb9-3c5b-4e31-bc14-578108b76a81.png" alt="img">上类图之后，接下来我们就要逐一分析以上类图中所涉及到的类和接口，以及类和类、类和接口之间的关系了。</p>
<p>首先，我们先来看一下以上类图的左侧部分，可以看到上面有一个接口，名称为Animal，很显然，该接口充当的就是访问者模式里面的抽象元素角色。而且，该接口里面还提供了一个accept方法，很明显，该方法就是用来接受访问者访问的。不过大家要注意了，该方法还须接收一个Person类型的参数，而Person就是一个接口，这在类图的右侧部分就能看到，后面我再来讲解该接口啊！</p>
<p>对于Animal接口来说，它有两个子实现类，一个是Dog（即宠物狗类），一个是Cat（即宠物猫类），显然它俩都得实现Animal接口并重写里面的accept抽象方法，注意，它俩充当的是访问者模式里面的具体元素角色。</p>
<p>然后，我们再来看一下以上类图的右侧部分，可以看到上面也有一个接口，名称为Person，很显然，该接口充当的就是访问者模式里面的抽象访问者角色。而且，该接口里面还提供了两个feed方法，之前我在给大家讲述抽象访问者角色时就说过，对于它里面的方法来说，方法的个数以及参数是有一定特点的，方法个数的话，是和抽象元素角色类的子实现类的个数保持一致的，很明显，现在有两个子实现类，所以在Person接口里面我们就得提供两个feed方法；方法参数的话，就是具体元素角色类，即Cat和Dog，从上图中你也能清晰地看到。我之所以给大家解释的这么详细，就是希望大家能记住抽象访问者角色里面方法的以上特点。</p>
<p>对于Person接口来说，它也有两个子实现类，一个是Owner（即主人类），一个是Someone（即其他人类），显然它俩都得实现Person接口并重写里面的feed抽象方法，注意，它俩充当的是访问者模式里面的具体访问者角色。</p>
<p>接着，我们再来看一下Home这个类，很显然，它充当的就是访问者模式里面的对象结构角色。可以看到，该类里面声明了一个List<animal>类型的成员变量，也就是说该成员变量就是一个List集合，而且List集合里面存储的元素类型是Animal，所以，大家可以把该类看作是一个容器。</animal></p>
<p>此外，Home这个类里面还定义了两个方法，一个是add方法，它是往上述List集合里面去添加元素的，而且元素是Animal接口类型的；还有一个是action方法，它是来接受访问者访问的，访问谁呢？访问的就是List集合里面的元素。</p>
<p>最后，还有一个客户端类，该类就是用来做测试的，比较简单，所以这里我就不费多的笔墨去讲它了。</p>
<p>至此，以上类图我们就分析完了，接下来我们就要编写代码来实现以上给宠物喂食的案例了。</p>
<h4 id="6-9-3-2-实现"><a href="#6-9-3-2-实现" class="headerlink" title="6.9.3.2. 实现"></a>6.9.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即visitor，也即实现以上案例的具体代码我们是放在了该包下。</p>
<p>然后，创建抽象访问者接口，这里我们就命名为Person了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象访问者角色接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 喂食宠物猫</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 喂食宠物狗</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上抽象访问者接口创建完毕之后，你会发现具体元素类（即Dog和Cat）还没有创建出来，所以接下来我们来创建抽象元素接口和其对应的具体元素类。</p>
<p>先创建抽象元素接口，这里我们不妨就命名为Animal。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象元素角色接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受访问者访问的功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建具体元素类，一个是宠物猫类，即Cat。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体元素角色类（宠物猫）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这儿是宠物猫接受具体访问者进行访问，访问是怎么访问呢？是不是就是喂食呀？</span></span><br><span class="line"><span class="comment">         * 而调用feed方法进行喂食的话，就得把当前对象（即this）作为参数进行一个传</span></span><br><span class="line"><span class="comment">         * 递，这表示的就是访问者给宠物猫进行喂食！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">"好好吃，喵喵喵..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一个是宠物狗类，即Dog。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体元素角色类（宠物狗）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这儿是宠物狗接受具体访问者进行访问，访问是怎么访问呢？是不是就是喂食呀？</span></span><br><span class="line"><span class="comment">         * 而调用feed方法进行喂食的话，就得把当前对象（即this）作为参数进行一个传</span></span><br><span class="line"><span class="comment">         * 递，这表示的就是访问者给宠物狗进行喂食！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">"好好吃，汪汪汪..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，以上两个类都实现了Animal接口并重写了它里面的accept方法，值得注意的是，我们并没有在这两个类里面定义其他的方法，当然，在实际开发中可能就不会这么简单了，或许还有一些别的需求，让我们不得不再去定义一些其他方法。</p>
<p>接着，创建不同的具体访问者类，一个是主人类，即Owner。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体访问者角色类（主人自己）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> {</span><br><span class="line">        System.out.println(<span class="string">"主人喂食猫"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> {</span><br><span class="line">        System.out.println(<span class="string">"主人喂食狗"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一个是其他人类，即Someone。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体访问者角色类（其他人）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> {</span><br><span class="line">        System.out.println(<span class="string">"其他人喂食猫"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> {</span><br><span class="line">        System.out.println(<span class="string">"其他人喂食狗"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建对象结构类，在此案例中就是主人的家，所以这里我们不妨就命名为Home。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象结构类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个集合对象，用来存储元素对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> {</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> {</span><br><span class="line">        <span class="comment">// 遍历集合，获取每一个元素，并让访问者访问每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (Animal animal : nodeList) {</span><br><span class="line">            animal.accept(person);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建一个客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 12:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建Home对象</span></span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        <span class="comment">// 添加元素到Home对象中，也就是给家里边买几个宠物</span></span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建主人对象</span></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        <span class="comment">// 让主人喂食所有的宠物</span></span><br><span class="line">        home.action(owner);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类的代码，打印结果如下图所示，可以看到主人喂食了家里面的所有宠物，而这确实是我们所想要的结果。</p>
<p><img src="/./assets/1709706785751-e9137a20-0548-4f08-b69f-06b0d636594b.png" alt="img"></p>
<p>现在我们开动脑筋来想一下，假如我们现在要去逗宠物玩，那么应该如何去做呢？大家注意了啊，在Person接口里面，我们是统一将方法的名称定义成了feed，大家一看便知这是喂食的意思，其实，我们可以将方法的名称定义得更模糊一些，这样，我们在创建该Person接口的子实现类，实现它里面的方法时，就可以不再是喂食宠物，而是逗宠物玩了。我话讲完，大家现在该知道如何去做了吧！</p>
<h3 id="6-9-4-访问者模式的优缺点以及使用场景"><a href="#6-9-4-访问者模式的优缺点以及使用场景" class="headerlink" title="6.9.4. 访问者模式的优缺点以及使用场景"></a>6.9.4. 访问者模式的优缺点以及使用场景</h3><p>接下来，我们来看一下访问者模式的优缺点以及使用场景。</p>
<h4 id="6-9-4-1-优缺点"><a href="#6-9-4-1-优缺点" class="headerlink" title="6.9.4.1. 优缺点"></a>6.9.4.1. 优缺点</h4><h5 id="6-9-4-1-1-优点"><a href="#6-9-4-1-1-优点" class="headerlink" title="6.9.4.1.1. 优点"></a>6.9.4.1.1. 优点</h5><p>关于访问者模式的优点，这里我总结了三点。</p>
<ol>
<li>扩展性好。在不修改对象结构中的元素的情况下，可以为对象结构中的元素添加新的功能。以上述案例来说，如果后期我们想在对对象结构中的元素进行访问时执行其他的操作，例如将上述案例中的喂食宠物给改成遛宠物，那么我们只需要再去定义一个Person接口的子实现类即可。当然了，上述案例中Person接口里面的方法命名并不是特别规范，因为通过方法的名字（即feed）我们就明白了它就是喂食的意思，所以，Person接口里面的方法我们可以命名得更通用一些！</li>
<li>复用性好。通过访问者来定义整个对象结构通用的功能，从而提高复用程度。还是看一下上述案例，Home类里面是不是提供了一个action方法啊，该方法就可以对集合里面的元素进行一些通用的操作，而且我们还是把这些通用的操作全部都封装到了具体访问者类里面，就是喂食宠物嘛！这样，就大大减少了Home类里面代码的一个书写。</li>
<li>分离无关行为。通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。例如，我现在既可以创建一个子类，让该子类来喂食宠物，也可以再创建一个子类，让该子类来遛宠物。</li>
</ol>
<h5 id="6-9-4-1-2-缺点"><a href="#6-9-4-1-2-缺点" class="headerlink" title="6.9.4.1.2. 缺点"></a>6.9.4.1.2. 缺点</h5><p>关于访问者模式的缺点，这里我总结了两点。</p>
<ol>
<li>对象结构变化很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了”开闭原则”。上面这句话啥意思啊？还是拿上述案例来说，假设现在我们又创建了一个Animal接口的子实现类，那么我们是不是又得在抽象访问者接口中再定义一个方法啊！并且该方法是用来操作新创建的具体元素类的对象的。这还不够，对于具体访问者类而言，它们还得实现新定义的方法。现在，你明白了对象结构变化很困难这句话的意思了吧！</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。还是回到我们上述案例来看一下，对于具体访问者类来说，它们的方法都是依赖的是具体而不是抽象，于是，这就违反了依赖倒转原则。</li>
</ol>
<h4 id="6-9-4-2-使用场景"><a href="#6-9-4-2-使用场景" class="headerlink" title="6.9.4.2. 使用场景"></a>6.9.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用访问者模式了。</p>
<ul>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>
</ul>
<hr>
<h3 id="6-9-5-分派"><a href="#6-9-5-分派" class="headerlink" title="6.9.5. 分派"></a>6.9.5. 分派</h3><p><strong>扩展</strong></p>
<p>接下来，我们来对访问者模式进行一个扩展，扩展一个叫<strong>双分派</strong>的技术，因为在访问者模式里面就用到了。</p>
<p>既然要扩展双分派的技术，那么我们就得先知道什么是分派。下面，我们来看一看它的定义。</p>
<p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。例如，从下面这行代码中我们就能知道，map变量的静态类型是Map，实际类型是HashMap。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br></pre></td></tr></tbody></table></figure>

<p>根据对象的类型而对方法进行的选择（这时我们就要进行选择了，选择执行的是静态类型中的方法，还是实际类型中的方法呢？），就是分派（Dispatch），分派（Dispatch）又分为两种，即静态分派和动态分派。</p>
<p>接下来，我们来看一下什么是静态分派，什么又是动态分派。</p>
<ul>
<li><p><strong>静态分派（Static Dispatch）</strong> 发生在编译时期，分派根据静态类型信息发生。</p>
</li>
<li><ul>
<li>方法重载就是静态分派。</li>
</ul>
</li>
<li><p><strong>动态分派（Dynamic Dispatch）</strong> 发生在运行时期，动态分派动态地置换掉某个方法。</p>
</li>
<li><ul>
<li>Java可以通过方法的重写来支持动态分派。</li>
</ul>
</li>
</ul>
<p>下面我们通过具体的代码来分别演示一下静态分派和动态分派。</p>
<h4 id="6-9-5-1-动态分派-多态"><a href="#6-9-5-1-动态分派-多态" class="headerlink" title="6.9.5.1. 动态分派(多态)"></a>6.9.5.1. 动态分派(多态)</h4><p>在Java中，我们可以通过方法的重写来支持动态分派。</p>
<p>这里我们先创建一个Animal类，该类比较简单，里面只有一个execute方法，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Animal"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建Animal类的两个子类，一个是Dog类，注意，该类重写了父类中的execute方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Dog"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个是Cat类，注意，该类也重写了父类中的execute方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Cat"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个测试类，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">// 由于a变量的实际类型是Dog，所以调用其execute方法时，执行的是子类（即Dog）里面的execute方法</span></span><br><span class="line">        a.execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// 由于a1变量的实际类型是Cat，所以调用其execute方法时，执行的是子类（即Cat）里面的execute方法</span></span><br><span class="line">        a1.execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码的结果大家应该可以直接说出来，这不就是多态吗？遵循编译看左边，运行看右边的原则，可知最终执行的是子类中的方法。</p>
<p>这里我给大家总结一下：<strong>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型（或者实际类型）；而方法的调用则是根据对象的真实类型（或者实际类型），而不是静态类型</strong>。</p>
<h4 id="6-9-5-2-静态分派-重载"><a href="#6-9-5-2-静态分派-重载" class="headerlink" title="6.9.5.2. 静态分派(重载)*"></a>6.9.5.2. 静态分派(重载)*</h4><p>在Java中，我们可以通过方法重载来支持静态分派。</p>
<p>同上，这里我们先创建一个Animal类，该类里面啥都没有，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建Animal类的两个子类，一个是Dog类，注意，该类里面没有具体的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个是Cat类，注意，该类里面也没有具体的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建一个Execute类，该类里面有三个重载的execute方法，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Animal"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Dog"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Cat"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个测试类，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        exe.execute(a);   <span class="comment">//Animal</span></span><br><span class="line">        exe.execute(a1);  <span class="comment">//Animal</span></span><br><span class="line">        exe.execute(a2);  <span class="comment">//Animal</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上测试类的代码，打印结果如下图所示，可以看到打印的都是Animal。</p>
<p><img src="/./assets/1709706785717-b2e5ef31-55cb-4c45-946c-2f813a5d103d.png" alt="img"></p>
<p>这个结果可能会出乎一些人的意料，为什么会这样呢？因为<strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了</strong>。</p>
<p>知道静态分派和动态分派之后，接下来我们就得看一看双分派了，这个才是我们要讲的重点。</p>
<h4 id="6-9-5-3-双分派-实现动态重载"><a href="#6-9-5-3-双分派-实现动态重载" class="headerlink" title="6.9.5.3. 双分派(实现动态重载)*"></a>6.9.5.3. 双分派(实现动态重载)*</h4><p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p>
<p>相信大家看完上面这句话之后，都懵了，这说的啥意思啊？没关系，下面我会通过一个例子来向大家解释一番。</p>
<p>同上，这里我们先创建一个Animal类，该类里面只有一个accept方法，而且该方法需要一个Execute类型的参数，至于Execute类，后面你就会看到。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> {</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建Animal类的两个子类，一个是Dog类，注意，虽然该类重写了父类中的accept方法，但是它和父类中的accept方法是一模一样的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 11:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> {</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个是Cat类，同理，虽然该类也重写了父类中的accept方法，但是它和父类中的accept方法也是一模一样的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 11:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> {</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其实，Dog和Cat这俩子类中的accept方法我们可以不写，不写的话，就是重用父类中的accept方法了，效果都是一样的。当然，我们在这里都给写出来了，因为这样的话，大家更好理解一些。</p>
<p>接着，创建Execute类，该类里面有三个重载的execute方法，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 11:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Animal"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Dog"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Cat"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们来创建一个测试类，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.visitor.demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-07 11:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        a.accept(exe);   <span class="comment">//Animal</span></span><br><span class="line">        d.accept(exe);   <span class="comment">//Dog</span></span><br><span class="line">        c.accept(exe);   <span class="comment">//Cat</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面代码中，客户端将Execute对象作为参数传递给了Animal类型的变量调用的方法，这里完成了第一次分派，由于这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，拿c变量来举例，c.accept(exe)是把Execute对象作为参数传递给了accept方法，那么此时程序执行的便是Cat类里面的accept方法。</p>
<p>同时，也将自己this作为参数传递了进去，这里就完成了第二次分派。什么意思呢？还是拿c变量来说，c.accept(exe)本质上执行的还是Cat类里面的accept方法，而Cat类里面的accept方法是像下面这样实现的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> {</span><br><span class="line">    exe.execute(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，会<strong>通过传递进来的Execute对象来调用execute方法，并且把<strong><strong>this</strong></strong>作为参数进行传递，而这儿的<strong><strong>this</strong></strong>就表示<strong><strong>谁调用我，我就代表谁</strong></strong>，显然，此时的<strong><strong>this</strong></strong>表示的就是Cat对象。</strong></p>
<p>问题来了，这里的Execute类中有多个重载的execute方法，那么此时执行的是这三个重载的execute方法中的哪一个方法呢？要知道现在传递进execute方法的是this，也就是具体的实际类型（即Cat类型）的对象，所以想必大家都明白了，此时必然执行的是带有Cat类型参数的execute方法。</p>
<p>说到这里，相信大家已经明白双分派是怎么回事了，不就是经过了两次分派嘛！如果你还是不明白的话，那么你可以根据我上面的描述以及上例中的代码再去理解一下双分派。当然了，你会发现上例中的代码异常熟悉，这是因为上述我们使用访问者模式实现的案例里面的代码也有异曲同工之处，所以我们才说访问者模式里面用到了双分派技术。</p>
<p>这里我们不妨运行一下以上测试类中的代码，可以看到打印结果如下图所示。</p>
<p><img src="/./assets/1709706785731-20b26496-3167-46ae-ab6c-8af190811bf3.png" alt="img"></p>
<p>既然大家已经对双分派有了一定的认识了，那么它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p>
<p>最后，我给大家总结一下：<strong>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了</strong>。</p>
<p>所以这里大家要知道，正是由于有了双分派，所以我们此处的方法重载体现出来的就是动态分派的这种效果。</p>
<hr>
<hr>
<h2 id="6-10-备忘录模式"><a href="#6-10-备忘录模式" class="headerlink" title="6.10. 备忘录模式"></a>6.10. 备忘录模式</h2><h3 id="6-10-1-概述"><a href="#6-10-1-概述" class="headerlink" title="6.10.1. 概述"></a>6.10.1. 概述</h3><p>在学习备忘录模式的概念之前，我们先来看下面这段描述。</p>
<p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题，或者就想回到之前的历史步骤时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如Word、记事本、PhotoShop、IDEA等软件在编辑时按Ctrl+Z组合键时就能撤销当前操作，使文档恢复到之前的状态；还有在浏览器中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这种状态恢复的实现机制，而这种状态恢复的实现机制正是备忘录模式提供的。</p>
<p>接下来，我们就可以看一下备忘录模式的概念了。</p>
<p>备忘录模式又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<p>知道了备忘录模式的概念之后，接下来，我们就来看看备忘录模式的结构，也就是它里面所拥有的角色。</p>
<h3 id="6-10-2-结构"><a href="#6-10-2-结构" class="headerlink" title="6.10.2. 结构"></a>6.10.2. 结构</h3><p>备忘录模式的主要角色如下：</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能（注意，这俩功能是必须提供的），实现其他业务功能（当然了，有的话你就实现，没有的话你就可以不实现了），它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<p>知晓备忘录模式里面的角色之后，大家一定要明白一点，就是管理者角色是不能对备忘录里面的内容进行访问或者修改的。那如何来保证这一点呢？要想知道答案，那么接下来我们就得先认识一下备忘录里面的两个等效的接口了。</p>
<p>备忘录有两个等效的接口，它们分别是：</p>
<ul>
<li><strong>窄接口</strong>：管理者（Caretaker）对象（和其他发起人对象之外的任何对象）看到的都是备忘录的窄接口（narror Interface），这个窄接口只允许他把备忘录对象传给其他的对象。现在大家应该知道什么是窄接口了吧！窄接口就是只能允许管理者对象去获取备忘录对象，而不允许他对备忘录里面的数据进行访问或者修改。</li>
<li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口（wide Interface），这个宽接口允许他读取所有的数据（也即允许发起人对象读取备忘录里面的所有数据，或者对备忘录里面的数据进行修改），以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
<h3 id="6-10-3-案例实现"><a href="#6-10-3-案例实现" class="headerlink" title="6.10.3. 案例实现"></a>6.10.3. 案例实现</h3><p>接下来，按照惯例我们通过一个案例来让大家再去理解一下备忘录模式的概念，以及它里面所包含的角色，而这个案例就是在游戏中挑战Boss。</p>
<p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，于是我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p>
<p>看到让游戏恢复到决斗之前的状态，那么想必你已经知道了肯定是要用到备忘录模式的。而这里我们要实现上述案例，是可以有两种方式的：</p>
<ol>
<li>白箱备忘录模式</li>
<li>黑箱备忘录模式</li>
</ol>
<p>那什么是白箱备忘录模式？什么又是黑箱备忘录模式呢？接下来我一个一个来为大家讲述，这里不妨先来看看白箱备忘录模式。</p>
<h4 id="6-10-3-1-白箱备忘录模式"><a href="#6-10-3-1-白箱备忘录模式" class="headerlink" title="6.10.3.1. 白箱备忘录模式"></a>6.10.3.1. 白箱备忘录模式</h4><h5 id="6-10-3-1-1-概述"><a href="#6-10-3-1-1-概述" class="headerlink" title="6.10.3.1.1. 概述"></a>6.10.3.1.1. 概述</h5><p>备忘录角色对任何对象都提供一个接口，即宽接口，这样的话，备忘录角色的内部所存储的状态就对所有对象公开。</p>
<p>看到这里，大家应该明白一点，就是这好像违背了备忘录模式的意思，因为刚才我们就讲过窄接口和宽接口，而备忘录模式只会对发起人对象提供一个宽接口，对其他的对象则全部提供一个窄接口。有意思的是这恰巧描述的是黑箱备忘录模式，别急，后面我就会讲到。</p>
<h5 id="6-10-3-1-2-案例"><a href="#6-10-3-1-2-案例" class="headerlink" title="6.10.3.1.2. 案例"></a>6.10.3.1.2. 案例</h5><p>我们先来看一下下面的这张类图，这张类图就是针对于上述案例进行设计的。</p>
<p><img src="/./assets/1709706935115-5fd2a2af-85b2-488c-a131-efbb6632b84d.png" alt="img"></p>
<p>可以看到，以上类图中包含有四个类，当然还有一个客户端类了，只是我们不用过多地去关注于它。下面我就来为大家逐一分析一下每一个类。</p>
<p>先来看一下GameRole类，翻译过来就是游戏角色类，该类里面有三个成员变量，分别代表着生命力、攻击力和防御力。除此之外，该类还提供了这样几个成员方法：</p>
<ol>
<li>void initState()：给游戏角色赋予初始化状态。</li>
<li>void fight()：对外展示攻击。</li>
<li>RoleStateMemento saveState()：保存游戏角色内部状态的数据。</li>
<li>void recoverState(RoleStateMemento roleStateMemento)：恢复游戏角色内部状态的数据。</li>
</ol>
<p>很显然，该游戏角色类充当的就是备忘录模式里面的发起人角色。</p>
<p>然后，我们来看一下RoleStateMemento类，可以看到该类里面同样也声明了三个成员变量，依旧分别代表着生命力、攻击力和防御力，想必大家也看到了这和发起人角色内部是一摸一样的，为什么会这样呢？这是因为该类充当的正是备忘录模式里面的备忘录角色，而它是要负责存储发起人的内部状态的，也就是做一个备忘的操作。</p>
<p>当然了，在RoleStateMemento类里面，我们还提供了构造方法以及对应的getter和setter方法，只不过getter和setter方法在这里我没有列出来而已。</p>
<p>接着，我们来看一下RoleStateCaretaker类，很显然，该类充当的是备忘录模式里面的管理者角色。可以看到，该类里面声明了一个RoleStateMemento类型的成员变量，通过该成员变量我们就能对备忘录对象进行管理了。当然了，针对该成员变量，我们还提供了相应的getter和setter方法，因为作为一个管理者，总要有一个方法去存储备忘录对象，以及一个方法去获取备忘录对象。</p>
<p>至此，以上类图我们就分析完了，接下来我们就要编写代码来实现以上在游戏中挑战Boss的案例了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即memento.white_box，也即使用白箱备忘录模式实现以上案例的具体代码我们是放在了该包下。</p>
<p>然后，创建游戏角色类，这里我们就命名为GameRole了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.white_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 游戏角色类（属于发起人角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 19:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">// 生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">// 攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">// 防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存游戏角色的内部状态</span></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">saveState</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 这儿我们只须创建一个备忘录对象，将游戏角色的内部状态进行一个存储即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复游戏角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(RoleStateMemento roleStateMemento)</span> {</span><br><span class="line">        <span class="comment">// 将备忘录对象中存储的状态赋值给当前对象的成员</span></span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了等会让大家看到效果，这里我们再提供一个方法，该方法就是用于展示游戏角色内部状态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"角色生命力："</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">"角色攻击力："</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">"角色防御力："</span> + def);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> {</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> {</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为以上游戏角色类中要用到备忘录类，所以这里我们再来创建备忘录类，名字就叫RoleStateMemento。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.white_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 19:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">// 生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">// 攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">// 防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> {</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> {</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建角色状态管理者类，这里我们就命名为RoleStateCaretaker了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.white_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录对象管理角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个RoleStateMemento类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento roleStateMemento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">getRoleStateMemento</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> roleStateMemento;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoleStateMemento</span><span class="params">(RoleStateMemento roleStateMemento)</span> {</span><br><span class="line">        <span class="built_in">this</span>.roleStateMemento = roleStateMemento;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.white_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------------------大战Boss前-------------------------"</span>);</span><br><span class="line">        <span class="comment">// 创建游戏角色对象</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState(); <span class="comment">// 初始化状态操作</span></span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将该游戏角色内部状态进行一个备份</span></span><br><span class="line">        <span class="comment">// 创建管理者对象</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------大战Boss后-------------------------"</span>);</span><br><span class="line">        <span class="comment">// 损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------恢复之前的状态-------------------------"</span>);</span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类的代码，打印结果如下图所示，可以看到确实是我们所想要的结果。</p>
<p><img src="/./assets/1709706935094-2295f0ed-20f1-46b8-b149-bb8e79857d23.png" alt="img"></p>
<p>以上就是我们使用白箱备忘录模式来实现了一个在游戏中挑战Boss的案例。为什么说是使用白箱备忘录模式呢？这是因为在咱们编写的角色状态管理者类里面，我们是可以对备忘录里面的数据进行访问的，就像下面这样，只是这里我们并没有这样做而已。</p>
<p><img src="/./assets/1709706935133-fdf259ca-0b59-40e1-8409-7be856a0f15c.png" alt="img"></p>
<p>而且，在客户端我们依旧可以在获取到备忘录对象之后，对它里面的数据进行访问。</p>
<p><img src="/./assets/1709706935150-53b8ecff-4e7a-4aa7-a631-f6d5baeac554.png" alt="img"></p>
<p>从上可以看到，虽然我们使用白箱备忘录模式实现了在游戏中挑战Boss的案例，但是白箱备忘录模式给我们带来了一个问题，就是它破坏了封装性。不过，在实际开发中，可以通过程序员的自律在一定程度上实现模式的大部分用意。也就是说，程序员他自个约束自个只在发起人对象里面对备忘录对象里面的属性进行一个访问，而在其他对象里面不进行访问。</p>
<p>但是，不知你有没有想过一点，就是程序员写的程序是要给其他人使用的，这样，别人就有可能在其他对象里面去访问备忘录里面的数据了，是不是啊😱！</p>
<p>那如何来改进呢？嘻嘻，那就要使用到黑箱备忘录模式了，所以接下来我就得向大家介绍一番黑箱备忘录模式了。</p>
<h4 id="6-10-3-2-黑箱备忘录模式"><a href="#6-10-3-2-黑箱备忘录模式" class="headerlink" title="6.10.3.2. 黑箱备忘录模式"></a>6.10.3.2. 黑箱备忘录模式</h4><h5 id="6-10-3-2-1-概述"><a href="#6-10-3-2-1-概述" class="headerlink" title="6.10.3.2.1. 概述"></a>6.10.3.2.1. 概述</h5><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p>
<h5 id="6-10-3-2-2-案例"><a href="#6-10-3-2-2-案例" class="headerlink" title="6.10.3.2.2. 案例"></a>6.10.3.2.2. 案例</h5><p>知道黑箱备忘录模式的概念之后，大家知不知道应该如何使用黑箱备忘录模式来改进上述案例呢？想必是不知道的，看来还得我来为大家讲解一番。</p>
<p>根据黑箱备忘录模式的概念，我想大家应该知道一点，就是要将RoleStateMemento设为GameRole的私有成员内部类，从而将RoleStateMemento对象封装在GameRole里面，这样，外界就不能直接去访问了。</p>
<p>这样做还不够，我们还得在外界提供一个Memento接口，而且该接口只是一个标识接口，里面没有任何方法，提供该接口的目的就是为了让外界（例如RoleStateCaretaker及其他对象）去访问，这里，大家还应该知道，RoleStateMemento类得要去实现该标识接口。这样，GameRole类看到的便是RoleStateMemento类的所有接口（从发起人对象角度来看，标识接口Memento就是一个宽接口，而这也正对应着备忘录角色对发起人对象提供的是一个宽接口这句话），而RoleStateCaretaker及其他对象看到的仅仅是标识接口Memento所暴露出来的接口（从外界来看，标识接口Memento就是一个窄接口，这也恰好对应着备忘录角色为其他对象提供的是一个窄接口这句话），从而维护了封装型。</p>
<p>接下来，我们就来看一下下面的这张类图，这张类图就是通过上面的分析设计出来的。</p>
<p><img src="/./assets/1709988781290-25e4ac33-61d1-4712-8232-922b8a4d225a.png" alt="img"></p>
<p>可以看到，游戏角色类（即GameRole）里面成员基本上都没有变，只是保存/恢复游戏角色内部状态的俩方法使用的都是Memento接口类型，因为这俩方法是要提供给外界使用的，当外界在使用时，看到的便只能是Memento接口类型的对象，而再也不能看到真正的子实现类到底是谁了。</p>
<p>然后，我们来看一下Memento接口，可以看到该接口里面并没有任何方法，这就表明着它就是一个标识接口，我们正是通过该标识接口实现了备忘录角色为其他对象提供一个窄接口的这一目的。</p>
<p>接着，我们来看一下备忘录类啊！该类设计得很巧妙，因为它是声明在了GameRole这个类的内部，而且它还实现了Memento接口。当然了，该类里面的成员也是基本上没有变的，这里我就不再细说了。</p>
<p>最后，我们来看一下角色状态管理者类，注意了，该类现在依赖的可就是Memento接口类型的对象了，因为它是不能看到真正的子实现类到底是谁的。</p>
<p>至此，以上类图我们就分析完了，接下来我们就要使用黑箱备忘录模式来改进以上在游戏中挑战Boss的案例了。</p>
<p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即memento.black_box，也即使用黑箱备忘录模式改进以上案例的具体代码我们是放在了该包下。</p>
<p>然后，创建窄接口Memento，由于这是一个标识接口，因此我们没有定义出任何的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.black_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录接口，也即对外提供的窄接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 23:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memento</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建游戏角色类，这里我们同样命名为GameRole。注意了，我们还得在该类内部定义备忘录内部类，同样取名为RoleStateMemento，显然，该内部类应该设置为私有的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.black_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 游戏角色类（属于发起人角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 19:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">// 生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">// 攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">// 防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存游戏角色的内部状态</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">saveState</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 这儿我们只须创建一个备忘录对象，将游戏角色的内部状态进行一个存储即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复游戏角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(Memento memento)</span> {</span><br><span class="line">        <span class="type">RoleStateMemento</span> <span class="variable">roleStateMemento</span> <span class="operator">=</span> (RoleStateMemento) memento;</span><br><span class="line">        <span class="comment">// 将备忘录对象中存储的状态赋值给当前对象的成员</span></span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了等会让大家看到效果，这里我们再提供一个方法，该方法就是用于展示游戏角色内部状态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"角色生命力："</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">"角色攻击力："</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">"角色防御力："</span> + def);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> {</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> {</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> {</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里一定要注意，备忘录类必须实现Memento接口，</span></span><br><span class="line">    <span class="comment">//如果不实现Memento接口的话，那么外界就无法去操作备忘录类的对象了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> <span class="keyword">implements</span> <span class="title class_">Memento</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">// 生命力</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">// 攻击力</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">// 防御力</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> {</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> vit;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> {</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> atk;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> {</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> def;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> {</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建角色状态管理者类，这里我们同样命名为RoleStateCaretaker。这里，大家要知道的一点是，<strong>该类能够得到的备忘录对象是<strong><strong>Memento</strong></strong>接口类型的，由于这个接口仅仅是一个标识接口，因此管理者角色是不可能改变这个备忘录对象中的内容的</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.black_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录对象管理角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个Memento接口类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> {</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.memento.black_box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-18 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------------------大战Boss前-------------------------"</span>);</span><br><span class="line">        <span class="comment">// 创建游戏角色对象</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState(); <span class="comment">// 初始化状态操作</span></span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该游戏角色内部状态进行一个备份</span></span><br><span class="line">        <span class="comment">// 创建管理者对象</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setMemento(gameRole.saveState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------大战Boss后-------------------------"</span>);</span><br><span class="line">        <span class="comment">// 损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------恢复之前的状态-------------------------"</span>);</span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类的代码，打印结果如下图所示，可以看到确实是我们所想要的结果，并且和之前的结果是一模一样的。</p>
<p><img src="/./assets/1709706935889-a6afa193-a1c3-4ba8-b777-1e05be720db8.png" alt="img"></p>
<p>现在，大家来思考一下，我们还能在咱们编写的角色状态管理者类里面对备忘录里面的数据进行访问吗？那必须是不可以的了，你试一下便知道了，结果必然是像下图这样。</p>
<p><img src="/./assets/1709706936074-2a238a9b-9b59-4519-9489-4f884205bcf7.png" alt="img"></p>
<p>为什么会这样啊？这是因为对于角色状态管理者类来说，它现在聚合的是Memento接口类型的对象，这样，它就看不到真正的子实现类到底是谁了，更何论子实现类里面到底有哪些成员呢！</p>
<p>至此，我们就使用黑箱备忘录模式改进完以上在游戏中挑战Boss的案例了。这里，我再跟大家说一下，<strong>使用黑箱备忘录模式的核心就是要把备忘录角色类定义在发起人角色类的内部，并且将其私有，私有的话，外界就不能去访问了</strong>！</p>
<hr>
<h3 id="6-10-4-备忘录模式的优缺点以及使用场景"><a href="#6-10-4-备忘录模式的优缺点以及使用场景" class="headerlink" title="6.10.4. 备忘录模式的优缺点以及使用场景"></a>6.10.4. 备忘录模式的优缺点以及使用场景</h3><p>接下来，我们就来看一下备忘录模式的优缺点以及使用场景。</p>
<h4 id="6-10-4-1-优缺点"><a href="#6-10-4-1-优缺点" class="headerlink" title="6.10.4.1. 优缺点"></a>6.10.4.1. 优缺点</h4><h5 id="6-10-4-1-1-优点"><a href="#6-10-4-1-1-优点" class="headerlink" title="6.10.4.1.1. 优点"></a>6.10.4.1.1. 优点</h5><p>关于备忘录模式的优点，我总结出来了下面三点。</p>
<ol>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。这里，我就要说一嘴了，对于我们上述案例来说，它是只能恢复到一个历史状态的。为什么呢？这是因为在角色状态管理者类中，我们只声明了一个Memento接口类型的成员变量用来存储一个备忘录对象。其实，我们是可以声明一个单列集合或者双列集合来存储多个备忘录对象的，不过建议使用双列集合。这样，我们就可以在双列集合里面去记录每一个历史版本的备忘录对象了，至于标识（也就是键）的话，你可以以时间点或者其他的某种方式来做标识。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。当然，这点只是针对黑箱备忘录模式来说的。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ol>
<h5 id="6-10-4-1-2-缺点"><a href="#6-10-4-1-2-缺点" class="headerlink" title="6.10.4.1.2. 缺点"></a>6.10.4.1.2. 缺点</h5><p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，那么将会占用比较大的内存资源。</p>
<h4 id="6-10-4-2-使用场景"><a href="#6-10-4-2-使用场景" class="headerlink" title="6.10.4.2. 使用场景"></a>6.10.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用备忘录模式了。</p>
<ul>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>
<li>需要提供一个可回滚操作的场景，如Word、记事本、PhotoShop、IDEA等软件在编辑时按Ctrl+Z组合键，还有数据库中事务的操作（例如事务的回滚）。</li>
</ul>
<hr>
<hr>
<h2 id="6-11-解释器模式"><a href="#6-11-解释器模式" class="headerlink" title="6.11. 解释器模式"></a>6.11. 解释器模式</h2><h3 id="6-11-1-概述"><a href="#6-11-1-概述" class="headerlink" title="6.11.1. 概述"></a>6.11.1. 概述</h3><p>在学习解释器模式之前，我们先来看下下面这张图。</p>
<p><img src="/./assets/1709707034643-2fb61b15-5e62-43b0-baf1-9fef5375e8b5.png" alt="img"></p>
<p>可以看到，这就是一个计算器，大家平时用的应该也是比较多的，当我们输入了1+2+3+4-5之后，它就会给我们出一个结果5。现在我们想要设计一个软件，类似于这样的一个计算器，用来进行加减计算。</p>
<p>各位来思考一下，我们应该如何来设计这样一个软件呢？可能大家的第一想法就是写个工具类不就得了，然后在该工具类中提供对应的加法和减法的工具方法，就像下面这段代码一样。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于两个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于三个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>{</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于n个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Integer ... arr)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : arr) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，上面代码中减法我们还没有提供出来。</p>
<p>不知你注意到了没有，上面的形式是比较单一、有限的，如果形式变化非常多，那么这就不符合要求了，因为加法和减法运算，两个运算符与数值可以有无限种组合方式，比如1+2+3+4+5、1+2+3-4等等，这样，我们再去设计像上面那样的一个工具类就不是特别合适了。而现在我们想实现的就是当我们输入了1+2+3+4-5这样一个语法之后，就能计算出一个正确的结果。</p>
<p>明白解释器模式的思维之后，接下来我们来看一下其概念。</p>
<p>给定一个语言（也就是说让我们自己定义一个语言），定义它的文法表示（即该语言的组成规则），并定义一个解释器，这个解释器会使用该语言的文法规则表示来解释语言中的句子。</p>
<p>注意，定义解释器是最关键的，解释器的作用就是根据给定语言的文法规则表示来解释语言中的句子，最终达到我们想要的结果。对于加减法运算来说，我们最重要的是要得到语句里面描述的最终的运算结果。</p>
<p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种”语言”。比如加减法运算，它的规则为：由数值和+、-符号组成的合法序列，例如1+3-2就是这种语言的句子。</p>
<p>解释器就是要解析出来语句的含义。但是问题来了，我们如何来描述语句组成的规则呢？要想知道该问题的答案，那么你就不得不来认识一下下面要讲述的文法（语法）规则了。</p>
<h4 id="6-11-1-1-文法规则"><a href="#6-11-1-1-文法规则" class="headerlink" title="6.11.1.1. 文法规则"></a>6.11.1.1. 文法规则</h4><p><strong>文法（语法）规则</strong>是用于描述语言的语法结构的形式规则。例如，这儿就有一个文法表达式。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression ::= value | plus | minus</span><br><span class="line">plus ::= expression <span class="string">'+'</span> expression   </span><br><span class="line">minus ::= expression <span class="string">'-'</span> expression  </span><br><span class="line">value ::= integer</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，这里面有很多符号，对于这些符号我们得先来说明一下。</p>
<ul>
<li>::=：表示”定义为”的意思。</li>
<li>|：表示或，也就是竖线两边选一个就可以了。</li>
<li>‘’：引号内为字符本身，引号外为语法。</li>
</ul>
<p>明白上述这些符号的意思之后，那么我们就能知道上述文法规则描述的是什么意思了。看一下，是不是下面这个意思啊？</p>
<p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成的，至于值，只要它是一个整型数就可以了。</p>
<p>很明显，上述我们定义的文法（语法）规则只针对于加减法运算的语句，例如1+2、2-1等等。</p>
<h4 id="6-11-1-2-抽象语法树"><a href="#6-11-1-2-抽象语法树" class="headerlink" title="6.11.1.2. 抽象语法树"></a>6.11.1.2. 抽象语法树</h4><p>简单了解了一下文法（语法）规则之后，接下来还有一个概念我得给大家说一下，那就是<strong>抽象语法树</strong>。</p>
<p>什么是抽象语法树呢？看下面的概念。</p>
<p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>我们不妨来看一下下面这种树形结构啊！</p>
<p><img src="/./assets/1709707034622-fea65b5d-201b-45b3-9c72-b3cd092e8e2b.png" alt="img"></p>
<p>很明显，这就是一棵抽象语法树。对于这一棵语法树而言，我们应该从左边往右边去看，它的含义我不说，想必大家应该已经很清楚了，无非就是1+2的结果再去加3，然后加3的结果再去加4，最后加4的结果再去减5，很容易理解。</p>
<p>可以看到，解释器模式这一块的概念还是比较多的，有很多概念是需要大家好好去理解的。</p>
<p>对解释器模式这一块的概念有了一定了解之后，接下来，我们就来看看解释器模式的结构，也就是它里面所拥有的角色。</p>
<h3 id="6-11-2-结构"><a href="#6-11-2-结构" class="headerlink" title="6.11.2. 结构"></a>6.11.2. 结构</h3><p>解释器模式包含以下主要角色：</p>
<ul>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法，即interpret方法。</li>
<li>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。看到这儿，很多人可能都懵逼了，What’up，什么是终结符表达式啊？这里我就要给大家解释解释了。大家不妨再看一下上述我们定义的文法规则，如下所示，这里我就给大家复制过来了哟，够贴心吧😊！</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression ::= value | plus | minus</span><br><span class="line">plus ::= expression '+' expression   </span><br><span class="line">minus ::= expression '-' expression  </span><br><span class="line">value ::= integer</span><br></pre></td></tr></tbody></table></figure>

<p>在上面定义的文法规则中，value就属于终结符表达式。至于plus或者minus，它们里面又包含了表达式，而表达式又有可能是plus或者minus，但是如果表达式是value（即具体的整形的数据）的话，那么整个表达式就结束了，所以我们才说value属于终结符表达式。</p>
<ul>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。很明显，上述我们定义的文法规则中，plus或者minus就属于非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。也就是说，环境角色可以对给定文法里面牵扯到的那些表达式数据进行一个存储。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法，最终获得我们所想要的结果。</li>
</ul>
<h3 id="6-11-3-解释器模式案例"><a href="#6-11-3-解释器模式案例" class="headerlink" title="6.11.3. 解释器模式案例"></a>6.11.3. 解释器模式案例</h3><p>接下来，按照惯例我们通过一个案例来让大家再去理解一下解释器模式的概念，以及它里面所包含的角色，而这个案例就是设计一个实现加减法的软件。</p>
<h4 id="6-11-3-1-分析"><a href="#6-11-3-1-分析" class="headerlink" title="6.11.3.1. 分析"></a>6.11.3.1. 分析</h4><p>我们先来看下该软件的设计类图。</p>
<p><img src="/./assets/1709998706862-fac463d5-348f-41a4-a016-a1addcf2144d.png" alt="img">首先，我们来看一下类图里面的AbstractExpression类，它充当的是解释器模式中的抽象表达式角色，在该类里面我们定义了一个interpret方法，该方法就是用来解释表达式的，而且该方法需要依赖Context类，至于Context类，我们等会就会说到。</p>
<p>从以上类图中可以看到，该抽象表达式类有好几个子类，它们分别是：</p>
<ul>
<li><p>Variable类：该类是用于对变量进行封装的，它里面有一个name属性，表示的就是变量的名称。此外，我们还在该类里面定义如下几个方法：</p>
</li>
<li><ul>
<li>有参构造：用于给变量起名字的。</li>
<li>interpret方法：该方法是重写父类中的interpret方法。</li>
<li>toString方法：该方法只是为了我们在后期验证测试的时候想看到更好的效果而定义的。</li>
</ul>
</li>
<li><p>Value类：该类是用于对具体的值进行封装的。注意，在该案例中，我们并没有用到该类，只是在类图里面将其表示出来了而已。</p>
</li>
<li><p>Plus类：该类是用于对加法表达式进行封装的，它里面定义有两个AbstractExpression类型的成员变量，名字分别叫left和right，表示的就是加号左右两边的表达式，很明显，这俩成员变量将AbstractExpression类的对象聚合进来了。此外，我们还在该类里面定义如下几个方法：</p>
</li>
<li><ul>
<li>有参构造：用于设置加号左右两边的表达式的。</li>
<li>interpret方法：该方法是重写父类中的interpret方法。</li>
<li>toString方法：该方法只是为了我们在后期验证测试的时候想看到更好的效果而定义的。</li>
</ul>
</li>
<li><p>Minus类：该类是用于对减法表达式进行封装的。该类同以上Plus类基本类似，所以在这里我就不再详细赘述了。</p>
</li>
</ul>
<p>反正不管怎么着，Plus和Minus这俩类既继承自抽象表达式类，同时又聚合进来了抽象表达式类的对象，所以大家要把这一块的复杂关系给理清楚。</p>
<p>最后，我们再来看一个类，那就是Context类，很明显，该类充当的是解释器模式中的环境角色。从上可以看到，该类里面定义了一个Map集合，Map集合里面存储的就是变量以及变量对应的值。此外，我们还在该类里面定义了两个方法，一个是assign，该方法是用来向Map集合里面添加变量及其对应的值的；一个是getValue，该方法就是根据变量来获取变量对应的值的。</p>
<p>至此，以上类图我们就分析完了，接下来我们就要编写代码来实现以上案例了。</p>
<h4 id="6-11-3-2-实现"><a href="#6-11-3-2-实现" class="headerlink" title="6.11.3.2. 实现"></a>6.11.3.2. 实现</h4><p>首先，打开咱们的maven工程，并在com.meimeixia.pattern包下新建一个子包，即interpreter，也即实现以上案例的具体代码我们是放在了该包下。</p>
<p>然后，创建抽象表达式类，这里我们就命名为AbstractExpression了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象表达式类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-19 12:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExpression</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为什么该抽象方法的返回值类型是int呢？因为在该案例里面我们只考虑对int类型的数据进行加减法运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，创建以上抽象表达式类的子类。这里，我们先创建第一个子类，即用于封装变量的类，名字就取为Variable。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装变量的类（属于终结符表达式角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-19 12:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个存储变量名的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Variable</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> {</span><br><span class="line">        <span class="comment">// 直接返回变量的值。问题是变量的值在哪存储呢？既然在本类中没有存储，那么肯定就是存储在Context类里面了！</span></span><br><span class="line">        <span class="keyword">return</span> context.getValue(<span class="built_in">this</span>); <span class="comment">// 注意，调用getValue方法时，需要向其传递一个Variable类型的对象，而当前类的对象就是这样一个对象，所以这里传递this即可</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 返回变量的名称就好</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建第二个子类，即用于封装加法表达式的类，名字就取为Plus。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装加法表达式的类（属于非终结符表达式角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-19 12:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plus</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +号左边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="comment">// +号右边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Plus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> {</span><br><span class="line">        <span class="comment">// 将左边表达式的结果和右边表达式的结果进行相加</span></span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 无非就是返回加号左边表达式的字符串表示形式+加号右边表达式的字符串表示形式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + left.toString() + <span class="string">" + "</span> + right.toString() + <span class="string">")"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再再创建第三个子类，即用于封装减法表达式的类，名字就取为Minus。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装减法表达式的类（属于非终结符表达式角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-19 12:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Minus</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -号左边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="comment">// -号右边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Minus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> {</span><br><span class="line">        <span class="comment">// 将左边表达式的结果和右边表达式的结果进行相减</span></span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 无非就是返回减号左边表达式的字符串表示形式 - 减号右边表达式的字符串表示形式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + left.toString() + <span class="string">" - "</span> + right.toString() + <span class="string">")"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，创建环境类。注意了，大家可千万别忘记了创建该类哟，因为上面的类都要用到它，我们这里是放在了最后来创建的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环境角色类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-19 12:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Map集合，用来存储变量及其对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Variable, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加变量的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(Variable <span class="keyword">var</span>, Integer value)</span> {</span><br><span class="line">        map.put(<span class="keyword">var</span>, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据变量获取对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(Variable <span class="keyword">var</span>)</span> {</span><br><span class="line">        <span class="keyword">return</span> map.get(<span class="keyword">var</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，创建客户端类用于测试。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meimeixia.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liayun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-19 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建环境对象</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个变量对象</span></span><br><span class="line">        <span class="type">Variable</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">"a"</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">"b"</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">"c"</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将变量存储到环境对象中</span></span><br><span class="line">        context.assign(a, <span class="number">1</span>);</span><br><span class="line">        context.assign(b, <span class="number">2</span>);</span><br><span class="line">        context.assign(c, <span class="number">3</span>);</span><br><span class="line">        context.assign(d, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取抽象语法树，例如a + b - c + d就是一棵抽象语法树</span></span><br><span class="line">        <span class="type">AbstractExpression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Minus</span>(a, <span class="keyword">new</span> <span class="title class_">Plus</span>(<span class="keyword">new</span> <span class="title class_">Minus</span>(b, c), d)); <span class="comment">// 通过对应的表达式对象去构建a - ((b - c) + d)这样一棵抽象语法树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解释（加减法计算）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> expression.interpret(context);</span><br><span class="line">        System.out.println(expression + <span class="string">" = "</span> + result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，运行以上客户端类的代码，打印结果如下图所示，可以看到确实是我们所想要的结果，因为1-((2-3)+4)的结果就是-2。</p>
<p><img src="/./assets/1709707034671-f1f0e1ce-b4de-4d9d-b156-8ce1475e2bad.png" alt="img"></p>
<p>当然了，你也可以尝试着去修改一下构建的抽象语法树，然后再来验证一下上面我们写的代码到底有没有问题啊！但我想是没有任何问题的。</p>
<h3 id="6-11-4-解释器模式的优缺点以及使用场景"><a href="#6-11-4-解释器模式的优缺点以及使用场景" class="headerlink" title="6.11.4. 解释器模式的优缺点以及使用场景"></a>6.11.4. 解释器模式的优缺点以及使用场景</h3><p>接下来，我们来看一下解释器模式的优缺点以及使用场景。</p>
<h4 id="6-11-4-1-优缺点"><a href="#6-11-4-1-优缺点" class="headerlink" title="6.11.4.1. 优缺点"></a>6.11.4.1. 优缺点</h4><h5 id="6-11-4-1-1-优点"><a href="#6-11-4-1-1-优点" class="headerlink" title="6.11.4.1.1. 优点"></a>6.11.4.1.1. 优点</h5><p>关于解释器模式的优点，我总结出来了如下三点。</p>
<ol>
<li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。上面这段话，聪明的童鞋肯定能看得懂，但是有些人或许还是不能看懂，所以，我觉得有必要对上面这段话解释一番。先来看在解释器模式中使用类来表示语言的文法规则这句话，文法规则，我相信大家都明白是啥，就拿上述案例来说，我们定义的文法规则它里面包含的无非就是一些变量、加法表达式以及减法表达式。对于变量来说，我们是使用Variable类来表示它的文法规则的，即获取变量对应的值；对于加法表达式来说，我们是使用Plus类来表示它的文法规则的，即将加号左边表达式的结果和右边表达式的结果进行相加；对于减法表达式来说，我们是使用Minus类来表示它的文法规则的，即将减号左边表达式的结果和右边表达式的结果进行相减。所以，每一条文法规则都可以表示为一个类。再来看可以通过继承等机制来改变或扩展文法这句话，这句话说的啥意思呢？举个例子，假如现在我们想要定义一个乘法表达式的文法规则，那么应该怎么办呢？很简单，我们只需要定义一个类，让它去继承抽象表达式类就可以了。</li>
<li>实现文法较为容易。在抽象语法树中，每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。还是拿上述案例来说，对于Variable这个封装变量的表达式类而言，它里边的代码实现还是比较简单的，而且也符合我们人类思考的逻辑，因为对于一个变量来说，我们无非就是从它里面去获取对应的数据；对于Plus这个封装加法表达式的表达式类而言，它里边的代码实现也是比较简单的，而且同样也符合我们人类思考的逻辑，不就是把加号两边表达式的结果进行一个相加吗？对于Minus这个封装减法表达式的表达式类而言，也是同样的一个道理。</li>
<li>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式，那么他只需要对应增加一个新的终结符表达式或非终结符表达式类即可，而且原有表达式类代码无须修改，很显然，这符合”开闭原则”。</li>
</ol>
<h5 id="6-11-4-1-2-缺点"><a href="#6-11-4-1-2-缺点" class="headerlink" title="6.11.4.1.2. 缺点"></a>6.11.4.1.2. 缺点</h5><p>关于解释器模式的缺点，我总结出来了如下两点。</p>
<ol>
<li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，那么类的个数将会急剧增加，从而导致系统难以管理和维护。也就是说，如果给定语言的文法规则特别复杂的话，那么我们就需要定义很多抽象表达式的子类了，这样的话，会显得我们的系统特别特别庞大，从而也就导致了系统难以管理和维护。</li>
<li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度会很慢，而且代码的调试过程也会变得比较麻烦。有些人可能会说，在上述案例的解释器模式中，到底用的是循环还是递归啊？其实使用的是递归啊！大家不妨去看一下Minus、Plus这些表达式类，你会发现它们不仅继承了AbstractExpression类，而且还聚合进来了该类的对象，所以这就是递归。对于递归来说，它必须是要有出口的，那么这里面的出口又是什么呢？很显然，是变量。因为对于终结符表达式（即Variable这个封装变量的表达式类）而言，调用其interpret方法获取的就是其封装的变量的值，而对于非终结符表达式而言，调用其interpret方法时，又会去调用其他表达式类里面的interpret方法，这不就是递归调用吗？</li>
</ol>
<h4 id="6-11-4-2-使用场景"><a href="#6-11-4-2-使用场景" class="headerlink" title="6.11.4.2. 使用场景"></a>6.11.4.2. 使用场景</h4><p>只要出现如下几个场景，我们就可以去考虑一下能不能使用解释器模式了。</p>
<ul>
<li>当语言的文法较为简单，且执行效率不是关键问题时，完美地把上面的两个缺点给避开了。</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</li>
</ul>
<p>至此，23种设计模式的讲解就到此为止了，完美落幕😘！谢谢努力而又无私奉献的自己👍！</p>
<hr>
<hr>
<h1 id="7-在自定义Spring框架"><a href="#7-在自定义Spring框架" class="headerlink" title="7. 在自定义Spring框架"></a>7. 在自定义Spring框架</h1>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Saber</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://leistia.github.io/categories/develop/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">http://leistia.github.io/categories/develop/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Saber</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/">
                                    <span class="chip bg-color"></span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/categories/develop/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="IO流详解">
                        
                        <span class="card-title">IO流详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-09-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/" class="post-category">
                                    
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/">
                        <span class="chip bg-color"></span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/categories/develop/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="IO流详解">
                        
                        <span class="card-title">IO流详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-09-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/" class="post-category">
                                    
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/">
                        <span class="chip bg-color"></span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 嘟噜嘟~<br />'
            + '文章作者: Saber<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '随便借鉴好吧(我就是缝合怪)';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



 <!-- 天气插件 -->
 <div id="ww_700f0fa94d372" v='1.3' loc='id' a='{"t":"responsive","lang":"zh-Hant","sl_lpl":1,"ids":[],"font":"Arial","sl_ics":"one_a","sl_sot":"celsius","cl_bkg":"#0097A7","cl_font":"#FFFFFF","cl_cloud":"#FFFFFF","cl_persp":"#FFFFFF","cl_sun":"#FFC107","cl_moon":"#FFC107","cl_thund":"#FF5722","cl_odd":"#0000000a"}'><a href="https://weatherwidget.org/" id="ww_700f0fa94d372_u" target="_blank">Html weather widget</a></div><script async src="https://app2.weatherwidget.org/js/?id=ww_700f0fa94d372"></script>
    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <span id="year">2024</span>
            <a href="/about" target="_blank">Saber</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">8</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            

            
                <div class="translate-style">
                    繁/简：<a id="translateLink" href="javascript:translatePage();">繁体
                    </a>
                </div>
                <script type="text/javascript" src="/js/tw_cn.js"></script>
                    <script type="text/javascript">
                    var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
                    var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
                    var cookieDomain = "https://1han.wiki/"; //Cookie地址, 一定要设定, 通常为你的网址
                    var msgToTraditionalChinese = "繁体"; //此处可以更改为你想要显示的文字
                    var msgToSimplifiedChinese = "简体"; //同上，但两处均不建议更改
                    var translateButtonId = "translateLink"; //默认互换id
                    translateInitilization();
                 </script>
                

        
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Leistia" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1705551409@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1705551409" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1705551409" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>



    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

  <!-- ------------------------------------------------------ -->
    
        <script type="text/javascript">
            //只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
            }
        </script>
    
    
    
        <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/wenzi.js"><\/script>');
        }
        </script>
    
    <!-- 添加鼠标点击烟花爆炸效果 -->
    
        <canvas class="fireworks" style="position: fixed; left: 0; top: 0; z-index: 1; pointer-events: none;" ></canvas>
        <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
        <script type="text/javascript" src="/js/fireworks.js"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":150,"height":350,"hOffset":50,"vOffset":-5},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>

</html>
